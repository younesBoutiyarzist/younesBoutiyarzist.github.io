(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[179],{878:(Ce,Te,U)=>{"use strict";var fe={};U.r(fe),U.d(fe,{assertParamsValid:()=>$D,computeFlatOffset:()=>BD,computeOutShape:()=>LD,getNormalizedAxes:()=>Jte,isSliceContinous:()=>VD,maskToAxes:()=>Qte,parseSliceParams:()=>a_,sliceInfo:()=>zD,startForAxis:()=>M2,startIndicesWithElidedDims:()=>N2,stopForAxis:()=>O2,stopIndicesWithElidedDims:()=>A2,stridesForAxis:()=>R2,stridesWithElidedDims:()=>I2});var ht={};U.r(ht),U.d(ht,{collectGatherOpShapeInfo:()=>KS,computeOutShape:()=>P$,segOpComputeOptimalWindowSize:()=>F$});var se={};U.r(se),U.d(se,{ERF_A1:()=>OS,ERF_A2:()=>FS,ERF_A3:()=>PS,ERF_A4:()=>$S,ERF_A5:()=>LS,ERF_P:()=>MS,PARALLELIZE_THRESHOLD:()=>TS,SELU_SCALE:()=>k_,SELU_SCALEALPHA:()=>T_,applyActivation:()=>w_,assertAndGetBroadcastShape:()=>gt,assertAxesAreInnerMostDims:()=>Ir,assertParamsConsistent:()=>IS,assignToTypedArray:()=>v$,axesAreInnerMostDims:()=>QD,calculateShapes:()=>qf,checkEinsumDimSizes:()=>HS,checkPadOnDimRoundingMode:()=>Gr,combineLocations:()=>j2,complexWithEvenIndex:()=>y$,complexWithOddIndex:()=>_$,computeConv2DInfo:()=>gr,computeConv3DInfo:()=>Ra,computeDefaultPad:()=>jD,computeDilation2DInfo:()=>Lf,computeOptimalWindowSize:()=>I_,computeOutAndReduceShapes:()=>yr,computeOutShape:()=>yo,computePool2DInfo:()=>ui,computePool3DInfo:()=>Go,convertConv2DDataFormat:()=>qo,decodeEinsumEquation:()=>zS,eitherStridesOrDilationsAreOne:()=>Er,expandShapeToKeepDim:()=>Bn,exponent:()=>x$,exponents:()=>b$,fromStringArrayToUint8:()=>$$,fromUint8ToStringArray:()=>Ul,getAxesPermutation:()=>Sn,getBroadcastDims:()=>xu,getComplexWithIndex:()=>VS,getEinsumComputePath:()=>jS,getEinsumPermutation:()=>US,getFusedBiasGradient:()=>x_,getFusedDyActivation:()=>b_,getImageCenter:()=>kS,getInnerMostAxes:()=>An,getPermuted:()=>Wf,getReductionAxes:()=>er,getReshaped:()=>jf,getReshapedPermuted:()=>Gf,getSliceBeginCoords:()=>NS,getSliceSize:()=>AS,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>D$,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>S$,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>E$,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>k$,getSparseReshapeInputOutputMismatchErrorMessage:()=>A$,getSparseReshapeInputOutputMultipleErrorMessage:()=>N$,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>I$,getSparseReshapeNegativeOutputDimErrorMessage:()=>T$,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>O$,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>qS,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>R$,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>M$,getUndoAxesPermutation:()=>Fa,isIdentityPermutation:()=>WS,log:()=>Fee,mergeRealAndImagArrays:()=>Zo,prepareAndValidate:()=>RS,prepareSplitSize:()=>GS,segment_util:()=>ht,shouldFuse:()=>C_,slice_util:()=>fe,splitRealAndImagArrays:()=>g$,tupleValuesAreOne:()=>Ma,upcastType:()=>_s,validateInput:()=>ioe,validateUpdateShape:()=>m$,warn:()=>Vs});var tt={};function de(n){return"function"==typeof n}function xe(n){const e=n(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}U.r(tt),U.d(tt,{addImpl:()=>aB,bincountImpl:()=>rI,bincountReduceImpl:()=>fB,ceilImpl:()=>pB,concatImpl:()=>mB,equalImpl:()=>_B,expImpl:()=>bB,expm1Impl:()=>wB,floorImpl:()=>SB,gatherNdImpl:()=>EB,gatherV2Impl:()=>IB,greaterEqualImpl:()=>kB,greaterImpl:()=>TB,lessEqualImpl:()=>AB,lessImpl:()=>NB,linSpaceImpl:()=>RB,logImpl:()=>MB,maxImpl:()=>OB,maximumImpl:()=>PB,minimumImpl:()=>$B,multiplyImpl:()=>sI,negImpl:()=>VB,notEqualImpl:()=>BB,prodImpl:()=>jB,rangeImpl:()=>WB,rsqrtImpl:()=>GB,sigmoidImpl:()=>vhe,simpleAbsImpl:()=>cB,sliceImpl:()=>hB,sparseFillEmptyRowsImpl:()=>XB,sparseReshapeImpl:()=>YB,sparseSegmentReductionImpl:()=>uI,sqrtImpl:()=>Eye,squaredDifferenceImpl:()=>ZB,stridedSliceImpl:()=>QB,stringNGramsImpl:()=>JB,stringSplitImpl:()=>e3,stringToHashBucketFastImpl:()=>t3,subImpl:()=>CB,tileImpl:()=>n3,topKImpl:()=>s3,transposeImpl:()=>tI,uniqueImpl:()=>a3});const pe=xe(n=>function(e){n(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function B(n,t){if(n){const e=n.indexOf(t);0<=e&&n.splice(e,1)}}class x{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const i of e)i.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(de(r))try{r()}catch(i){t=i instanceof pe?i.errors:[i]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const i of s)try{D(i)}catch(o){t=null!=t?t:[],o instanceof pe?t=[...t,...o.errors]:t.push(o)}}if(t)throw new pe(t)}}add(t){var e;if(t&&t!==this)if(this.closed)D(t);else{if(t instanceof x){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(t)}}_hasParent(t){const{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){const{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&B(e,t)}remove(t){const{_finalizers:e}=this;e&&B(e,t),t instanceof x&&t._removeParent(this)}}x.EMPTY=(()=>{const n=new x;return n.closed=!0,n})();const N=x.EMPTY;function F(n){return n instanceof x||n&&"closed"in n&&de(n.remove)&&de(n.add)&&de(n.unsubscribe)}function D(n){de(n)?n():n.unsubscribe()}const I={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},H={setTimeout(n,t,...e){const{delegate:r}=H;return(null==r?void 0:r.setTimeout)?r.setTimeout(n,t,...e):setTimeout(n,t,...e)},clearTimeout(n){const{delegate:t}=H;return((null==t?void 0:t.clearTimeout)||clearTimeout)(n)},delegate:void 0};function q(n){H.setTimeout(()=>{const{onUnhandledError:t}=I;if(!t)throw n;t(n)})}function Ye(){}const Rt=mn("C",void 0,void 0);function mn(n,t,e){return{kind:n,value:t,error:e}}let _e=null;function Ee(n){if(I.useDeprecatedSynchronousErrorHandling){const t=!_e;if(t&&(_e={errorThrown:!1,error:null}),n(),t){const{errorThrown:e,error:r}=_e;if(_e=null,e)throw r}}else n()}class ie extends x{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,F(t)&&t.add(this)):this.destination=jt}static create(t,e,r){return new ke(t,e,r)}next(t){this.isStopped?st(function On(n){return mn("N",n,void 0)}(t),this):this._next(t)}error(t){this.isStopped?st(function bt(n){return mn("E",void 0,n)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?st(Rt,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const Y=Function.prototype.bind;function R(n,t){return Y.call(n,t)}class ve{constructor(t){this.partialObserver=t}next(t){const{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(r){Qe(r)}}error(t){const{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(r){Qe(r)}else Qe(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){Qe(e)}}}class ke extends ie{constructor(t,e,r){let s;if(super(),de(t)||!t)s={next:null!=t?t:void 0,error:null!=e?e:void 0,complete:null!=r?r:void 0};else{let i;this&&I.useDeprecatedNextContext?(i=Object.create(t),i.unsubscribe=()=>this.unsubscribe(),s={next:t.next&&R(t.next,i),error:t.error&&R(t.error,i),complete:t.complete&&R(t.complete,i)}):s=t}this.destination=new ve(s)}}function Qe(n){I.useDeprecatedSynchronousErrorHandling?function We(n){I.useDeprecatedSynchronousErrorHandling&&_e&&(_e.errorThrown=!0,_e.error=n)}(n):q(n)}function st(n,t){const{onStoppedNotification:e}=I;e&&H.setTimeout(()=>e(n,t))}const jt={closed:!0,next:Ye,error:function Xe(n){throw n},complete:Ye},Lt="function"==typeof Symbol&&Symbol.observable||"@@observable";function gn(n){return n}let ct=(()=>{class n{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new n;return r.source=this,r.operator=e,r}subscribe(e,r,s){const i=function sU(n){return n&&n instanceof ie||function rc(n){return n&&de(n.next)&&de(n.error)&&de(n.complete)}(n)&&F(n)}(e)?e:new ke(e,r,s);return Ee(()=>{const{operator:o,source:a}=this;i.add(o?o.call(i,a):a?this._subscribe(i):this._trySubscribe(i))}),i}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=Vr(r))((s,i)=>{const o=new ke({next:a=>{try{e(a)}catch(l){i(l),o.unsubscribe()}},error:i,complete:s});this.subscribe(o)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[Lt](){return this}pipe(...e){return function Zr(n){return 0===n.length?gn:1===n.length?n[0]:function(e){return n.reduce((r,s)=>s(r),e)}}(e)(this)}toPromise(e){return new(e=Vr(e))((r,s)=>{let i;this.subscribe(o=>i=o,o=>s(o),()=>r(i))})}}return n.create=t=>new n(t),n})();function Vr(n){var t;return null!==(t=null!=n?n:I.Promise)&&void 0!==t?t:Promise}const iU=xe(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let Ge=(()=>{class n extends ct{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new PI(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new iU}next(e){Ee(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){Ee(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){Ee(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:s,observers:i}=this;return r||s?N:(this.currentObservers=null,i.push(e),new x(()=>{this.currentObservers=null,B(i,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:s,isStopped:i}=this;r?e.error(s):i&&e.complete()}asObservable(){const e=new ct;return e.source=this,e}}return n.create=(t,e)=>new PI(t,e),n})();class PI extends Ge{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,t)}error(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,t)}complete(){var t,e;null===(e=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===e||e.call(t)}_subscribe(t){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(t))&&void 0!==r?r:N}}function $I(n){return de(null==n?void 0:n.lift)}function jn(n){return t=>{if($I(t))return t.lift(function(e){try{return n(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function In(n,t,e,r,s){return new oU(n,t,e,r,s)}class oU extends ie{constructor(t,e,r,s,i,o){super(t),this.onFinalize=i,this.shouldUnsubscribe=o,this._next=e?function(a){try{e(a)}catch(l){t.error(l)}}:super._next,this._error=s?function(a){try{s(a)}catch(l){t.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function Et(n,t){return jn((e,r)=>{let s=0;e.subscribe(In(r,i=>{r.next(n.call(t,i,s++))}))})}function Ja(n){return this instanceof Ja?(this.v=n,this):new Ja(n)}function cU(n,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=e.apply(n,t||[]),i=[];return s={},o("next"),o("throw"),o("return"),s[Symbol.asyncIterator]=function(){return this},s;function o(h){r[h]&&(s[h]=function(f){return new Promise(function(p,m){i.push([h,f,p,m])>1||a(h,f)})})}function a(h,f){try{!function l(h){h.value instanceof Ja?Promise.resolve(h.value.v).then(c,u):d(i[0][2],h)}(r[h](f))}catch(p){d(i[0][3],p)}}function c(h){a("next",h)}function u(h){a("throw",h)}function d(h,f){h(f),i.shift(),i.length&&a(i[0][0],i[0][1])}}function uU(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,t=n[Symbol.asyncIterator];return t?t.call(n):(n=function BI(n){var t="function"==typeof Symbol&&Symbol.iterator,e=t&&n[t],r=0;if(e)return e.call(n);if(n&&"number"==typeof n.length)return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(n),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(i){e[i]=n[i]&&function(o){return new Promise(function(a,l){!function s(i,o,a,l){Promise.resolve(l).then(function(c){i({value:c,done:a})},o)}(a,l,(o=n[i](o)).done,o.value)})}}}const Ov=n=>n&&"number"==typeof n.length&&"function"!=typeof n;function zI(n){return de(null==n?void 0:n.then)}function UI(n){return de(n[Lt])}function HI(n){return Symbol.asyncIterator&&de(null==n?void 0:n[Symbol.asyncIterator])}function jI(n){return new TypeError(`You provided ${null!==n&&"object"==typeof n?"an invalid object":`'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const WI=function hU(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function GI(n){return de(null==n?void 0:n[WI])}function qI(n){return cU(this,arguments,function*(){const e=n.getReader();try{for(;;){const{value:r,done:s}=yield Ja(e.read());if(s)return yield Ja(void 0);yield yield Ja(r)}}finally{e.releaseLock()}})}function KI(n){return de(null==n?void 0:n.getReader)}function Ds(n){if(n instanceof ct)return n;if(null!=n){if(UI(n))return function fU(n){return new ct(t=>{const e=n[Lt]();if(de(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(n);if(Ov(n))return function pU(n){return new ct(t=>{for(let e=0;e<n.length&&!t.closed;e++)t.next(n[e]);t.complete()})}(n);if(zI(n))return function mU(n){return new ct(t=>{n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,q)})}(n);if(HI(n))return XI(n);if(GI(n))return function gU(n){return new ct(t=>{for(const e of n)if(t.next(e),t.closed)return;t.complete()})}(n);if(KI(n))return function yU(n){return XI(qI(n))}(n)}throw jI(n)}function XI(n){return new ct(t=>{(function _U(n,t){var e,r,s,i;return function aU(n,t,e,r){return new(e||(e=Promise))(function(i,o){function a(u){try{c(r.next(u))}catch(d){o(d)}}function l(u){try{c(r.throw(u))}catch(d){o(d)}}function c(u){u.done?i(u.value):function s(i){return i instanceof e?i:new e(function(o){o(i)})}(u.value).then(a,l)}c((r=r.apply(n,t||[])).next())})}(this,void 0,void 0,function*(){try{for(e=uU(n);!(r=yield e.next()).done;)if(t.next(r.value),t.closed)return}catch(o){s={error:o}}finally{try{r&&!r.done&&(i=e.return)&&(yield i.call(e))}finally{if(s)throw s.error}}t.complete()})})(n,t).catch(e=>t.error(e))})}function So(n,t,e,r=0,s=!1){const i=t.schedule(function(){e(),s?n.add(this.schedule(null,r)):this.unsubscribe()},r);if(n.add(i),!s)return i}function ir(n,t,e=1/0){return de(t)?ir((r,s)=>Et((i,o)=>t(r,i,s,o))(Ds(n(r,s))),e):("number"==typeof t&&(e=t),jn((r,s)=>function vU(n,t,e,r,s,i,o,a){const l=[];let c=0,u=0,d=!1;const h=()=>{d&&!l.length&&!c&&t.complete()},f=m=>c<r?p(m):l.push(m),p=m=>{i&&t.next(m),c++;let g=!1;Ds(e(m,u++)).subscribe(In(t,_=>{null==s||s(_),i?f(_):t.next(_)},()=>{g=!0},void 0,()=>{if(g)try{for(c--;l.length&&c<r;){const _=l.shift();o?So(t,o,()=>p(_)):p(_)}h()}catch(_){t.error(_)}}))};return n.subscribe(In(t,f,()=>{d=!0,h()})),()=>{null==a||a()}}(r,s,n,e)))}function rd(n=1/0){return ir(gn,n)}const Eo=new ct(n=>n.complete());function YI(n){return n&&de(n.schedule)}function Fv(n){return n[n.length-1]}function ZI(n){return de(Fv(n))?n.pop():void 0}function sd(n){return YI(Fv(n))?n.pop():void 0}function QI(n,t=0){return jn((e,r)=>{e.subscribe(In(r,s=>So(r,n,()=>r.next(s),t),()=>So(r,n,()=>r.complete(),t),s=>So(r,n,()=>r.error(s),t)))})}function JI(n,t=0){return jn((e,r)=>{r.add(n.schedule(()=>e.subscribe(r),t))})}function eT(n,t){if(!n)throw new Error("Iterable cannot be null");return new ct(e=>{So(e,t,()=>{const r=n[Symbol.asyncIterator]();So(e,t,()=>{r.next().then(s=>{s.done?e.complete():e.next(s.value)})},0,!0)})})}function Ar(n,t){return t?function IU(n,t){if(null!=n){if(UI(n))return function wU(n,t){return Ds(n).pipe(JI(t),QI(t))}(n,t);if(Ov(n))return function DU(n,t){return new ct(e=>{let r=0;return t.schedule(function(){r===n.length?e.complete():(e.next(n[r++]),e.closed||this.schedule())})})}(n,t);if(zI(n))return function CU(n,t){return Ds(n).pipe(JI(t),QI(t))}(n,t);if(HI(n))return eT(n,t);if(GI(n))return function SU(n,t){return new ct(e=>{let r;return So(e,t,()=>{r=n[WI](),So(e,t,()=>{let s,i;try{({value:s,done:i}=r.next())}catch(o){return void e.error(o)}i?e.complete():e.next(s)},0,!0)}),()=>de(null==r?void 0:r.return)&&r.return()})}(n,t);if(KI(n))return function EU(n,t){return eT(qI(n),t)}(n,t)}throw jI(n)}(n,t):Ds(n)}function id(...n){const t=sd(n),e=function xU(n,t){return"number"==typeof Fv(n)?n.pop():t}(n,1/0),r=n;return r.length?1===r.length?Ds(r[0]):rd(e)(Ar(r,t)):Eo}function Br(n){return n<=0?()=>Eo:jn((t,e)=>{let r=0;t.subscribe(In(e,s=>{++r<=n&&(e.next(s),n<=r&&e.complete())}))})}function tT(n={}){const{connector:t=(()=>new Ge),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:s=!0}=n;return i=>{let o=null,a=null,l=null,c=0,u=!1,d=!1;const h=()=>{null==a||a.unsubscribe(),a=null},f=()=>{h(),o=l=null,u=d=!1},p=()=>{const m=o;f(),null==m||m.unsubscribe()};return jn((m,g)=>{c++,!d&&!u&&h();const _=l=null!=l?l:t();g.add(()=>{c--,0===c&&!d&&!u&&(a=Pv(p,s))}),_.subscribe(g),o||(o=new ke({next:y=>_.next(y),error:y=>{d=!0,h(),a=Pv(f,e,y),_.error(y)},complete:()=>{u=!0,h(),a=Pv(f,r),_.complete()}}),Ar(m).subscribe(o))})(i)}}function Pv(n,t,...e){return!0===t?(n(),null):!1===t?null:t(...e).pipe(Br(1)).subscribe(()=>n())}function nn(n){for(let t in n)if(n[t]===nn)return t;throw Error("Could not find renamed property on target object.")}function $v(n,t){for(const e in t)t.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(n[e]=t[e])}function Xt(n){if("string"==typeof n)return n;if(Array.isArray(n))return"["+n.map(Xt).join(", ")+"]";if(null==n)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return""+t;const e=t.indexOf("\n");return-1===e?t:t.substring(0,e)}function Lv(n,t){return null==n||""===n?null===t?"":t:null==t||""===t?n:n+" "+t}const TU=nn({__forward_ref__:nn});function od(n){return n.__forward_ref__=od,n.toString=function(){return Xt(this())},n}function xt(n){return nT(n)?n():n}function nT(n){return"function"==typeof n&&n.hasOwnProperty(TU)&&n.__forward_ref__===od}class je extends Error{constructor(t,e){super(function Vv(n,t){return`NG0${Math.abs(n)}${t?": "+t:""}`}(t,e)),this.code=t}}function pt(n){return"string"==typeof n?n:null==n?"":String(n)}function Qr(n){return"function"==typeof n?n.name||n.toString():"object"==typeof n&&null!=n&&"function"==typeof n.type?n.type.name||n.type.toString():pt(n)}function Cp(n,t){const e=t?` in ${t}`:"";throw new je(-201,`No provider for ${Qr(n)} found${e}`)}function Es(n,t){null==n&&function yn(n,t,e,r){throw new Error(`ASSERTION ERROR: ${n}`+(null==r?"":` [Expected=> ${e} ${r} ${t} <=Actual]`))}(t,n,null,"!=")}function Ve(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function Jt(n){return{providers:n.providers||[],imports:n.imports||[]}}function Bv(n){return rT(n,Dp)||rT(n,iT)}function rT(n,t){return n.hasOwnProperty(t)?n[t]:null}function sT(n){return n&&(n.hasOwnProperty(zv)||n.hasOwnProperty(FU))?n[zv]:null}const Dp=nn({\u0275prov:nn}),zv=nn({\u0275inj:nn}),iT=nn({ngInjectableDef:nn}),FU=nn({ngInjectorDef:nn});var ut=(()=>((ut=ut||{})[ut.Default=0]="Default",ut[ut.Host=1]="Host",ut[ut.Self=2]="Self",ut[ut.SkipSelf=4]="SkipSelf",ut[ut.Optional=8]="Optional",ut))();let Uv;function ra(n){const t=Uv;return Uv=n,t}function oT(n,t,e){const r=Bv(n);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&ut.Optional?null:void 0!==t?t:void Cp(Xt(n),"Injector")}function sa(n){return{toString:n}.toString()}var bi=(()=>((bi=bi||{})[bi.OnPush=0]="OnPush",bi[bi.Default=1]="Default",bi))(),xi=(()=>{return(n=xi||(xi={}))[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",xi;var n})();const $U="undefined"!=typeof globalThis&&globalThis,LU="undefined"!=typeof window&&window,VU="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,en=$U||"undefined"!=typeof global&&global||LU||VU,sc={},rn=[],Sp=nn({\u0275cmp:nn}),Hv=nn({\u0275dir:nn}),jv=nn({\u0275pipe:nn}),aT=nn({\u0275mod:nn}),To=nn({\u0275fac:nn}),ad=nn({__NG_ELEMENT_ID__:nn});let BU=0;function Wn(n){return sa(()=>{const e={},r={type:n.type,providersResolver:null,decls:n.decls,vars:n.vars,factory:null,template:n.template||null,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:e,inputs:null,outputs:null,exportAs:n.exportAs||null,onPush:n.changeDetection===bi.OnPush,directiveDefs:null,pipeDefs:null,selectors:n.selectors||rn,viewQuery:n.viewQuery||null,features:n.features||null,data:n.data||{},encapsulation:n.encapsulation||xi.Emulated,id:"c",styles:n.styles||rn,_:null,setInput:null,schemas:n.schemas||null,tView:null},s=n.directives,i=n.features,o=n.pipes;return r.id+=BU++,r.inputs=dT(n.inputs,e),r.outputs=dT(n.outputs),i&&i.forEach(a=>a(r)),r.directiveDefs=s?()=>("function"==typeof s?s():s).map(lT):null,r.pipeDefs=o?()=>("function"==typeof o?o():o).map(cT):null,r})}function lT(n){return zr(n)||function ia(n){return n[Hv]||null}(n)}function cT(n){return function el(n){return n[jv]||null}(n)}const uT={};function sn(n){return sa(()=>{const t={type:n.type,bootstrap:n.bootstrap||rn,declarations:n.declarations||rn,imports:n.imports||rn,exports:n.exports||rn,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null};return null!=n.id&&(uT[n.id]=n.type),t})}function dT(n,t){if(null==n)return sc;const e={};for(const r in n)if(n.hasOwnProperty(r)){let s=n[r],i=s;Array.isArray(s)&&(i=s[1],s=s[0]),e[s]=r,t&&(t[s]=i)}return e}const un=Wn;function zr(n){return n[Sp]||null}function qs(n,t){const e=n[aT]||null;if(!e&&!0===t)throw new Error(`Type ${Xt(n)} does not have '\u0275mod' property.`);return e}function Ki(n){return Array.isArray(n)&&"object"==typeof n[1]}function Ci(n){return Array.isArray(n)&&!0===n[1]}function qv(n){return 0!=(8&n.flags)}function kp(n){return 2==(2&n.flags)}function Np(n){return 1==(1&n.flags)}function Di(n){return null!==n.template}function GU(n){return 0!=(512&n[2])}function sl(n,t){return n.hasOwnProperty(To)?n[To]:null}class XU{constructor(t,e,r){this.previousValue=t,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function ko(){return fT}function fT(n){return n.type.prototype.ngOnChanges&&(n.setInput=ZU),YU}function YU(){const n=mT(this),t=null==n?void 0:n.current;if(t){const e=n.previous;if(e===sc)n.previous=t;else for(let r in t)e[r]=t[r];n.current=null,this.ngOnChanges(t)}}function ZU(n,t,e,r){const s=mT(n)||function QU(n,t){return n[pT]=t}(n,{previous:sc,current:null}),i=s.current||(s.current={}),o=s.previous,a=this.declaredInputs[e],l=o[a];i[a]=new XU(l&&l.currentValue,t,o===sc),n[r]=t}ko.ngInherit=!0;const pT="__ngSimpleChanges__";function mT(n){return n[pT]||null}let Qv;function Fn(n){return!!n.listen}const gT={createRenderer:(n,t)=>function Jv(){return void 0!==Qv?Qv:"undefined"!=typeof document?document:void 0}()};function Xn(n){for(;Array.isArray(n);)n=n[0];return n}function Ap(n,t){return Xn(t[n])}function Ys(n,t){return Xn(t[n.index])}function eb(n,t){return n.data[t]}function Ts(n,t){const e=t[n];return Ki(e)?e:e[0]}function yT(n){return 4==(4&n[2])}function tb(n){return 128==(128&n[2])}function oa(n,t){return null==t?null:n[t]}function _T(n){n[18]=0}function nb(n,t){n[5]+=t;let e=n,r=n[3];for(;null!==r&&(1===t&&1===e[5]||-1===t&&0===e[5]);)r[5]+=t,e=r,r=r[3]}const dt={lFrame:ET(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function vT(){return dt.bindingsEnabled}function ye(){return dt.lFrame.lView}function Vt(){return dt.lFrame.tView}function No(n){return dt.lFrame.contextLView=n,n[8]}function or(){let n=bT();for(;null!==n&&64===n.type;)n=n.parent;return n}function bT(){return dt.lFrame.currentTNode}function Xi(n,t){const e=dt.lFrame;e.currentTNode=n,e.isParent=t}function rb(){return dt.lFrame.isParent}function sb(){dt.lFrame.isParent=!1}function Rp(){return dt.isInCheckNoChangesMode}function Mp(n){dt.isInCheckNoChangesMode=n}function Jr(){const n=dt.lFrame;let t=n.bindingRootIndex;return-1===t&&(t=n.bindingRootIndex=n.tView.bindingStartIndex),t}function uc(){return dt.lFrame.bindingIndex++}function mH(n,t){const e=dt.lFrame;e.bindingIndex=e.bindingRootIndex=n,ib(t)}function ib(n){dt.lFrame.currentDirectiveIndex=n}function ob(n){const t=dt.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}function CT(){return dt.lFrame.currentQueryIndex}function ab(n){dt.lFrame.currentQueryIndex=n}function yH(n){const t=n[1];return 2===t.type?t.declTNode:1===t.type?n[6]:null}function DT(n,t,e){if(e&ut.SkipSelf){let s=t,i=n;for(;!(s=s.parent,null!==s||e&ut.Host||(s=yH(i),null===s||(i=i[15],10&s.type))););if(null===s)return!1;t=s,n=i}const r=dt.lFrame=ST();return r.currentTNode=t,r.lView=n,!0}function Op(n){const t=ST(),e=n[1];dt.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function ST(){const n=dt.lFrame,t=null===n?null:n.child;return null===t?ET(n):t}function ET(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&&(n.child=t),t}function IT(){const n=dt.lFrame;return dt.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const TT=IT;function Fp(){const n=IT();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function es(){return dt.lFrame.selectedIndex}function aa(n){dt.lFrame.selectedIndex=n}function Pn(){const n=dt.lFrame;return eb(n.tView,n.selectedIndex)}function Pp(n,t){for(let e=t.directiveStart,r=t.directiveEnd;e<r;e++){const i=n.data[e].type.prototype,{ngAfterContentInit:o,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:c,ngOnDestroy:u}=i;o&&(n.contentHooks||(n.contentHooks=[])).push(-e,o),a&&((n.contentHooks||(n.contentHooks=[])).push(e,a),(n.contentCheckHooks||(n.contentCheckHooks=[])).push(e,a)),l&&(n.viewHooks||(n.viewHooks=[])).push(-e,l),c&&((n.viewHooks||(n.viewHooks=[])).push(e,c),(n.viewCheckHooks||(n.viewCheckHooks=[])).push(e,c)),null!=u&&(n.destroyHooks||(n.destroyHooks=[])).push(e,u)}}function $p(n,t,e){kT(n,t,3,e)}function Lp(n,t,e,r){(3&n[2])===e&&kT(n,t,e,r)}function lb(n,t){let e=n[2];(3&e)===t&&(e&=2047,e+=1,n[2]=e)}function kT(n,t,e,r){const i=null!=r?r:-1,o=t.length-1;let a=0;for(let l=void 0!==r?65535&n[18]:0;l<o;l++)if("number"==typeof t[l+1]){if(a=t[l],null!=r&&a>=r)break}else t[l]<0&&(n[18]+=65536),(a<i||-1==i)&&(EH(n,e,t,l),n[18]=(4294901760&n[18])+l+2),l++}function EH(n,t,e,r){const s=e[r]<0,i=e[r+1],a=n[s?-e[r]:e[r]];if(s){if(n[2]>>11<n[18]>>16&&(3&n[2])===t){n[2]+=2048;try{i.call(a)}finally{}}}else try{i.call(a)}finally{}}class hd{constructor(t,e,r){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function Vp(n,t,e){const r=Fn(n);let s=0;for(;s<e.length;){const i=e[s];if("number"==typeof i){if(0!==i)break;s++;const o=e[s++],a=e[s++],l=e[s++];r?n.setAttribute(t,a,l,o):t.setAttributeNS(o,a,l)}else{const o=i,a=e[++s];ub(o)?r&&n.setProperty(t,o,a):r?n.setAttribute(t,o,a):t.setAttribute(o,a),s++}}return s}function NT(n){return 3===n||4===n||6===n}function ub(n){return 64===n.charCodeAt(0)}function Bp(n,t){if(null!==t&&0!==t.length)if(null===n||0===n.length)n=t.slice();else{let e=-1;for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?e=s:0===e||AT(n,e,s,null,-1===e||2===e?t[++r]:null)}}return n}function AT(n,t,e,r,s){let i=0,o=n.length;if(-1===t)o=-1;else for(;i<n.length;){const a=n[i++];if("number"==typeof a){if(a===t){o=-1;break}if(a>t){o=i-1;break}}}for(;i<n.length;){const a=n[i];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(n[i+1]=s));if(r===n[i+1])return void(n[i+2]=s)}i++,null!==r&&i++,null!==s&&i++}-1!==o&&(n.splice(o,0,t),i=o+1),n.splice(i++,0,e),null!==r&&n.splice(i++,0,r),null!==s&&n.splice(i++,0,s)}function RT(n){return-1!==n}function dc(n){return 32767&n}function hc(n,t){let e=function AH(n){return n>>16}(n),r=t;for(;e>0;)r=r[15],e--;return r}let db=!0;function zp(n){const t=db;return db=n,t}let RH=0;function pd(n,t){const e=fb(n,t);if(-1!==e)return e;const r=t[1];r.firstCreatePass&&(n.injectorIndex=t.length,hb(r.data,n),hb(t,null),hb(r.blueprint,null));const s=Up(n,t),i=n.injectorIndex;if(RT(s)){const o=dc(s),a=hc(s,t),l=a[1].data;for(let c=0;c<8;c++)t[i+c]=a[o+c]|l[o+c]}return t[i+8]=s,i}function hb(n,t){n.push(0,0,0,0,0,0,0,0,t)}function fb(n,t){return-1===n.injectorIndex||n.parent&&n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function Up(n,t){if(n.parent&&-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let e=0,r=null,s=t;for(;null!==s;){const i=s[1],o=i.type;if(r=2===o?i.declTNode:1===o?s[6]:null,null===r)return-1;if(e++,s=s[15],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return-1}function Hp(n,t,e){!function MH(n,t,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(ad)&&(r=e[ad]),null==r&&(r=e[ad]=RH++);const s=255&r;t.data[n+(s>>5)]|=1<<s}(n,t,e)}function FT(n,t,e){if(e&ut.Optional)return n;Cp(t,"NodeInjector")}function PT(n,t,e,r){if(e&ut.Optional&&void 0===r&&(r=null),0==(e&(ut.Self|ut.Host))){const s=n[9],i=ra(void 0);try{return s?s.get(t,r,e&ut.Optional):oT(t,r,e&ut.Optional)}finally{ra(i)}}return FT(r,t,e)}function $T(n,t,e,r=ut.Default,s){if(null!==n){const i=function $H(n){if("string"==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(ad)?n[ad]:void 0;return"number"==typeof t?t>=0?255&t:FH:t}(e);if("function"==typeof i){if(!DT(t,n,r))return r&ut.Host?FT(s,e,r):PT(t,e,r,s);try{const o=i(r);if(null!=o||r&ut.Optional)return o;Cp(e)}finally{TT()}}else if("number"==typeof i){let o=null,a=fb(n,t),l=-1,c=r&ut.Host?t[16][6]:null;for((-1===a||r&ut.SkipSelf)&&(l=-1===a?Up(n,t):t[a+8],-1!==l&&BT(r,!1)?(o=t[1],a=dc(l),t=hc(l,t)):a=-1);-1!==a;){const u=t[1];if(VT(i,a,u.data)){const d=PH(a,t,e,o,r,c);if(d!==LT)return d}l=t[a+8],-1!==l&&BT(r,t[1].data[a+8]===c)&&VT(i,a,t)?(o=u,a=dc(l),t=hc(l,t)):a=-1}}}return PT(t,e,r,s)}const LT={};function FH(){return new fc(or(),ye())}function PH(n,t,e,r,s,i){const o=t[1],a=o.data[n+8],u=jp(a,o,e,null==r?kp(a)&&db:r!=o&&0!=(3&a.type),s&ut.Host&&i===a);return null!==u?md(t,o,u,a):LT}function jp(n,t,e,r,s){const i=n.providerIndexes,o=t.data,a=1048575&i,l=n.directiveStart,u=i>>20,h=s?a+u:n.directiveEnd;for(let f=r?a:a+u;f<h;f++){const p=o[f];if(f<l&&e===p||f>=l&&p.type===e)return f}if(s){const f=o[l];if(f&&Di(f)&&f.type===e)return l}return null}function md(n,t,e,r){let s=n[e];const i=t.data;if(function IH(n){return n instanceof hd}(s)){const o=s;o.resolving&&function kU(n,t){const e=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new je(-200,`Circular dependency in DI detected for ${n}${e}`)}(Qr(i[e]));const a=zp(o.canSeeViewProviders);o.resolving=!0;const l=o.injectImpl?ra(o.injectImpl):null;DT(n,r,ut.Default);try{s=n[e]=o.factory(void 0,i,n,r),t.firstCreatePass&&e>=r.directiveStart&&function SH(n,t,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:i}=t.type.prototype;if(r){const o=fT(t);(e.preOrderHooks||(e.preOrderHooks=[])).push(n,o),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,o)}s&&(e.preOrderHooks||(e.preOrderHooks=[])).push(0-n,s),i&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n,i),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,i))}(e,i[e],t)}finally{null!==l&&ra(l),zp(a),o.resolving=!1,TT()}}return s}function VT(n,t,e){return!!(e[t+(n>>5)]&1<<n)}function BT(n,t){return!(n&ut.Self||n&ut.Host&&t)}class fc{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,r){return $T(this._tNode,this._lView,t,r,e)}}function pb(n){return nT(n)?()=>{const t=pb(xt(n));return t&&t()}:sl(n)}function pc(n){return function OH(n,t){if("class"===t)return n.classes;if("style"===t)return n.styles;const e=n.attrs;if(e){const r=e.length;let s=0;for(;s<r;){const i=e[s];if(NT(i))break;if(0===i)s+=2;else if("number"==typeof i)for(s++;s<r&&"string"==typeof e[s];)s++;else{if(i===t)return e[s+1];s+=2}}}return null}(or(),n)}const gc="__parameters__";function _c(n,t,e){return sa(()=>{const r=function mb(n){return function(...e){if(n){const r=n(...e);for(const s in r)this[s]=r[s]}}}(t);function s(...i){if(this instanceof s)return r.apply(this,i),this;const o=new s(...i);return a.annotation=o,a;function a(l,c,u){const d=l.hasOwnProperty(gc)?l[gc]:Object.defineProperty(l,gc,{value:[]})[gc];for(;d.length<=u;)d.push(null);return(d[u]=d[u]||[]).push(o),l}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=n,s.annotationCls=s,s})}class Fe{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=Ve({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}toString(){return`InjectionToken ${this._desc}`}}const VH=new Fe("AnalyzeForEntryComponents");function Zs(n,t){void 0===t&&(t=n);for(let e=0;e<n.length;e++){let r=n[e];Array.isArray(r)?(t===n&&(t=n.slice(0,e)),Zs(r,t)):t!==n&&t.push(r)}return t}function Yi(n,t){n.forEach(e=>Array.isArray(e)?Yi(e,t):t(e))}function HT(n,t,e){t>=n.length?n.push(e):n.splice(t,0,e)}function Wp(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}function _d(n,t){const e=[];for(let r=0;r<n;r++)e.push(t);return e}function ks(n,t,e){let r=vc(n,t);return r>=0?n[1|r]=e:(r=~r,function UH(n,t,e,r){let s=n.length;if(s==t)n.push(e,r);else if(1===s)n.push(r,n[0]),n[0]=e;else{for(s--,n.push(n[s-1],n[s]);s>t;)n[s]=n[s-2],s--;n[t]=e,n[t+1]=r}}(n,r,t,e)),r}function yb(n,t){const e=vc(n,t);if(e>=0)return n[1|e]}function vc(n,t){return function GT(n,t,e){let r=0,s=n.length>>e;for(;s!==r;){const i=r+(s-r>>1),o=n[i<<e];if(t===o)return i<<e;o>t?s=i:r=i+1}return~(s<<e)}(n,t,1)}const vd={},vb="__NG_DI_FLAG__",qp="ngTempTokenPath",XH=/\n/gm,KT="__source",ZH=nn({provide:String,useValue:nn});let bd;function XT(n){const t=bd;return bd=n,t}function QH(n,t=ut.Default){if(void 0===bd)throw new je(203,"");return null===bd?oT(n,void 0,t):bd.get(n,t&ut.Optional?null:void 0,t)}function ee(n,t=ut.Default){return(function PU(){return Uv}()||QH)(xt(n),t)}const Kp=ee;function bb(n){const t=[];for(let e=0;e<n.length;e++){const r=xt(n[e]);if(Array.isArray(r)){if(0===r.length)throw new je(900,"");let s,i=ut.Default;for(let o=0;o<r.length;o++){const a=r[o],l=JH(a);"number"==typeof l?-1===l?s=a.token:i|=l:s=a}t.push(ee(s,i))}else t.push(ee(r))}return t}function xd(n,t){return n[vb]=t,n.prototype[vb]=t,n}function JH(n){return n[vb]}const Xp=xd(_c("Inject",n=>({token:n})),-1),Si=xd(_c("Optional"),8),bc=xd(_c("SkipSelf"),4);let Zp;function wb(){if(void 0===Zp&&(Zp=null,en.trustedTypes))try{Zp=en.trustedTypes.createPolicy("angular",{createHTML:n=>n,createScript:n=>n,createScriptURL:n=>n})}catch(n){}return Zp}function wc(n){var t;return(null===(t=wb())||void 0===t?void 0:t.createHTML(n))||n}class il{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}class f4 extends il{getTypeName(){return"HTML"}}class p4 extends il{getTypeName(){return"Style"}}class m4 extends il{getTypeName(){return"Script"}}class g4 extends il{getTypeName(){return"URL"}}class y4 extends il{getTypeName(){return"ResourceURL"}}function Ns(n){return n instanceof il?n.changingThisBreaksApplicationSecurity:n}function Zi(n,t){const e=s1(n);if(null!=e&&e!==t){if("ResourceURL"===e&&"URL"===t)return!0;throw new Error(`Required a safe ${t}, got a ${e} (see https://g.co/ng/security#xss)`)}return e===t}function s1(n){return n instanceof il&&n.getTypeName()||null}class C4{constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{const e=(new window.DOMParser).parseFromString(wc(t),"text/html").body;return null===e?this.inertDocumentHelper.getInertBodyElement(t):(e.removeChild(e.firstChild),e)}catch(e){return null}}}class D4{constructor(t){if(this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"),null==this.inertDocument.body){const e=this.inertDocument.createElement("html");this.inertDocument.appendChild(e);const r=this.inertDocument.createElement("body");e.appendChild(r)}}getInertBodyElement(t){const e=this.inertDocument.createElement("template");if("content"in e)return e.innerHTML=wc(t),e;const r=this.inertDocument.createElement("body");return r.innerHTML=wc(t),this.defaultDoc.documentMode&&this.stripCustomNsAttrs(r),r}stripCustomNsAttrs(t){const e=t.attributes;for(let s=e.length-1;0<s;s--){const o=e.item(s).name;("xmlns:ns1"===o||0===o.indexOf("ns1:"))&&t.removeAttribute(o)}let r=t.firstChild;for(;r;)r.nodeType===Node.ELEMENT_NODE&&this.stripCustomNsAttrs(r),r=r.nextSibling}}const E4=/^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,I4=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;function Cd(n){return(n=String(n)).match(E4)||n.match(I4)?n:"unsafe:"+n}function Qi(n){const t={};for(const e of n.split(","))t[e]=!0;return t}function Dd(...n){const t={};for(const e of n)for(const r in e)e.hasOwnProperty(r)&&(t[r]=!0);return t}const l1=Qi("area,br,col,hr,img,wbr"),c1=Qi("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),u1=Qi("rp,rt"),Db=Dd(l1,Dd(c1,Qi("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),Dd(u1,Qi("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),Dd(u1,c1)),Sb=Qi("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),Eb=Qi("srcset"),d1=Dd(Sb,Eb,Qi("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),Qi("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),T4=Qi("script,style,template");class k4{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(t){let e=t.firstChild,r=!0;for(;e;)if(e.nodeType===Node.ELEMENT_NODE?r=this.startElement(e):e.nodeType===Node.TEXT_NODE?this.chars(e.nodeValue):this.sanitizedSomething=!0,r&&e.firstChild)e=e.firstChild;else for(;e;){e.nodeType===Node.ELEMENT_NODE&&this.endElement(e);let s=this.checkClobberedElement(e,e.nextSibling);if(s){e=s;break}e=this.checkClobberedElement(e,e.parentNode)}return this.buf.join("")}startElement(t){const e=t.nodeName.toLowerCase();if(!Db.hasOwnProperty(e))return this.sanitizedSomething=!0,!T4.hasOwnProperty(e);this.buf.push("<"),this.buf.push(e);const r=t.attributes;for(let s=0;s<r.length;s++){const i=r.item(s),o=i.name,a=o.toLowerCase();if(!d1.hasOwnProperty(a)){this.sanitizedSomething=!0;continue}let l=i.value;Sb[a]&&(l=Cd(l)),Eb[a]&&(n=l,l=(n=String(n)).split(",").map(t=>Cd(t.trim())).join(", ")),this.buf.push(" ",o,'="',h1(l),'"')}var n;return this.buf.push(">"),!0}endElement(t){const e=t.nodeName.toLowerCase();Db.hasOwnProperty(e)&&!l1.hasOwnProperty(e)&&(this.buf.push("</"),this.buf.push(e),this.buf.push(">"))}chars(t){this.buf.push(h1(t))}checkClobberedElement(t,e){if(e&&(t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);return e}}const N4=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,A4=/([^\#-~ |!])/g;function h1(n){return n.replace(/&/g,"&amp;").replace(N4,function(t){return"&#"+(1024*(t.charCodeAt(0)-55296)+(t.charCodeAt(1)-56320)+65536)+";"}).replace(A4,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let Jp;function f1(n,t){let e=null;try{Jp=Jp||function o1(n){const t=new D4(n);return function S4(){try{return!!(new window.DOMParser).parseFromString(wc(""),"text/html")}catch(n){return!1}}()?new C4(t):t}(n);let r=t?String(t):"";e=Jp.getInertBodyElement(r);let s=5,i=r;do{if(0===s)throw new Error("Failed to sanitize html because the input is unstable");s--,r=i,i=e.innerHTML,e=Jp.getInertBodyElement(r)}while(r!==i);return wc((new k4).sanitizeChildren(Ib(e)||e))}finally{if(e){const r=Ib(e)||e;for(;r.firstChild;)r.removeChild(r.firstChild)}}}function Ib(n){return"content"in n&&function R4(n){return n.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===n.nodeName}(n)?n.content:null}var Wt=(()=>((Wt=Wt||{})[Wt.NONE=0]="NONE",Wt[Wt.HTML=1]="HTML",Wt[Wt.STYLE=2]="STYLE",Wt[Wt.SCRIPT=3]="SCRIPT",Wt[Wt.URL=4]="URL",Wt[Wt.RESOURCE_URL=5]="RESOURCE_URL",Wt))();function Cc(n){const t=function Sd(){const n=ye();return n&&n[12]}();return t?t.sanitize(Wt.URL,n)||"":Zi(n,"URL")?Ns(n):Cd(pt(n))}function m1(n){return function h4(n){var t;return(null===(t=wb())||void 0===t?void 0:t.createScriptURL(n))||n}(n[0])}const y1="__ngContext__";function Hr(n,t){n[y1]=t}function kb(n){const t=function Ed(n){return n[y1]||null}(n);return t?Array.isArray(t)?t:t.lView:null}function Ab(n){return n.ngOriginalError}function K4(n,...t){n.error(...t)}class ca{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t),r=function q4(n){return n&&n.ngErrorLogger||K4}(t);r(this._console,"ERROR",t),e&&r(this._console,"ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&Ab(t);for(;e&&Ab(e);)e=Ab(e);return e||null}}const sj=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(en))();function Ji(n){return n instanceof Function?n():n}var As=(()=>((As=As||{})[As.Important=1]="Important",As[As.DashCase=2]="DashCase",As))();function Mb(n,t){return undefined(n,t)}function Id(n){const t=n[3];return Ci(t)?t[3]:t}function Ob(n){return E1(n[13])}function Fb(n){return E1(n[4])}function E1(n){for(;null!==n&&!Ci(n);)n=n[4];return n}function Sc(n,t,e,r,s){if(null!=r){let i,o=!1;Ci(r)?i=r:Ki(r)&&(o=!0,r=r[0]);const a=Xn(r);0===n&&null!==e?null==s?R1(t,e,a):ol(t,e,a,s||null,!0):1===n&&null!==e?ol(t,e,a,s||null,!0):2===n?function V1(n,t,e){const r=em(n,t);r&&function _j(n,t,e,r){Fn(n)?n.removeChild(t,e,r):t.removeChild(e)}(n,r,t,e)}(t,a,o):3===n&&t.destroyNode(a),null!=i&&function xj(n,t,e,r,s){const i=e[7];i!==Xn(e)&&Sc(t,n,r,i,s);for(let a=10;a<e.length;a++){const l=e[a];Td(l[1],l,n,t,r,i)}}(t,n,i,e,s)}}function $b(n,t,e){if(Fn(n))return n.createElement(t,e);{const r=null!==e?function nH(n){const t=n.toLowerCase();return"svg"===t?"http://www.w3.org/2000/svg":"math"===t?"http://www.w3.org/1998/MathML/":null}(e):null;return null===r?n.createElement(t):n.createElementNS(r,t)}}function T1(n,t){const e=n[9],r=e.indexOf(t),s=t[3];1024&t[2]&&(t[2]&=-1025,nb(s,-1)),e.splice(r,1)}function Lb(n,t){if(n.length<=10)return;const e=10+t,r=n[e];if(r){const s=r[17];null!==s&&s!==n&&T1(s,r),t>0&&(n[e-1][4]=r[4]);const i=Wp(n,10+t);!function uj(n,t){Td(n,t,t[11],2,null,null),t[0]=null,t[6]=null}(r[1],r);const o=i[19];null!==o&&o.detachView(i[1]),r[3]=null,r[4]=null,r[2]&=-129}return r}function k1(n,t){if(!(256&t[2])){const e=t[11];Fn(e)&&e.destroyNode&&Td(n,t,e,3,null,null),function fj(n){let t=n[13];if(!t)return Vb(n[1],n);for(;t;){let e=null;if(Ki(t))e=t[13];else{const r=t[10];r&&(e=r)}if(!e){for(;t&&!t[4]&&t!==n;)Ki(t)&&Vb(t[1],t),t=t[3];null===t&&(t=n),Ki(t)&&Vb(t[1],t),e=t&&t[4]}t=e}}(t)}}function Vb(n,t){if(!(256&t[2])){t[2]&=-129,t[2]|=256,function yj(n,t){let e;if(null!=n&&null!=(e=n.destroyHooks))for(let r=0;r<e.length;r+=2){const s=t[e[r]];if(!(s instanceof hd)){const i=e[r+1];if(Array.isArray(i))for(let o=0;o<i.length;o+=2){const a=s[i[o]],l=i[o+1];try{l.call(a)}finally{}}else try{i.call(s)}finally{}}}}(n,t),function gj(n,t){const e=n.cleanup,r=t[7];let s=-1;if(null!==e)for(let i=0;i<e.length-1;i+=2)if("string"==typeof e[i]){const o=e[i+1],a="function"==typeof o?o(t):Xn(t[o]),l=r[s=e[i+2]],c=e[i+3];"boolean"==typeof c?a.removeEventListener(e[i],l,c):c>=0?r[s=c]():r[s=-c].unsubscribe(),i+=2}else{const o=r[s=e[i+1]];e[i].call(o)}if(null!==r){for(let i=s+1;i<r.length;i++)r[i]();t[7]=null}}(n,t),1===t[1].type&&Fn(t[11])&&t[11].destroy();const e=t[17];if(null!==e&&Ci(t[3])){e!==t[3]&&T1(e,t);const r=t[19];null!==r&&r.detachView(n)}}}function N1(n,t,e){return function A1(n,t,e){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return e[0];if(2&r.flags){const s=n.data[r.directiveStart].encapsulation;if(s===xi.None||s===xi.Emulated)return null}return Ys(r,e)}(n,t.parent,e)}function ol(n,t,e,r,s){Fn(n)?n.insertBefore(t,e,r,s):t.insertBefore(e,r,s)}function R1(n,t,e){Fn(n)?n.appendChild(t,e):t.appendChild(e)}function M1(n,t,e,r,s){null!==r?ol(n,t,e,r,s):R1(n,t,e)}function em(n,t){return Fn(n)?n.parentNode(t):t.parentNode}function O1(n,t,e){return P1(n,t,e)}let P1=function F1(n,t,e){return 40&n.type?Ys(n,e):null};function tm(n,t,e,r){const s=N1(n,r,t),i=t[11],a=O1(r.parent||t[6],r,t);if(null!=s)if(Array.isArray(e))for(let l=0;l<e.length;l++)M1(i,s,e[l],a,!1);else M1(i,s,e,a,!1)}function nm(n,t){if(null!==t){const e=t.type;if(3&e)return Ys(t,n);if(4&e)return zb(-1,n[t.index]);if(8&e){const r=t.child;if(null!==r)return nm(n,r);{const s=n[t.index];return Ci(s)?zb(-1,s):Xn(s)}}if(32&e)return Mb(t,n)()||Xn(n[t.index]);{const r=L1(n,t);return null!==r?Array.isArray(r)?r[0]:nm(Id(n[16]),r):nm(n,t.next)}}return null}function L1(n,t){return null!==t?n[16][6].projection[t.projection]:null}function zb(n,t){const e=10+n+1;if(e<t.length){const r=t[e],s=r[1].firstChild;if(null!==s)return nm(r,s)}return t[7]}function Ub(n,t,e,r,s,i,o){for(;null!=e;){const a=r[e.index],l=e.type;if(o&&0===t&&(a&&Hr(Xn(a),r),e.flags|=4),64!=(64&e.flags))if(8&l)Ub(n,t,e.child,r,s,i,!1),Sc(t,n,s,a,i);else if(32&l){const c=Mb(e,r);let u;for(;u=c();)Sc(t,n,s,u,i);Sc(t,n,s,a,i)}else 16&l?B1(n,t,r,e,s,i):Sc(t,n,s,a,i);e=o?e.projectionNext:e.next}}function Td(n,t,e,r,s,i){Ub(e,r,n.firstChild,t,s,i,!1)}function B1(n,t,e,r,s,i){const o=e[16],l=o[6].projection[r.projection];if(Array.isArray(l))for(let c=0;c<l.length;c++)Sc(t,n,s,l[c],i);else Ub(n,t,l,o[3],s,i,!0)}function z1(n,t,e){Fn(n)?n.setAttribute(t,"style",e):t.style.cssText=e}function Hb(n,t,e){Fn(n)?""===e?n.removeAttribute(t,"class"):n.setAttribute(t,"class",e):t.className=e}function U1(n,t,e){let r=n.length;for(;;){const s=n.indexOf(t,e);if(-1===s)return s;if(0===s||n.charCodeAt(s-1)<=32){const i=t.length;if(s+i===r||n.charCodeAt(s+i)<=32)return s}e=s+1}}const H1="ng-template";function Cj(n,t,e){let r=0;for(;r<n.length;){let s=n[r++];if(e&&"class"===s){if(s=n[r],-1!==U1(s.toLowerCase(),t,0))return!0}else if(1===s){for(;r<n.length&&"string"==typeof(s=n[r++]);)if(s.toLowerCase()===t)return!0;return!1}}return!1}function j1(n){return 4===n.type&&n.value!==H1}function Dj(n,t,e){return t===(4!==n.type||e?n.value:H1)}function Sj(n,t,e){let r=4;const s=n.attrs||[],i=function Tj(n){for(let t=0;t<n.length;t++)if(NT(n[t]))return t;return n.length}(s);let o=!1;for(let a=0;a<t.length;a++){const l=t[a];if("number"!=typeof l){if(!o)if(4&r){if(r=2|1&r,""!==l&&!Dj(n,l,e)||""===l&&1===t.length){if(Ei(r))return!1;o=!0}}else{const c=8&r?l:t[++a];if(8&r&&null!==n.attrs){if(!Cj(n.attrs,c,e)){if(Ei(r))return!1;o=!0}continue}const d=Ej(8&r?"class":l,s,j1(n),e);if(-1===d){if(Ei(r))return!1;o=!0;continue}if(""!==c){let h;h=d>i?"":s[d+1].toLowerCase();const f=8&r?h:null;if(f&&-1!==U1(f,c,0)||2&r&&c!==h){if(Ei(r))return!1;o=!0}}}}else{if(!o&&!Ei(r)&&!Ei(l))return!1;if(o&&Ei(l))continue;o=!1,r=l|1&r}}return Ei(r)||o}function Ei(n){return 0==(1&n)}function Ej(n,t,e,r){if(null===t)return-1;let s=0;if(r||!e){let i=!1;for(;s<t.length;){const o=t[s];if(o===n)return s;if(3===o||6===o)i=!0;else{if(1===o||2===o){let a=t[++s];for(;"string"==typeof a;)a=t[++s];continue}if(4===o)break;if(0===o){s+=4;continue}}s+=i?1:2}return-1}return function kj(n,t){let e=n.indexOf(4);if(e>-1)for(e++;e<n.length;){const r=n[e];if("number"==typeof r)return-1;if(r===t)return e;e++}return-1}(t,n)}function W1(n,t,e=!1){for(let r=0;r<t.length;r++)if(Sj(n,t[r],e))return!0;return!1}function Nj(n,t){e:for(let e=0;e<t.length;e++){const r=t[e];if(n.length===r.length){for(let s=0;s<n.length;s++)if(n[s]!==r[s])continue e;return!0}}return!1}function G1(n,t){return n?":not("+t.trim()+")":t}function Aj(n){let t=n[0],e=1,r=2,s="",i=!1;for(;e<n.length;){let o=n[e];if("string"==typeof o)if(2&r){const a=n[++e];s+="["+o+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+o:4&r&&(s+=" "+o);else""!==s&&!Ei(o)&&(t+=G1(i,s),s=""),r=o,i=i||!Ei(r);e++}return""!==s&&(t+=G1(i,s)),t}const mt={};function Yn(n){q1(Vt(),ye(),es()+n,Rp())}function q1(n,t,e,r){if(!r)if(3==(3&t[2])){const i=n.preOrderCheckHooks;null!==i&&$p(t,i,e)}else{const i=n.preOrderHooks;null!==i&&Lp(t,i,0,e)}aa(e)}function rm(n,t){return n<<17|t<<2}function Ii(n){return n>>17&32767}function jb(n){return 2|n}function Mo(n){return(131068&n)>>2}function Wb(n,t){return-131069&n|t<<2}function Gb(n){return 1|n}function sk(n,t){const e=n.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const s=e[r],i=e[r+1];if(-1!==i){const o=n.data[i];ab(s),o.contentQueries(2,t[i],i)}}}function kd(n,t,e,r,s,i,o,a,l,c){const u=t.blueprint.slice();return u[0]=s,u[2]=140|r,_T(u),u[3]=u[15]=n,u[8]=e,u[10]=o||n&&n[10],u[11]=a||n&&n[11],u[12]=l||n&&n[12]||null,u[9]=c||n&&n[9]||null,u[6]=i,u[16]=2==t.type?n[16]:u,u}function Ec(n,t,e,r,s){let i=n.data[t];if(null===i)i=function t0(n,t,e,r,s){const i=bT(),o=rb(),l=n.data[t]=function Xj(n,t,e,r,s,i){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?i:i&&i.parent,e,t,r,s);return null===n.firstChild&&(n.firstChild=l),null!==i&&(o?null==i.child&&null!==l.parent&&(i.child=l):null===i.next&&(i.next=l)),l}(n,t,e,r,s),function pH(){return dt.lFrame.inI18n}()&&(i.flags|=64);else if(64&i.type){i.type=e,i.value=r,i.attrs=s;const o=function dd(){const n=dt.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}();i.injectorIndex=null===o?-1:o.injectorIndex}return Xi(i,!0),i}function Ic(n,t,e,r){if(0===e)return-1;const s=t.length;for(let i=0;i<e;i++)t.push(r),n.blueprint.push(r),n.data.push(null);return s}function Nd(n,t,e){Op(t);try{const r=n.viewQuery;null!==r&&d0(1,r,e);const s=n.template;null!==s&&ik(n,t,s,1,e),n.firstCreatePass&&(n.firstCreatePass=!1),n.staticContentQueries&&sk(n,t),n.staticViewQueries&&d0(2,n.viewQuery,e);const i=n.components;null!==i&&function Gj(n,t){for(let e=0;e<t.length;e++)fW(n,t[e])}(t,i)}catch(r){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),r}finally{t[2]&=-5,Fp()}}function Tc(n,t,e,r){const s=t[2];if(256==(256&s))return;Op(t);const i=Rp();try{_T(t),function xT(n){return dt.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==e&&ik(n,t,e,2,r);const o=3==(3&s);if(!i)if(o){const c=n.preOrderCheckHooks;null!==c&&$p(t,c,null)}else{const c=n.preOrderHooks;null!==c&&Lp(t,c,0,null),lb(t,0)}if(function dW(n){for(let t=Ob(n);null!==t;t=Fb(t)){if(!t[2])continue;const e=t[9];for(let r=0;r<e.length;r++){const s=e[r],i=s[3];0==(1024&s[2])&&nb(i,1),s[2]|=1024}}}(t),function uW(n){for(let t=Ob(n);null!==t;t=Fb(t))for(let e=10;e<t.length;e++){const r=t[e],s=r[1];tb(r)&&Tc(s,r,s.template,r[8])}}(t),null!==n.contentQueries&&sk(n,t),!i)if(o){const c=n.contentCheckHooks;null!==c&&$p(t,c)}else{const c=n.contentHooks;null!==c&&Lp(t,c,1),lb(t,1)}!function jj(n,t){const e=n.hostBindingOpCodes;if(null!==e)try{for(let r=0;r<e.length;r++){const s=e[r];if(s<0)aa(~s);else{const i=s,o=e[++r],a=e[++r];mH(o,i),a(2,t[i])}}}finally{aa(-1)}}(n,t);const a=n.components;null!==a&&function Wj(n,t){for(let e=0;e<t.length;e++)hW(n,t[e])}(t,a);const l=n.viewQuery;if(null!==l&&d0(2,l,r),!i)if(o){const c=n.viewCheckHooks;null!==c&&$p(t,c)}else{const c=n.viewHooks;null!==c&&Lp(t,c,2),lb(t,2)}!0===n.firstUpdatePass&&(n.firstUpdatePass=!1),i||(t[2]&=-73),1024&t[2]&&(t[2]&=-1025,nb(t[3],-1))}finally{Fp()}}function qj(n,t,e,r){const s=t[10],i=!Rp(),o=yT(t);try{i&&!o&&s.begin&&s.begin(),o&&Nd(n,t,r),Tc(n,t,e,r)}finally{i&&!o&&s.end&&s.end()}}function ik(n,t,e,r,s){const i=es(),o=2&r;try{aa(-1),o&&t.length>20&&q1(n,t,20,Rp()),e(r,s)}finally{aa(i)}}function n0(n,t,e){!vT()||(function nW(n,t,e,r){const s=e.directiveStart,i=e.directiveEnd;n.firstCreatePass||pd(e,t),Hr(r,t);const o=e.initialInputs;for(let a=s;a<i;a++){const l=n.data[a],c=Di(l);c&&aW(t,e,l);const u=md(t,n,a,e);Hr(u,t),null!==o&&lW(0,a-s,u,l,0,o),c&&(Ts(e.index,t)[8]=u)}}(n,t,e,Ys(e,t)),128==(128&e.flags)&&function rW(n,t,e){const r=e.directiveStart,s=e.directiveEnd,o=e.index,a=function gH(){return dt.lFrame.currentDirectiveIndex}();try{aa(o);for(let l=r;l<s;l++){const c=n.data[l],u=t[l];ib(l),(null!==c.hostBindings||0!==c.hostVars||null!==c.hostAttrs)&&pk(c,u)}}finally{aa(-1),ib(a)}}(n,t,e))}function r0(n,t,e=Ys){const r=t.localNames;if(null!==r){let s=t.index+1;for(let i=0;i<r.length;i+=2){const o=r[i+1],a=-1===o?e(t,n):n[o];n[s++]=a}}}function ak(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=om(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts):t}function om(n,t,e,r,s,i,o,a,l,c){const u=20+r,d=u+s,h=function Kj(n,t){const e=[];for(let r=0;r<t;r++)e.push(r<n?null:mt);return e}(u,d),f="function"==typeof c?c():c;return h[1]={type:n,blueprint:h,template:e,queries:null,viewQuery:a,declTNode:t,data:h.slice().fill(null,u),bindingStartIndex:u,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:l,consts:f,incompleteFirstPass:!1}}function uk(n,t,e,r){const s=bk(t);null===e?s.push(r):(s.push(e),n.firstCreatePass&&xk(n).push(r,s.length-1))}function dk(n,t,e){for(let r in n)if(n.hasOwnProperty(r)){const s=n[r];(e=null===e?{}:e).hasOwnProperty(r)?e[r].push(t,s):e[r]=[t,s]}return e}function Rs(n,t,e,r,s,i,o,a){const l=Ys(t,e);let u,c=t.inputs;!a&&null!=c&&(u=c[r])?(Dk(n,e,u,r,s),kp(t)&&function Qj(n,t){const e=Ts(t,n);16&e[2]||(e[2]|=64)}(e,t.index)):3&t.type&&(r=function Zj(n){return"class"===n?"className":"for"===n?"htmlFor":"formaction"===n?"formAction":"innerHtml"===n?"innerHTML":"readonly"===n?"readOnly":"tabindex"===n?"tabIndex":n}(r),s=null!=o?o(s,t.value||"",r):s,Fn(i)?i.setProperty(l,r,s):ub(r)||(l.setProperty?l.setProperty(r,s):l[r]=s))}function s0(n,t,e,r){let s=!1;if(vT()){const i=function sW(n,t,e){const r=n.directiveRegistry;let s=null;if(r)for(let i=0;i<r.length;i++){const o=r[i];W1(e,o.selectors,!1)&&(s||(s=[]),Hp(pd(e,t),n,o.type),Di(o)?(mk(n,e),s.unshift(o)):s.push(o))}return s}(n,t,e),o=null===r?null:{"":-1};if(null!==i){s=!0,gk(e,n.data.length,i.length);for(let u=0;u<i.length;u++){const d=i[u];d.providersResolver&&d.providersResolver(d)}let a=!1,l=!1,c=Ic(n,t,i.length,null);for(let u=0;u<i.length;u++){const d=i[u];e.mergedAttrs=Bp(e.mergedAttrs,d.hostAttrs),yk(n,e,t,c,d),oW(c,d,o),null!==d.contentQueries&&(e.flags|=8),(null!==d.hostBindings||null!==d.hostAttrs||0!==d.hostVars)&&(e.flags|=128);const h=d.type.prototype;!a&&(h.ngOnChanges||h.ngOnInit||h.ngDoCheck)&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e.index),a=!0),!l&&(h.ngOnChanges||h.ngDoCheck)&&((n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e.index),l=!0),c++}!function Yj(n,t){const r=t.directiveEnd,s=n.data,i=t.attrs,o=[];let a=null,l=null;for(let c=t.directiveStart;c<r;c++){const u=s[c],d=u.inputs,h=null===i||j1(t)?null:cW(d,i);o.push(h),a=dk(d,c,a),l=dk(u.outputs,c,l)}null!==a&&(a.hasOwnProperty("class")&&(t.flags|=16),a.hasOwnProperty("style")&&(t.flags|=32)),t.initialInputs=o,t.inputs=a,t.outputs=l}(n,e)}o&&function iW(n,t,e){if(t){const r=n.localNames=[];for(let s=0;s<t.length;s+=2){const i=e[t[s+1]];if(null==i)throw new je(-301,!1);r.push(t[s],i)}}}(e,r,o)}return e.mergedAttrs=Bp(e.mergedAttrs,e.attrs),s}function fk(n,t,e,r,s,i){const o=i.hostBindings;if(o){let a=n.hostBindingOpCodes;null===a&&(a=n.hostBindingOpCodes=[]);const l=~t.index;(function tW(n){let t=n.length;for(;t>0;){const e=n[--t];if("number"==typeof e&&e<0)return e}return 0})(a)!=l&&a.push(l),a.push(r,s,o)}}function pk(n,t){null!==n.hostBindings&&n.hostBindings(1,t)}function mk(n,t){t.flags|=2,(n.components||(n.components=[])).push(t.index)}function oW(n,t,e){if(e){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)e[t.exportAs[r]]=n;Di(t)&&(e[""]=n)}}function gk(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}function yk(n,t,e,r,s){n.data[r]=s;const i=s.factory||(s.factory=sl(s.type)),o=new hd(i,Di(s),null);n.blueprint[r]=o,e[r]=o,fk(n,t,0,r,Ic(n,e,s.hostVars,mt),s)}function aW(n,t,e){const r=Ys(t,n),s=ak(e),i=n[10],o=am(n,kd(n,s,null,e.onPush?64:16,r,t,i,i.createRenderer(r,e),null,null));n[t.index]=o}function eo(n,t,e,r,s,i){const o=Ys(n,t);!function o0(n,t,e,r,s,i,o){if(null==i)Fn(n)?n.removeAttribute(t,s,e):t.removeAttribute(s);else{const a=null==o?pt(i):o(i,r||"",s);Fn(n)?n.setAttribute(t,s,a,e):e?t.setAttributeNS(e,s,a):t.setAttribute(s,a)}}(t[11],o,i,n.value,e,r,s)}function lW(n,t,e,r,s,i){const o=i[t];if(null!==o){const a=r.setInput;for(let l=0;l<o.length;){const c=o[l++],u=o[l++],d=o[l++];null!==a?r.setInput(e,d,c,u):e[u]=d}}}function cW(n,t){let e=null,r=0;for(;r<t.length;){const s=t[r];if(0!==s)if(5!==s){if("number"==typeof s)break;n.hasOwnProperty(s)&&(null===e&&(e=[]),e.push(s,n[s],t[r+1])),r+=2}else r+=2;else r+=4}return e}function _k(n,t,e,r){return new Array(n,!0,!1,t,null,0,r,e,null,null)}function hW(n,t){const e=Ts(t,n);if(tb(e)){const r=e[1];80&e[2]?Tc(r,e,r.template,e[8]):e[5]>0&&a0(e)}}function a0(n){for(let r=Ob(n);null!==r;r=Fb(r))for(let s=10;s<r.length;s++){const i=r[s];if(1024&i[2]){const o=i[1];Tc(o,i,o.template,i[8])}else i[5]>0&&a0(i)}const e=n[1].components;if(null!==e)for(let r=0;r<e.length;r++){const s=Ts(e[r],n);tb(s)&&s[5]>0&&a0(s)}}function fW(n,t){const e=Ts(t,n),r=e[1];(function pW(n,t){for(let e=t.length;e<n.blueprint.length;e++)t.push(n.blueprint[e])})(r,e),Nd(r,e,e[8])}function am(n,t){return n[13]?n[14][4]=t:n[13]=t,n[14]=t,t}function l0(n){for(;n;){n[2]|=64;const t=Id(n);if(GU(n)&&!t)return n;n=t}return null}function u0(n,t,e){const r=t[10];r.begin&&r.begin();try{Tc(n,t,n.template,e)}catch(s){throw Ck(t,s),s}finally{r.end&&r.end()}}function vk(n){!function c0(n){for(let t=0;t<n.components.length;t++){const e=n.components[t],r=kb(e),s=r[1];qj(s,r,s.template,e)}}(n[8])}function d0(n,t,e){ab(0),t(n,e)}const _W=(()=>Promise.resolve(null))();function bk(n){return n[7]||(n[7]=[])}function xk(n){return n.cleanup||(n.cleanup=[])}function wk(n,t,e){return(null===n||Di(n))&&(e=function iH(n){for(;Array.isArray(n);){if("object"==typeof n[1])return n;n=n[0]}return null}(e[t.index])),e[11]}function Ck(n,t){const e=n[9],r=e?e.get(ca,null):null;r&&r.handleError(t)}function Dk(n,t,e,r,s){for(let i=0;i<e.length;){const o=e[i++],a=e[i++],l=t[o],c=n.data[o];null!==c.setInput?c.setInput(l,s,r,a):l[a]=s}}function Oo(n,t,e){const r=Ap(t,n);!function I1(n,t,e){Fn(n)?n.setValue(t,e):t.textContent=e}(n[11],r,e)}function lm(n,t,e){let r=e?n.styles:null,s=e?n.classes:null,i=0;if(null!==t)for(let o=0;o<t.length;o++){const a=t[o];"number"==typeof a?i=a:1==i?s=Lv(s,a):2==i&&(r=Lv(r,a+": "+t[++o]+";"))}e?n.styles=r:n.stylesWithoutHost=r,e?n.classes=s:n.classesWithoutHost=s}const h0=new Fe("INJECTOR",-1);class Sk{get(t,e=vd){if(e===vd){const r=new Error(`NullInjectorError: No provider for ${Xt(t)}!`);throw r.name="NullInjectorError",r}return e}}const f0=new Fe("Set Injector scope."),Ad={},xW={};let p0;function Ek(){return void 0===p0&&(p0=new Sk),p0}function Ik(n,t=null,e=null,r){const s=Tk(n,t,e,r);return s._resolveInjectorDefTypes(),s}function Tk(n,t=null,e=null,r){return new wW(n,e,t||Ek(),r)}class wW{constructor(t,e,r,s=null){this.parent=r,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const i=[];e&&Yi(e,a=>this.processProvider(a,t,e)),Yi([t],a=>this.processInjectorType(a,[],i)),this.records.set(h0,kc(void 0,this));const o=this.records.get(f0);this.scope=null!=o?o.value:null,this.source=s||("object"==typeof t?null:Xt(t))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(t=>t.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(t,e=vd,r=ut.Default){this.assertNotDestroyed();const s=XT(this),i=ra(void 0);try{if(!(r&ut.SkipSelf)){let a=this.records.get(t);if(void 0===a){const l=function NW(n){return"function"==typeof n||"object"==typeof n&&n instanceof Fe}(t)&&Bv(t);a=l&&this.injectableDefInScope(l)?kc(m0(t),Ad):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(r&ut.Self?Ek():this.parent).get(t,e=r&ut.Optional&&e===vd?null:e)}catch(o){if("NullInjectorError"===o.name){if((o[qp]=o[qp]||[]).unshift(Xt(t)),s)throw o;return function e4(n,t,e,r){const s=n[qp];throw t[KT]&&s.unshift(t[KT]),n.message=function t4(n,t,e,r=null){n=n&&"\n"===n.charAt(0)&&"\u0275"==n.charAt(1)?n.substr(2):n;let s=Xt(t);if(Array.isArray(t))s=t.map(Xt).join(" -> ");else if("object"==typeof t){let i=[];for(let o in t)if(t.hasOwnProperty(o)){let a=t[o];i.push(o+":"+("string"==typeof a?JSON.stringify(a):Xt(a)))}s=`{${i.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${n.replace(XH,"\n  ")}`}("\n"+n.message,s,e,r),n.ngTokenPath=s,n[qp]=null,n}(o,t,"R3InjectorError",this.source)}throw o}finally{ra(i),XT(s)}}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(t=>this.get(t))}toString(){const t=[];return this.records.forEach((r,s)=>t.push(Xt(s))),`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new je(205,!1)}processInjectorType(t,e,r){if(!(t=xt(t)))return!1;let s=sT(t);const i=null==s&&t.ngModule||void 0,o=void 0===i?t:i,a=-1!==r.indexOf(o);if(void 0!==i&&(s=sT(i)),null==s)return!1;if(null!=s.imports&&!a){let u;r.push(o);try{Yi(s.imports,d=>{this.processInjectorType(d,e,r)&&(void 0===u&&(u=[]),u.push(d))})}finally{}if(void 0!==u)for(let d=0;d<u.length;d++){const{ngModule:h,providers:f}=u[d];Yi(f,p=>this.processProvider(p,h,f||rn))}}this.injectorDefTypes.add(o);const l=sl(o)||(()=>new o);this.records.set(o,kc(l,Ad));const c=s.providers;if(null!=c&&!a){const u=t;Yi(c,d=>this.processProvider(d,u,c))}return void 0!==i&&void 0!==t.providers}processProvider(t,e,r){let s=Nc(t=xt(t))?t:xt(t&&t.provide);const i=function DW(n,t,e){return Nk(n)?kc(void 0,n.useValue):kc(kk(n),Ad)}(t);if(Nc(t)||!0!==t.multi)this.records.get(s);else{let o=this.records.get(s);o||(o=kc(void 0,Ad,!0),o.factory=()=>bb(o.multi),this.records.set(s,o)),s=t,o.multi.push(t)}this.records.set(s,i)}hydrate(t,e){return e.value===Ad&&(e.value=xW,e.value=e.factory()),"object"==typeof e.value&&e.value&&function kW(n){return null!==n&&"object"==typeof n&&"function"==typeof n.ngOnDestroy}(e.value)&&this.onDestroy.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=xt(t.providedIn);return"string"==typeof e?"any"===e||e===this.scope:this.injectorDefTypes.has(e)}}function m0(n){const t=Bv(n),e=null!==t?t.factory:sl(n);if(null!==e)return e;if(n instanceof Fe)throw new je(204,!1);if(n instanceof Function)return function CW(n){const t=n.length;if(t>0)throw _d(t,"?"),new je(204,!1);const e=function MU(n){const t=n&&(n[Dp]||n[iT]);if(t){const e=function OU(n){if(n.hasOwnProperty("name"))return n.name;const t=(""+n).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(n);return console.warn(`DEPRECATED: DI is instantiating a token "${e}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${e}" class.`),t}return null}(n);return null!==e?()=>e.factory(n):()=>new n}(n);throw new je(204,!1)}function kk(n,t,e){let r;if(Nc(n)){const s=xt(n);return sl(s)||m0(s)}if(Nk(n))r=()=>xt(n.useValue);else if(function EW(n){return!(!n||!n.useFactory)}(n))r=()=>n.useFactory(...bb(n.deps||[]));else if(function SW(n){return!(!n||!n.useExisting)}(n))r=()=>ee(xt(n.useExisting));else{const s=xt(n&&(n.useClass||n.provide));if(!function TW(n){return!!n.deps}(n))return sl(s)||m0(s);r=()=>new s(...bb(n.deps))}return r}function kc(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function Nk(n){return null!==n&&"object"==typeof n&&ZH in n}function Nc(n){return"function"==typeof n}let Tn=(()=>{class n{static create(e,r){var s;if(Array.isArray(e))return Ik({name:""},r,e,"");{const i=null!==(s=e.name)&&void 0!==s?s:"";return Ik({name:i},e.parent,e.providers,i)}}}return n.THROW_IF_NOT_FOUND=vd,n.NULL=new Sk,n.\u0275prov=Ve({token:n,providedIn:"any",factory:()=>ee(h0)}),n.__NG_ELEMENT_ID__=-1,n})();function LW(n,t){Pp(kb(n)[1],or())}function ki(n){let t=function Uk(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),e=!0;const r=[n];for(;t;){let s;if(Di(n))s=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new je(903,"");s=t.\u0275dir}if(s){if(e){r.push(s);const o=n;o.inputs=_0(n.inputs),o.declaredInputs=_0(n.declaredInputs),o.outputs=_0(n.outputs);const a=s.hostBindings;a&&UW(n,a);const l=s.viewQuery,c=s.contentQueries;if(l&&BW(n,l),c&&zW(n,c),$v(n.inputs,s.inputs),$v(n.declaredInputs,s.declaredInputs),$v(n.outputs,s.outputs),Di(s)&&s.data.animation){const u=n.data;u.animation=(u.animation||[]).concat(s.data.animation)}}const i=s.features;if(i)for(let o=0;o<i.length;o++){const a=i[o];a&&a.ngInherit&&a(n),a===ki&&(e=!1)}}t=Object.getPrototypeOf(t)}!function VW(n){let t=0,e=null;for(let r=n.length-1;r>=0;r--){const s=n[r];s.hostVars=t+=s.hostVars,s.hostAttrs=Bp(s.hostAttrs,e=Bp(e,s.hostAttrs))}}(r)}function _0(n){return n===sc?{}:n===rn?[]:n}function BW(n,t){const e=n.viewQuery;n.viewQuery=e?(r,s)=>{t(r,s),e(r,s)}:t}function zW(n,t){const e=n.contentQueries;n.contentQueries=e?(r,s,i)=>{t(r,s,i),e(r,s,i)}:t}function UW(n,t){const e=n.hostBindings;n.hostBindings=e?(r,s)=>{t(r,s),e(r,s)}:t}let cm=null;function Ac(){if(!cm){const n=en.Symbol;if(n&&n.iterator)cm=n.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const r=t[e];"entries"!==r&&"size"!==r&&Map.prototype[r]===Map.prototype.entries&&(cm=r)}}}return cm}function Rd(n){return!!v0(n)&&(Array.isArray(n)||!(n instanceof Map)&&Ac()in n)}function v0(n){return null!==n&&("function"==typeof n||"object"==typeof n)}function to(n,t,e){return n[t]=e}function jr(n,t,e){return!Object.is(n[t],e)&&(n[t]=e,!0)}function no(n,t,e,r){const s=ye();return jr(s,uc(),t)&&(Vt(),eo(Pn(),s,n,t,e,r)),no}function Js(n,t,e,r,s,i,o,a){const l=ye(),c=Vt(),u=n+20,d=c.firstCreatePass?function XW(n,t,e,r,s,i,o,a,l){const c=t.consts,u=Ec(t,n,4,o||null,oa(c,a));s0(t,e,u,oa(c,l)),Pp(t,u);const d=u.tViews=om(2,u,r,s,i,t.directiveRegistry,t.pipeRegistry,null,t.schemas,c);return null!==t.queries&&(t.queries.template(t,u),d.queries=t.queries.embeddedTView(u)),u}(u,c,l,t,e,r,s,i,o):c.data[u];Xi(d,!1);const h=l[11].createComment("");tm(c,l,h,d),Hr(h,l),am(l,l[u]=_k(h,l,h,d)),Np(d)&&n0(c,l,d),null!=o&&r0(l,d,a)}function ll(n){return function cc(n,t){return n[t]}(function fH(){return dt.lFrame.contextLView}(),20+n)}function oe(n,t=ut.Default){const e=ye();return null===e?ee(n,t):$T(or(),e,xt(n),t)}function hm(){throw new Error("invalid")}function Cr(n,t,e){const r=ye();return jr(r,uc(),t)&&Rs(Vt(),Pn(),r,n,t,r[11],e,!1),Cr}function D0(n,t,e,r,s){const o=s?"class":"style";Dk(n,e,t.inputs[o],o,r)}function Re(n,t,e,r){const s=ye(),i=Vt(),o=20+n,a=s[11],l=s[o]=$b(a,t,function DH(){return dt.lFrame.currentNamespace}()),c=i.firstCreatePass?function gG(n,t,e,r,s,i,o){const a=t.consts,c=Ec(t,n,2,s,oa(a,i));return s0(t,e,c,oa(a,o)),null!==c.attrs&&lm(c,c.attrs,!1),null!==c.mergedAttrs&&lm(c,c.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,c),c}(o,i,s,0,t,e,r):i.data[o];Xi(c,!0);const u=c.mergedAttrs;null!==u&&Vp(a,l,u);const d=c.classes;null!==d&&Hb(a,l,d);const h=c.styles;return null!==h&&z1(a,l,h),64!=(64&c.flags)&&tm(i,s,l,c),0===function lH(){return dt.lFrame.elementDepthCount}()&&Hr(l,s),function cH(){dt.lFrame.elementDepthCount++}(),Np(c)&&(n0(i,s,c),function ok(n,t,e){if(qv(t)){const s=t.directiveEnd;for(let i=t.directiveStart;i<s;i++){const o=n.data[i];o.contentQueries&&o.contentQueries(1,e[i],i)}}}(i,c,s)),null!==r&&r0(s,c),Re}function Be(){let n=or();rb()?sb():(n=n.parent,Xi(n,!1));const t=n;!function uH(){dt.lFrame.elementDepthCount--}();const e=Vt();return e.firstCreatePass&&(Pp(e,n),qv(n)&&e.queries.elementEnd(n)),null!=t.classesWithoutHost&&function kH(n){return 0!=(16&n.flags)}(t)&&D0(e,t,ye(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function NH(n){return 0!=(32&n.flags)}(t)&&D0(e,t,ye(),t.stylesWithoutHost,!1),Be}function hn(n,t,e,r){return Re(n,t,e,r),Be(),hn}function Uc(){return ye()}function fm(n){return!!n&&"function"==typeof n.then}const uN=function cN(n){return!!n&&"function"==typeof n.subscribe};function Dr(n,t,e,r){const s=ye(),i=Vt(),o=or();return dN(i,s,s[11],o,n,t,!!e,r),Dr}function Od(n,t){const e=or(),r=ye(),s=Vt();return dN(s,r,wk(ob(s.data),e,r),e,n,t,!1),Od}function dN(n,t,e,r,s,i,o,a){const l=Np(r),u=n.firstCreatePass&&xk(n),d=t[8],h=bk(t);let f=!0;if(3&r.type||a){const g=Ys(r,t),_=a?a(g):g,y=h.length,v=a?b=>a(Xn(b[r.index])):r.index;if(Fn(e)){let b=null;if(!a&&l&&(b=function _G(n,t,e,r){const s=n.cleanup;if(null!=s)for(let i=0;i<s.length-1;i+=2){const o=s[i];if(o===e&&s[i+1]===r){const a=t[7],l=s[i+2];return a.length>l?a[l]:null}"string"==typeof o&&(i+=2)}return null}(n,t,s,r.index)),null!==b)(b.__ngLastListenerFn__||b).__ngNextListenerFn__=i,b.__ngLastListenerFn__=i,f=!1;else{i=I0(r,t,d,i,!1);const w=e.listen(_,s,i);h.push(i,w),u&&u.push(s,v,y,y+1)}}else i=I0(r,t,d,i,!0),_.addEventListener(s,i,o),h.push(i),u&&u.push(s,v,y,o)}else i=I0(r,t,d,i,!1);const p=r.outputs;let m;if(f&&null!==p&&(m=p[s])){const g=m.length;if(g)for(let _=0;_<g;_+=2){const C=t[m[_]][m[_+1]].subscribe(i),E=h.length;h.push(i,C),u&&u.push(s,r.index,E,-(E+1))}}}function hN(n,t,e,r){try{return!1!==e(r)}catch(s){return Ck(n,s),!1}}function I0(n,t,e,r,s){return function i(o){if(o===Function)return r;const a=2&n.flags?Ts(n.index,t):t;0==(32&t[2])&&l0(a);let l=hN(t,0,r,o),c=i.__ngNextListenerFn__;for(;c;)l=hN(t,0,c,o)&&l,c=c.__ngNextListenerFn__;return s&&!1===l&&(o.preventDefault(),o.returnValue=!1),l}}function ha(n=1){return function _H(n){return(dt.lFrame.contextLView=function vH(n,t){for(;n>0;)t=t[15],n--;return t}(n,dt.lFrame.contextLView))[8]}(n)}function vG(n,t){let e=null;const r=function Ij(n){const t=n.attrs;if(null!=t){const e=t.indexOf(5);if(0==(1&e))return t[e+1]}return null}(n);for(let s=0;s<t.length;s++){const i=t[s];if("*"!==i){if(null===r?W1(n,i,!0):Nj(r,i))return s}else e=s}return e}function fa(n){const t=ye()[16][6];if(!t.projection){const r=t.projection=_d(n?n.length:1,null),s=r.slice();let i=t.child;for(;null!==i;){const o=n?vG(i,n):0;null!==o&&(s[o]?s[o].projectionNext=i:r[o]=i,s[o]=i),i=i.next}}}function Ni(n,t=0,e){const r=ye(),s=Vt(),i=Ec(s,20+n,16,null,e||null);null===i.projection&&(i.projection=t),sb(),64!=(64&i.flags)&&function bj(n,t,e){B1(t[11],0,t,e,N1(n,e,t),O1(e.parent||t[6],e,t))}(s,r,i)}function wN(n,t,e,r,s){const i=n[e+1],o=null===t;let a=r?Ii(i):Mo(i),l=!1;for(;0!==a&&(!1===l||o);){const u=n[a+1];wG(n[a],t)&&(l=!0,n[a+1]=r?Gb(u):jb(u)),a=r?Ii(u):Mo(u)}l&&(n[e+1]=r?jb(i):Gb(i))}function wG(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||"string"!=typeof t)&&vc(n,t)>=0}function pm(n,t,e){return Ai(n,t,e,!1),pm}function ms(n,t){return Ai(n,t,null,!0),ms}function Ai(n,t,e,r){const s=ye(),i=Vt(),o=function Ro(n){const t=dt.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,e}(2);i.firstUpdatePass&&function NN(n,t,e,r){const s=n.data;if(null===s[e+1]){const i=s[es()],o=function kN(n,t){return t>=n.expandoStartIndex}(n,e);(function ON(n,t){return 0!=(n.flags&(t?16:32))})(i,r)&&null===t&&!o&&(t=!1),t=function AG(n,t,e,r){const s=ob(n);let i=r?t.residualClasses:t.residualStyles;if(null===s)0===(r?t.classBindings:t.styleBindings)&&(e=Fd(e=k0(null,n,t,e,r),t.attrs,r),i=null);else{const o=t.directiveStylingLast;if(-1===o||n[o]!==s)if(e=k0(s,n,t,e,r),null===i){let l=function RG(n,t,e){const r=e?t.classBindings:t.styleBindings;if(0!==Mo(r))return n[Ii(r)]}(n,t,r);void 0!==l&&Array.isArray(l)&&(l=k0(null,n,t,l[1],r),l=Fd(l,t.attrs,r),function MG(n,t,e,r){n[Ii(e?t.classBindings:t.styleBindings)]=r}(n,t,r,l))}else i=function OG(n,t,e){let r;const s=t.directiveEnd;for(let i=1+t.directiveStylingLast;i<s;i++)r=Fd(r,n[i].hostAttrs,e);return Fd(r,t.attrs,e)}(n,t,r)}return void 0!==i&&(r?t.residualClasses=i:t.residualStyles=i),e}(s,i,t,r),function bG(n,t,e,r,s,i){let o=i?t.classBindings:t.styleBindings,a=Ii(o),l=Mo(o);n[r]=e;let u,c=!1;if(Array.isArray(e)){const d=e;u=d[1],(null===u||vc(d,u)>0)&&(c=!0)}else u=e;if(s)if(0!==l){const h=Ii(n[a+1]);n[r+1]=rm(h,a),0!==h&&(n[h+1]=Wb(n[h+1],r)),n[a+1]=function Oj(n,t){return 131071&n|t<<17}(n[a+1],r)}else n[r+1]=rm(a,0),0!==a&&(n[a+1]=Wb(n[a+1],r)),a=r;else n[r+1]=rm(l,0),0===a?a=r:n[l+1]=Wb(n[l+1],r),l=r;c&&(n[r+1]=jb(n[r+1])),wN(n,u,r,!0),wN(n,u,r,!1),function xG(n,t,e,r,s){const i=s?n.residualClasses:n.residualStyles;null!=i&&"string"==typeof t&&vc(i,t)>=0&&(e[r+1]=Gb(e[r+1]))}(t,u,n,r,i),o=rm(a,l),i?t.classBindings=o:t.styleBindings=o}(s,i,t,e,o,r)}}(i,n,o,r),t!==mt&&jr(s,o,t)&&function RN(n,t,e,r,s,i,o,a){if(!(3&t.type))return;const l=n.data,c=l[a+1];mm(function Y1(n){return 1==(1&n)}(c)?MN(l,t,e,s,Mo(c),o):void 0)||(mm(i)||function X1(n){return 2==(2&n)}(c)&&(i=MN(l,null,e,s,a,o)),function wj(n,t,e,r,s){const i=Fn(n);if(t)s?i?n.addClass(e,r):e.classList.add(r):i?n.removeClass(e,r):e.classList.remove(r);else{let o=-1===r.indexOf("-")?void 0:As.DashCase;if(null==s)i?n.removeStyle(e,r,o):e.style.removeProperty(r);else{const a="string"==typeof s&&s.endsWith("!important");a&&(s=s.slice(0,-10),o|=As.Important),i?n.setStyle(e,r,s,o):e.style.setProperty(r,s,a?"important":"")}}}(r,o,Ap(es(),e),s,i))}(i,i.data[es()],s,s[11],n,s[o+1]=function $G(n,t){return null==n||("string"==typeof t?n+=t:"object"==typeof n&&(n=Xt(Ns(n)))),n}(t,e),r,o)}function k0(n,t,e,r,s){let i=null;const o=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<o&&(i=t[a],r=Fd(r,i.hostAttrs,s),i!==n);)a++;return null!==n&&(e.directiveStylingLast=a),r}function Fd(n,t,e){const r=e?1:2;let s=-1;if(null!==t)for(let i=0;i<t.length;i++){const o=t[i];"number"==typeof o?s=o:s===r&&(Array.isArray(n)||(n=void 0===n?[]:["",n]),ks(n,o,!!e||t[++i]))}return void 0===n?null:n}function MN(n,t,e,r,s,i){const o=null===t;let a;for(;s>0;){const l=n[s],c=Array.isArray(l),u=c?l[1]:l,d=null===u;let h=e[s+1];h===mt&&(h=d?rn:void 0);let f=d?yb(h,r):u===r?h:void 0;if(c&&!mm(f)&&(f=yb(l,r)),mm(f)&&(a=f,o))return a;const p=n[s+1];s=o?Ii(p):Mo(p)}if(null!==t){let l=i?t.residualClasses:t.residualStyles;null!=l&&(a=yb(l,r))}return a}function mm(n){return void 0!==n}function nt(n,t=""){const e=ye(),r=Vt(),s=n+20,i=r.firstCreatePass?Ec(r,s,1,t,null):r.data[s],o=e[s]=function Pb(n,t){return Fn(n)?n.createText(t):n.createTextNode(t)}(e[11],t);tm(r,e,o,i),Xi(i,!1)}function gm(n){return ym("",n,""),gm}function ym(n,t,e){const r=ye(),s=function Mc(n,t,e,r){return jr(n,uc(),e)?t+pt(e)+r:mt}(r,n,t,e);return s!==mt&&Oo(r,es(),s),ym}function N0(n,t,e){const r=ye();return jr(r,uc(),t)&&Rs(Vt(),Pn(),r,n,t,r[11],e,!0),N0}function Pd(n,t,e){const r=ye();if(jr(r,uc(),t)){const i=Vt(),o=Pn();Rs(i,o,r,n,t,wk(ob(i.data),o,r),e,!0)}return Pd}const _m="en-US";let eA=_m;function M0(n,t,e,r,s){if(n=xt(n),Array.isArray(n))for(let i=0;i<n.length;i++)M0(n[i],t,e,r,s);else{const i=Vt(),o=ye();let a=Nc(n)?n:xt(n.provide),l=kk(n);const c=or(),u=1048575&c.providerIndexes,d=c.directiveStart,h=c.providerIndexes>>20;if(Nc(n)||!n.multi){const f=new hd(l,s,oe),p=F0(a,t,s?u:u+h,d);-1===p?(Hp(pd(c,o),i,a),O0(i,n,t.length),t.push(a),c.directiveStart++,c.directiveEnd++,s&&(c.providerIndexes+=1048576),e.push(f),o.push(f)):(e[p]=f,o[p]=f)}else{const f=F0(a,t,u+h,d),p=F0(a,t,u,u+h),m=f>=0&&e[f],g=p>=0&&e[p];if(s&&!g||!s&&!m){Hp(pd(c,o),i,a);const _=function n6(n,t,e,r,s){const i=new hd(n,e,oe);return i.multi=[],i.index=t,i.componentProviders=0,DA(i,s,r&&!e),i}(s?t6:e6,e.length,s,r,l);!s&&g&&(e[p].providerFactory=_),O0(i,n,t.length,0),t.push(a),c.directiveStart++,c.directiveEnd++,s&&(c.providerIndexes+=1048576),e.push(_),o.push(_)}else O0(i,n,f>-1?f:p,DA(e[s?p:f],l,!s&&r));!s&&r&&g&&e[p].componentProviders++}}}function O0(n,t,e,r){const s=Nc(t),i=function IW(n){return!!n.useClass}(t);if(s||i){const l=(i?xt(t.useClass):t).prototype.ngOnDestroy;if(l){const c=n.destroyHooks||(n.destroyHooks=[]);if(!s&&t.multi){const u=c.indexOf(e);-1===u?c.push(e,[r,l]):c[u+1].push(r,l)}else c.push(e,l)}}}function DA(n,t,e){return e&&n.componentProviders++,n.multi.push(t)-1}function F0(n,t,e,r){for(let s=e;s<r;s++)if(t[s]===n)return s;return-1}function e6(n,t,e,r){return P0(this.multi,[])}function t6(n,t,e,r){const s=this.multi;let i;if(this.providerFactory){const o=this.providerFactory.componentProviders,a=md(e,e[1],this.providerFactory.index,r);i=a.slice(0,o),P0(s,i);for(let l=o;l<a.length;l++)i.push(a[l])}else i=[],P0(s,i);return i}function P0(n,t){for(let e=0;e<n.length;e++)t.push((0,n[e])());return t}function pa(n,t=[]){return e=>{e.providersResolver=(r,s)=>function Jq(n,t,e){const r=Vt();if(r.firstCreatePass){const s=Di(n);M0(e,r.data,r.blueprint,s,!0),M0(t,r.data,r.blueprint,s,!1)}}(r,s?s(n):n,t)}}class SA{}class i6{resolveComponentFactory(t){throw function s6(n){const t=Error(`No component factory found for ${Xt(n)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=n,t}(t)}}let ul=(()=>{class n{}return n.NULL=new i6,n})();function o6(){return Gc(or(),ye())}function Gc(n,t){return new Cn(Ys(n,t))}let Cn=(()=>{class n{constructor(e){this.nativeElement=e}}return n.__NG_ELEMENT_ID__=o6,n})();function a6(n){return n instanceof Cn?n.nativeElement:n}class zd{}let Cm=(()=>{class n{}return n.__NG_ELEMENT_ID__=()=>function c6(){const n=ye(),e=Ts(or().index,n);return function l6(n){return n[11]}(Ki(e)?e:n)}(),n})(),u6=(()=>{class n{}return n.\u0275prov=Ve({token:n,providedIn:"root",factory:()=>null}),n})();class qc{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const d6=new qc("13.3.3"),$0={};function Dm(n,t,e,r,s=!1){for(;null!==e;){const i=t[e.index];if(null!==i&&r.push(Xn(i)),Ci(i))for(let a=10;a<i.length;a++){const l=i[a],c=l[1].firstChild;null!==c&&Dm(l[1],l,c,r)}const o=e.type;if(8&o)Dm(n,t,e.child,r);else if(32&o){const a=Mb(e,t);let l;for(;l=a();)r.push(l)}else if(16&o){const a=L1(t,e);if(Array.isArray(a))r.push(...a);else{const l=Id(t[16]);Dm(l[1],l,a,r,!0)}}e=s?e.projectionNext:e.next}return r}class Ud{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return Dm(e,t,e.firstChild,[])}get context(){return this._lView[8]}set context(t){this._lView[8]=t}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(Ci(t)){const e=t[8],r=e?e.indexOf(this):-1;r>-1&&(Lb(t,r),Wp(e,r))}this._attachedToViewContainer=!1}k1(this._lView[1],this._lView)}onDestroy(t){uk(this._lView[1],this._lView,null,t)}markForCheck(){l0(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){u0(this._lView[1],this._lView,this.context)}checkNoChanges(){!function gW(n,t,e){Mp(!0);try{u0(n,t,e)}finally{Mp(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new je(902,"");this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function hj(n,t){Td(n,t,t[11],2,null,null)}(this._lView[1],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new je(902,"");this._appRef=t}}class h6 extends Ud{constructor(t){super(t),this._view=t}detectChanges(){vk(this._view)}checkNoChanges(){!function yW(n){Mp(!0);try{vk(n)}finally{Mp(!1)}}(this._view)}get context(){return null}}class IA extends ul{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=zr(t);return new L0(e,this.ngModule)}}function TA(n){const t=[];for(let e in n)n.hasOwnProperty(e)&&t.push({propName:n[e],templateName:e});return t}class L0 extends SA{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=function Rj(n){return n.map(Aj).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return TA(this.componentDef.inputs)}get outputs(){return TA(this.componentDef.outputs)}create(t,e,r,s){const i=(s=s||this.ngModule)?function p6(n,t){return{get:(e,r,s)=>{const i=n.get(e,$0,s);return i!==$0||r===$0?i:t.get(e,r,s)}}}(t,s.injector):t,o=i.get(zd,gT),a=i.get(u6,null),l=o.createRenderer(null,this.componentDef),c=this.componentDef.selectors[0][0]||"div",u=r?function ck(n,t,e){if(Fn(n))return n.selectRootElement(t,e===xi.ShadowDom);let r="string"==typeof t?n.querySelector(t):t;return r.textContent="",r}(l,r,this.componentDef.encapsulation):$b(o.createRenderer(null,this.componentDef),c,function f6(n){const t=n.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(c)),d=this.componentDef.onPush?576:528,h=function zk(n,t){return{components:[],scheduler:n||sj,clean:_W,playerHandler:t||null,flags:0}}(),f=om(0,null,null,1,0,null,null,null,null,null),p=kd(null,f,h,d,null,null,o,l,a,i);let m,g;Op(p);try{const _=function Vk(n,t,e,r,s,i){const o=e[1];e[20]=n;const l=Ec(o,20,2,"#host",null),c=l.mergedAttrs=t.hostAttrs;null!==c&&(lm(l,c,!0),null!==n&&(Vp(s,n,c),null!==l.classes&&Hb(s,n,l.classes),null!==l.styles&&z1(s,n,l.styles)));const u=r.createRenderer(n,t),d=kd(e,ak(t),null,t.onPush?64:16,e[20],l,r,u,i||null,null);return o.firstCreatePass&&(Hp(pd(l,e),o,t.type),mk(o,l),gk(l,e.length,1)),am(e,d),e[20]=d}(u,this.componentDef,p,o,l);if(u)if(r)Vp(l,u,["ng-version",d6.full]);else{const{attrs:y,classes:v}=function Mj(n){const t=[],e=[];let r=1,s=2;for(;r<n.length;){let i=n[r];if("string"==typeof i)2===s?""!==i&&t.push(i,n[++r]):8===s&&e.push(i);else{if(!Ei(s))break;s=i}r++}return{attrs:t,classes:e}}(this.componentDef.selectors[0]);y&&Vp(l,u,y),v&&v.length>0&&Hb(l,u,v.join(" "))}if(g=eb(f,20),void 0!==e){const y=g.projection=[];for(let v=0;v<this.ngContentSelectors.length;v++){const b=e[v];y.push(null!=b?Array.from(b):null)}}m=function Bk(n,t,e,r,s){const i=e[1],o=function eW(n,t,e){const r=or();n.firstCreatePass&&(e.providersResolver&&e.providersResolver(e),yk(n,r,t,Ic(n,t,1,null),e));const s=md(t,n,r.directiveStart,r);Hr(s,t);const i=Ys(r,t);return i&&Hr(i,t),s}(i,e,t);if(r.components.push(o),n[8]=o,s&&s.forEach(l=>l(o,t)),t.contentQueries){const l=or();t.contentQueries(1,o,l.directiveStart)}const a=or();return!i.firstCreatePass||null===t.hostBindings&&null===t.hostAttrs||(aa(a.index),fk(e[1],a,0,a.directiveStart,a.directiveEnd,t),pk(t,o)),o}(_,this.componentDef,p,h,[LW]),Nd(f,p,null)}finally{Fp()}return new g6(this.componentType,m,Gc(g,p),p,g)}}class g6 extends class r6{}{constructor(t,e,r,s,i){super(),this.location=r,this._rootLView=s,this._tNode=i,this.instance=e,this.hostView=this.changeDetectorRef=new h6(s),this.componentType=t}get injector(){return new fc(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}class Fo{}class kA{}const Kc=new Map;class RA extends Fo{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new IA(this);const r=qs(t);this._bootstrapComponents=Ji(r.bootstrap),this._r3Injector=Tk(t,e,[{provide:Fo,useValue:this},{provide:ul,useValue:this.componentFactoryResolver}],Xt(t)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(t)}get(t,e=Tn.THROW_IF_NOT_FOUND,r=ut.Default){return t===Tn||t===Fo||t===h0?this:this._r3Injector.get(t,e,r)}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class V0 extends kA{constructor(t){super(),this.moduleType=t,null!==qs(t)&&function _6(n){const t=new Set;!function e(r){const s=qs(r,!0),i=s.id;null!==i&&(function NA(n,t,e){if(t&&t!==e)throw new Error(`Duplicate module registered for ${n} - ${Xt(t)} vs ${Xt(t.name)}`)}(i,Kc.get(i),r),Kc.set(i,r));const o=Ji(s.imports);for(const a of o)t.has(a)||(t.add(a),e(a))}(n)}(t)}create(t){return new RA(this.moduleType,t)}}function B0(n,t,e,r){return function OA(n,t,e,r,s,i){const o=t+e;return jr(n,o,s)?to(n,o+1,i?r.call(i,s):r(s)):function Hd(n,t){const e=n[t];return e===mt?void 0:e}(n,o+1)}(ye(),Jr(),n,t,e,r)}function z0(n){return t=>{setTimeout(n,void 0,t)}}const Bt=class O6 extends Ge{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,r){var s,i,o;let a=t,l=e||(()=>null),c=r;if(t&&"object"==typeof t){const d=t;a=null===(s=d.next)||void 0===s?void 0:s.bind(d),l=null===(i=d.error)||void 0===i?void 0:i.bind(d),c=null===(o=d.complete)||void 0===o?void 0:o.bind(d)}this.__isAsync&&(l=z0(l),a&&(a=z0(a)),c&&(c=z0(c)));const u=super.subscribe({next:a,error:l,complete:c});return t instanceof x&&t.add(u),u}};function F6(){return this._results[Ac()]()}class Sm{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=Ac(),r=Sm.prototype;r[e]||(r[e]=F6)}get changes(){return this._changes||(this._changes=new Bt)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const r=this;r.dirty=!1;const s=Zs(t);(this._changesDetected=!function BH(n,t,e){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++){let s=n[r],i=t[r];if(e&&(s=e(s),i=e(i)),i!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}Symbol;let ei=(()=>{class n{}return n.__NG_ELEMENT_ID__=L6,n})();const P6=ei,$6=class extends P6{constructor(t,e,r){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=r}createEmbeddedView(t){const e=this._declarationTContainer.tViews,r=kd(this._declarationLView,e,t,16,null,e.declTNode,null,null,null,null);r[17]=this._declarationLView[this._declarationTContainer.index];const i=this._declarationLView[19];return null!==i&&(r[19]=i.createEmbeddedView(e)),Nd(e,r,t),new Ud(r)}};function L6(){return Em(or(),ye())}function Em(n,t){return 4&n.type?new $6(t,n,Gc(n,t)):null}let Ms=(()=>{class n{}return n.__NG_ELEMENT_ID__=V6,n})();function V6(){return zA(or(),ye())}const B6=Ms,VA=class extends B6{constructor(t,e,r){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=r}get element(){return Gc(this._hostTNode,this._hostLView)}get injector(){return new fc(this._hostTNode,this._hostLView)}get parentInjector(){const t=Up(this._hostTNode,this._hostLView);if(RT(t)){const e=hc(t,this._hostLView),r=dc(t);return new fc(e[1].data[r+8],e)}return new fc(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=BA(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-10}createEmbeddedView(t,e,r){const s=t.createEmbeddedView(e||{});return this.insert(s,r),s}createComponent(t,e,r,s,i){const o=t&&!function yd(n){return"function"==typeof n}(t);let a;if(o)a=e;else{const d=e||{};a=d.index,r=d.injector,s=d.projectableNodes,i=d.ngModuleRef}const l=o?t:new L0(zr(t)),c=r||this.parentInjector;if(!i&&null==l.ngModule){const h=(o?c:this.parentInjector).get(Fo,null);h&&(i=h)}const u=l.create(c,s,void 0,i);return this.insert(u.hostView,a),u}insert(t,e){const r=t._lView,s=r[1];if(function aH(n){return Ci(n[3])}(r)){const u=this.indexOf(t);if(-1!==u)this.detach(u);else{const d=r[3],h=new VA(d,d[6],d[3]);h.detach(h.indexOf(t))}}const i=this._adjustIndex(e),o=this._lContainer;!function pj(n,t,e,r){const s=10+r,i=e.length;r>0&&(e[s-1][4]=t),r<i-10?(t[4]=e[s],HT(e,10+r,t)):(e.push(t),t[4]=null),t[3]=e;const o=t[17];null!==o&&e!==o&&function mj(n,t){const e=n[9];t[16]!==t[3][3][16]&&(n[2]=!0),null===e?n[9]=[t]:e.push(t)}(o,t);const a=t[19];null!==a&&a.insertView(n),t[2]|=128}(s,r,o,i);const a=zb(i,o),l=r[11],c=em(l,o[7]);return null!==c&&function dj(n,t,e,r,s,i){r[0]=s,r[6]=t,Td(n,r,e,1,s,i)}(s,o[6],l,r,c,a),t.attachToViewContainerRef(),HT(U0(o),i,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=BA(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),r=Lb(this._lContainer,e);r&&(Wp(U0(this._lContainer),e),k1(r[1],r))}detach(t){const e=this._adjustIndex(t,-1),r=Lb(this._lContainer,e);return r&&null!=Wp(U0(this._lContainer),e)?new Ud(r):null}_adjustIndex(t,e=0){return null==t?this.length+e:t}};function BA(n){return n[8]}function U0(n){return n[8]||(n[8]=[])}function zA(n,t){let e;const r=t[n.index];if(Ci(r))e=r;else{let s;if(8&n.type)s=Xn(r);else{const i=t[11];s=i.createComment("");const o=Ys(n,t);ol(i,em(i,o),s,function vj(n,t){return Fn(n)?n.nextSibling(t):t.nextSibling}(i,o),!1)}t[n.index]=e=_k(r,t,s,n),am(t,e)}return new VA(e,n,t)}class H0{constructor(t){this.queryList=t,this.matches=null}clone(){return new H0(this.queryList)}setDirty(){this.queryList.setDirty()}}class j0{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const r=null!==t.contentQueries?t.contentQueries[0]:e.length,s=[];for(let i=0;i<r;i++){const o=e.getByIndex(i);s.push(this.queries[o.indexInDeclarationView].clone())}return new j0(s)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==GA(t,e).matches&&this.queries[e].setDirty()}}class UA{constructor(t,e,r=null){this.predicate=t,this.flags=e,this.read=r}}class W0{constructor(t=[]){this.queries=t}elementStart(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,i=this.getByIndex(r).embeddedTView(t,s);i&&(i.indexInDeclarationView=r,null!==e?e.push(i):e=[i])}return null!==e?new W0(e):null}template(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class G0{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new G0(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=t.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const i=r[s];this.matchTNodeWithReadOption(t,e,H6(e,i)),this.matchTNodeWithReadOption(t,e,jp(e,t,i,!1,!1))}else r===ei?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,jp(e,t,r,!1,!1))}matchTNodeWithReadOption(t,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===Cn||s===Ms||s===ei&&4&e.type)this.addMatch(e.index,-2);else{const i=jp(e,t,s,!1,!1);null!==i&&this.addMatch(e.index,i)}else this.addMatch(e.index,r)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function H6(n,t){const e=n.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===t)return e[r+1];return null}function W6(n,t,e,r){return-1===e?function j6(n,t){return 11&n.type?Gc(n,t):4&n.type?Em(n,t):null}(t,n):-2===e?function G6(n,t,e){return e===Cn?Gc(t,n):e===ei?Em(t,n):e===Ms?zA(t,n):void 0}(n,t,r):md(n,n[1],e,t)}function HA(n,t,e,r){const s=t[19].queries[r];if(null===s.matches){const i=n.data,o=e.matches,a=[];for(let l=0;l<o.length;l+=2){const c=o[l];a.push(c<0?null:W6(t,i[c],o[l+1],e.metadata.read))}s.matches=a}return s.matches}function q0(n,t,e,r){const s=n.queries.getByIndex(e),i=s.matches;if(null!==i){const o=HA(n,t,s,e);for(let a=0;a<i.length;a+=2){const l=i[a];if(l>0)r.push(o[a/2]);else{const c=i[a+1],u=t[-l];for(let d=10;d<u.length;d++){const h=u[d];h[17]===h[3]&&q0(h[1],h,c,r)}if(null!==u[9]){const d=u[9];for(let h=0;h<d.length;h++){const f=d[h];q0(f[1],f,c,r)}}}}}return r}function rs(n){const t=ye(),e=Vt(),r=CT();ab(r+1);const s=GA(e,r);if(n.dirty&&yT(t)===(2==(2&s.metadata.flags))){if(null===s.matches)n.reset([]);else{const i=s.crossesNgTemplate?q0(e,t,r,[]):HA(e,t,s,r);n.reset(i,a6),n.notifyOnChanges()}return!0}return!1}function dl(n,t,e){const r=Vt();r.firstCreatePass&&(WA(r,new UA(n,t,e),-1),2==(2&t)&&(r.staticViewQueries=!0)),jA(r,ye(),t)}function Po(n,t,e,r){const s=Vt();if(s.firstCreatePass){const i=or();WA(s,new UA(t,e,r),i.index),function K6(n,t){const e=n.contentQueries||(n.contentQueries=[]);t!==(e.length?e[e.length-1]:-1)&&e.push(n.queries.length-1,t)}(s,n),2==(2&e)&&(s.staticContentQueries=!0)}jA(s,ye(),e)}function ss(){return function q6(n,t){return n[19].queries[t].queryList}(ye(),CT())}function jA(n,t,e){const r=new Sm(4==(4&e));uk(n,t,r,r.destroy),null===t[19]&&(t[19]=new j0),t[19].queries.push(new H0(r))}function WA(n,t,e){null===n.queries&&(n.queries=new W0),n.queries.track(new G0(t,e))}function GA(n,t){return n.queries.getByIndex(t)}function km(...n){}const J0=new Fe("Application Initializer");let ex=(()=>{class n{constructor(e){this.appInits=e,this.resolve=km,this.reject=km,this.initialized=!1,this.done=!1,this.donePromise=new Promise((r,s)=>{this.resolve=r,this.reject=s})}runInitializers(){if(this.initialized)return;const e=[],r=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let s=0;s<this.appInits.length;s++){const i=this.appInits[s]();if(fm(i))e.push(i);else if(uN(i)){const o=new Promise((a,l)=>{i.subscribe({complete:a,error:l})});e.push(o)}}Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return n.\u0275fac=function(e){return new(e||n)(ee(J0,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Gd=new Fe("AppId",{providedIn:"root",factory:function cR(){return`${tx()}${tx()}${tx()}`}});function tx(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const uR=new Fe("Platform Initializer"),nx=new Fe("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),dR=new Fe("appBootstrapListener");let h8=(()=>{class n{log(e){console.log(e)}warn(e){console.warn(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();const $o=new Fe("LocaleId",{providedIn:"root",factory:()=>Kp($o,ut.Optional|ut.SkipSelf)||function f8(){return"undefined"!=typeof $localize&&$localize.locale||_m}()});class m8{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}let hR=(()=>{class n{compileModuleSync(e){return new V0(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),i=Ji(qs(e).declarations).reduce((o,a)=>{const l=zr(a);return l&&o.push(new L0(l)),o},[]);return new m8(r,i)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const y8=(()=>Promise.resolve(0))();function rx(n){"undefined"==typeof Zone?y8.then(()=>{n&&n.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",n)}class Ct{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Bt(!1),this.onMicrotaskEmpty=new Bt(!1),this.onStable=new Bt(!1),this.onError=new Bt(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function _8(){let n=en.requestAnimationFrame,t=en.cancelAnimationFrame;if("undefined"!=typeof Zone&&n&&t){const e=n[Zone.__symbol__("OriginalDelegate")];e&&(n=e);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function x8(n){const t=()=>{!function b8(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(en,()=>{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{n.lastRequestAnimationFrameId=-1,ix(n),n.isCheckStableRunning=!0,sx(n),n.isCheckStableRunning=!1},void 0,()=>{},()=>{})),n.fakeTopEventTask.invoke()}),ix(n))}(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,i,o,a)=>{try{return fR(n),e.invokeTask(s,i,o,a)}finally{(n.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||n.shouldCoalesceRunChangeDetection)&&t(),pR(n)}},onInvoke:(e,r,s,i,o,a,l)=>{try{return fR(n),e.invoke(s,i,o,a,l)}finally{n.shouldCoalesceRunChangeDetection&&t(),pR(n)}},onHasTask:(e,r,s,i)=>{e.hasTask(s,i),r===s&&("microTask"==i.change?(n._hasPendingMicrotasks=i.microTask,ix(n),sx(n)):"macroTask"==i.change&&(n.hasPendingMacrotasks=i.macroTask))},onHandleError:(e,r,s,i)=>(e.handleError(s,i),n.runOutsideAngular(()=>n.onError.emit(i)),!1)})}(s)}static isInAngularZone(){return"undefined"!=typeof Zone&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Ct.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(Ct.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(t,e,r){return this._inner.run(t,e,r)}runTask(t,e,r,s){const i=this._inner,o=i.scheduleEventTask("NgZoneEvent: "+s,t,v8,km,km);try{return i.runTask(o,e,r)}finally{i.cancelTask(o)}}runGuarded(t,e,r){return this._inner.runGuarded(t,e,r)}runOutsideAngular(t){return this._outer.run(t)}}const v8={};function sx(n){if(0==n._nesting&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function ix(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&-1!==n.lastRequestAnimationFrameId)}function fR(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function pR(n){n._nesting--,sx(n)}class w8{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Bt,this.onMicrotaskEmpty=new Bt,this.onStable=new Bt,this.onError=new Bt}run(t,e,r){return t.apply(e,r)}runGuarded(t,e,r){return t.apply(e,r)}runOutsideAngular(t){return t()}runTask(t,e,r,s){return t.apply(e,r)}}let ox=(()=>{class n{constructor(e){this._ngZone=e,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Ct.assertNotInAngularZone(),rx(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())rx(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let i=-1;r&&r>0&&(i=setTimeout(()=>{this._callbacks=this._callbacks.filter(o=>o.timeoutId!==i),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:i,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(e,r,s){return[]}}return n.\u0275fac=function(e){return new(e||n)(ee(Ct))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})(),C8=(()=>{class n{constructor(){this._applications=new Map,ax.addToWindow(this)}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return ax.findTestabilityInTree(this,e,r)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();class D8{addToWindow(t){}findTestabilityInTree(t,e,r){return null}}let Mi,ax=new D8;const mR=new Fe("AllowMultipleToken");class gR{constructor(t,e){this.name=t,this.token=e}}function yR(n,t,e=[]){const r=`Platform: ${t}`,s=new Fe(r);return(i=[])=>{let o=_R();if(!o||o.injector.get(mR,!1))if(n)n(e.concat(i).concat({provide:s,useValue:!0}));else{const a=e.concat(i).concat({provide:s,useValue:!0},{provide:f0,useValue:"platform"});!function T8(n){if(Mi&&!Mi.destroyed&&!Mi.injector.get(mR,!1))throw new je(400,"");Mi=n.get(N8);const t=n.get(uR,null);t&&t.forEach(e=>e())}(Tn.create({providers:a,name:r}))}return function k8(n){const t=_R();if(!t)throw new je(401,"");return t}()}}function _R(){return Mi&&!Mi.destroyed?Mi:null}let N8=(()=>{class n{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const a=function A8(n,t){let e;return e="noop"===n?new w8:("zone.js"===n?void 0:n)||new Ct({enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!!(null==t?void 0:t.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==t?void 0:t.ngZoneRunCoalescing)}),e}(r?r.ngZone:void 0,{ngZoneEventCoalescing:r&&r.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:r&&r.ngZoneRunCoalescing||!1}),l=[{provide:Ct,useValue:a}];return a.run(()=>{const c=Tn.create({providers:l,parent:this.injector,name:e.moduleType.name}),u=e.create(c),d=u.injector.get(ca,null);if(!d)throw new je(402,"");return a.runOutsideAngular(()=>{const h=a.onError.subscribe({next:f=>{d.handleError(f)}});u.onDestroy(()=>{lx(this._modules,u),h.unsubscribe()})}),function R8(n,t,e){try{const r=e();return fm(r)?r.catch(s=>{throw t.runOutsideAngular(()=>n.handleError(s)),s}):r}catch(r){throw t.runOutsideAngular(()=>n.handleError(r)),r}}(d,a,()=>{const h=u.injector.get(ex);return h.runInitializers(),h.donePromise.then(()=>(function lq(n){Es(n,"Expected localeId to be defined"),"string"==typeof n&&(eA=n.toLowerCase().replace(/_/g,"-"))}(u.injector.get($o,_m)||_m),this._moduleDoBootstrap(u),u))})})}bootstrapModule(e,r=[]){const s=vR({},r);return function E8(n,t,e){const r=new V0(e);return Promise.resolve(r)}(0,0,e).then(i=>this.bootstrapModuleFactory(i,s))}_moduleDoBootstrap(e){const r=e.injector.get(Nm);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new je(403,"");e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new je(404,"");this._modules.slice().forEach(e=>e.destroy()),this._destroyListeners.forEach(e=>e()),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(e){return new(e||n)(ee(Tn))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();function vR(n,t){return Array.isArray(t)?t.reduce(vR,n):Object.assign(Object.assign({},n),t)}let Nm=(()=>{class n{constructor(e,r,s,i){this._zone=e,this._injector=r,this._exceptionHandler=s,this._initStatus=i,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new ct(l=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{l.next(this._stable),l.complete()})}),a=new ct(l=>{let c;this._zone.runOutsideAngular(()=>{c=this._zone.onStable.subscribe(()=>{Ct.assertNotInAngularZone(),rx(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,l.next(!0))})})});const u=this._zone.onUnstable.subscribe(()=>{Ct.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{l.next(!1)}))});return()=>{c.unsubscribe(),u.unsubscribe()}});this.isStable=id(o,a.pipe(tT()))}bootstrap(e,r){if(!this._initStatus.done)throw new je(405,"");let s;s=e instanceof SA?e:this._injector.get(ul).resolveComponentFactory(e),this.componentTypes.push(s.componentType);const i=function I8(n){return n.isBoundToModule}(s)?void 0:this._injector.get(Fo),a=s.create(Tn.NULL,[],r||s.selector,i),l=a.location.nativeElement,c=a.injector.get(ox,null),u=c&&a.injector.get(C8);return c&&u&&u.registerApplication(l,c),a.onDestroy(()=>{this.detachView(a.hostView),lx(this.components,a),u&&u.unregisterApplication(l)}),this._loadComponent(a),a}tick(){if(this._runningTick)throw new je(101,"");try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;lx(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(dR,[]).concat(this._bootstrapListeners).forEach(s=>s(e))}ngOnDestroy(){this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return n.\u0275fac=function(e){return new(e||n)(ee(Ct),ee(Tn),ee(ca),ee(ex))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function lx(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}let xR=!0,oo=(()=>{class n{}return n.__NG_ELEMENT_ID__=F8,n})();function F8(n){return function P8(n,t,e){if(kp(n)&&!e){const r=Ts(n.index,t);return new Ud(r,r)}return 47&n.type?new Ud(t[16],t):null}(or(),ye(),16==(16&n))}class ER{constructor(){}supports(t){return Rd(t)}create(t){return new U8(t)}}const z8=(n,t)=>t;class U8{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||z8}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,r=this._removalsHead,s=0,i=null;for(;e||r;){const o=!r||e&&e.currentIndex<TR(r,s,i)?e:r,a=TR(o,s,i),l=o.currentIndex;if(o===r)s--,r=r._nextRemoved;else if(e=e._next,null==o.previousIndex)s++;else{i||(i=[]);const c=a-s,u=l-s;if(c!=u){for(let h=0;h<c;h++){const f=h<i.length?i[h]:i[h]=0,p=f+h;u<=p&&p<c&&(i[h]=f+1)}i[o.previousIndex]=u-c}}a!==l&&t(o,a,l)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!Rd(t))throw new je(900,"");return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let s,i,o,e=this._itHead,r=!1;if(Array.isArray(t)){this.length=t.length;for(let a=0;a<this.length;a++)i=t[a],o=this._trackByFn(a,i),null!==e&&Object.is(e.trackById,o)?(r&&(e=this._verifyReinsertion(e,i,o,a)),Object.is(e.item,i)||this._addIdentityChange(e,i)):(e=this._mismatch(e,i,o,a),r=!0),e=e._next}else s=0,function KW(n,t){if(Array.isArray(n))for(let e=0;e<n.length;e++)t(n[e]);else{const e=n[Ac()]();let r;for(;!(r=e.next()).done;)t(r.value)}}(t,a=>{o=this._trackByFn(s,a),null!==e&&Object.is(e.trackById,o)?(r&&(e=this._verifyReinsertion(e,a,o,s)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,o,s),r=!0),e=e._next,s++}),this.length=s;return this._truncate(e),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,r,s){let i;return null===t?i=this._itTail:(i=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,i,s)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,i,s)):t=this._addAfter(new H8(e,r),i,s),t}_verifyReinsertion(t,e,r,s){let i=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==i?t=this._reinsertAfter(i,t._prev,s):t.currentIndex!=s&&(t.currentIndex=s,this._addToMoves(t,s)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const s=t._prevRemoved,i=t._nextRemoved;return null===s?this._removalsHead=i:s._nextRemoved=i,null===i?this._removalsTail=s:i._prevRemoved=s,this._insertAfter(t,e,r),this._addToMoves(t,r),t}_moveAfter(t,e,r){return this._unlink(t),this._insertAfter(t,e,r),this._addToMoves(t,r),t}_addAfter(t,e,r){return this._insertAfter(t,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,r){const s=null===e?this._itHead:e._next;return t._next=s,t._prev=e,null===s?this._itTail=t:s._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new IR),this._linkedRecords.put(t),t.currentIndex=r,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,r=t._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new IR),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class H8{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class j8{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,t))return r;return null}remove(t){const e=t._prevDup,r=t._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class IR{constructor(){this.map=new Map}put(t){const e=t.trackById;let r=this.map.get(e);r||(r=new j8,this.map.set(e,r)),r.add(t)}get(t,e){const s=this.map.get(t);return s?s.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function TR(n,t,e){const r=n.previousIndex;if(null===r)return r;let s=0;return e&&r<e.length&&(s=e[r]),r+t+s}class kR{constructor(){}supports(t){return t instanceof Map||v0(t)}create(){return new W8}}class W8{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||v0(t)))throw new je(900,"")}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(r,s)=>{if(e&&e.key===s)this._maybeAddToChanges(e,r),this._appendAfter=e,e=e._next;else{const i=this._getOrCreateRecordForKey(s,r);e=this._insertBeforeOrAppend(e,i)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let r=e;null!==r;r=r._nextRemoved)r===this._mapHead&&(this._mapHead=null),this._records.delete(r.key),r._nextRemoved=r._next,r.previousValue=r.currentValue,r.currentValue=null,r._prev=null,r._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const r=t._prev;return e._next=t,e._prev=r,t._prev=e,r&&(r._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const s=this._records.get(t);this._maybeAddToChanges(s,e);const i=s._prev,o=s._next;return i&&(i._next=o),o&&(o._prev=i),s._next=null,s._prev=null,s}const r=new G8(t);return this._records.set(t,r),r.currentValue=e,this._addToAdditions(r),r}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(r=>e(t[r],r))}}class G8{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function NR(){return new Mm([new ER])}let Mm=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(null!=r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||NR()),deps:[[n,new bc,new Si]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(null!=r)return r;throw new je(901,"")}}return n.\u0275prov=Ve({token:n,providedIn:"root",factory:NR}),n})();function AR(){return new qd([new kR])}let qd=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||AR()),deps:[[n,new bc,new Si]]}}find(e){const r=this.factories.find(i=>i.supports(e));if(r)return r;throw new je(901,"")}}return n.\u0275prov=Ve({token:n,providedIn:"root",factory:AR}),n})();const X8=yR(null,"core",[]);let Y8=(()=>{class n{constructor(e){}}return n.\u0275fac=function(e){return new(e||n)(ee(Nm))},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({}),n})(),Om=null;function ma(){return Om}const _t=new Fe("DocumentToken");let fl=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:function(){return function e5(){return ee(RR)}()},providedIn:"platform"}),n})();const t5=new Fe("Location Initialized");let RR=(()=>{class n extends fl{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return ma().getBaseHref(this._doc)}onPopState(e){const r=ma().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=ma().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,r,s){MR()?this._history.pushState(e,r,s):this.location.hash=s}replaceState(e,r,s){MR()?this._history.replaceState(e,r,s):this.location.hash=s}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return n.\u0275fac=function(e){return new(e||n)(ee(_t))},n.\u0275prov=Ve({token:n,factory:function(){return function n5(){return new RR(ee(_t))}()},providedIn:"platform"}),n})();function MR(){return!!window.history.pushState}function fx(n,t){if(0==n.length)return t;if(0==t.length)return n;let e=0;return n.endsWith("/")&&e++,t.startsWith("/")&&e++,2==e?n+t.substring(1):1==e?n+t:n+"/"+t}function OR(n){const t=n.match(/#|\?|$/),e=t&&t.index||n.length;return n.slice(0,e-("/"===n[e-1]?1:0))+n.slice(e)}function Lo(n){return n&&"?"!==n[0]?"?"+n:n}let Yc=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:function(){return function r5(n){const t=ee(_t).location;return new FR(ee(fl),t&&t.origin||"")}()},providedIn:"root"}),n})();const px=new Fe("appBaseHref");let FR=(()=>{class n extends Yc{constructor(e,r){if(super(),this._platformLocation=e,this._removeListenerFns=[],null==r&&(r=this._platformLocation.getBaseHrefFromDOM()),null==r)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=r}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return fx(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+Lo(this._platformLocation.search),s=this._platformLocation.hash;return s&&e?`${r}${s}`:r}pushState(e,r,s,i){const o=this.prepareExternalUrl(s+Lo(i));this._platformLocation.pushState(e,r,o)}replaceState(e,r,s,i){const o=this.prepareExternalUrl(s+Lo(i));this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var r,s;null===(s=(r=this._platformLocation).historyGo)||void 0===s||s.call(r,e)}}return n.\u0275fac=function(e){return new(e||n)(ee(fl),ee(px,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})(),s5=(()=>{class n extends Yc{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=fx(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,s,i){let o=this.prepareExternalUrl(s+Lo(i));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.pushState(e,r,o)}replaceState(e,r,s,i){let o=this.prepareExternalUrl(s+Lo(i));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var r,s;null===(s=(r=this._platformLocation).historyGo)||void 0===s||s.call(r,e)}}return n.\u0275fac=function(e){return new(e||n)(ee(fl),ee(px,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})(),Kd=(()=>{class n{constructor(e,r){this._subject=new Bt,this._urlChangeListeners=[],this._platformStrategy=e;const s=this._platformStrategy.getBaseHref();this._platformLocation=r,this._baseHref=OR(PR(s)),this._platformStrategy.onPopState(i=>{this._subject.emit({url:this.path(!0),pop:!0,state:i.state,type:i.type})})}path(e=!1){return this.normalize(this._platformStrategy.path(e))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+Lo(r))}normalize(e){return n.stripTrailingSlash(function a5(n,t){return n&&t.startsWith(n)?t.substring(n.length):t}(this._baseHref,PR(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._platformStrategy.prepareExternalUrl(e)}go(e,r="",s=null){this._platformStrategy.pushState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Lo(r)),s)}replaceState(e,r="",s=null){this._platformStrategy.replaceState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Lo(r)),s)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}historyGo(e=0){var r,s;null===(s=(r=this._platformStrategy).historyGo)||void 0===s||s.call(r,e)}onUrlChange(e){this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)}))}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(s=>s(e,r))}subscribe(e,r,s){return this._subject.subscribe({next:e,error:r,complete:s})}}return n.normalizeQueryParams=Lo,n.joinWithSlash=fx,n.stripTrailingSlash=OR,n.\u0275fac=function(e){return new(e||n)(ee(Yc),ee(fl))},n.\u0275prov=Ve({token:n,factory:function(){return function o5(){return new Kd(ee(Yc),ee(fl))}()},providedIn:"root"}),n})();function PR(n){return n.replace(/\/index.html$/,"")}class q5{constructor(t,e,r,s){this.$implicit=t,this.ngForOf=e,this.index=r,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let WR=(()=>{class n{constructor(e,r,s){this._viewContainer=e,this._template=r,this._differs=s,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const r=this._viewContainer;e.forEachOperation((s,i,o)=>{if(null==s.previousIndex)r.createEmbeddedView(this._template,new q5(s.item,this._ngForOf,-1,-1),null===o?void 0:o);else if(null==o)r.remove(null===i?void 0:i);else if(null!==i){const a=r.get(i);r.move(a,o),GR(a,s)}});for(let s=0,i=r.length;s<i;s++){const a=r.get(s).context;a.index=s,a.count=i,a.ngForOf=this._ngForOf}e.forEachIdentityChange(s=>{GR(r.get(s.currentIndex),s)})}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(oe(Ms),oe(ei),oe(Mm))},n.\u0275dir=un({type:n,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}}),n})();function GR(n,t){n.context.$implicit=t.item}let jm=(()=>{class n{constructor(e,r){this._viewContainer=e,this._context=new K5,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){qR("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){qR("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(oe(Ms),oe(ei))},n.\u0275dir=un({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),n})();class K5{constructor(){this.$implicit=null,this.ngIf=null}}function qR(n,t){if(t&&!t.createEmbeddedView)throw new Error(`${n} must be a TemplateRef, but received '${Xt(t)}'.`)}let XR=(()=>{class n{constructor(e,r,s){this._ngEl=e,this._differs=r,this._renderer=s,this._ngStyle=null,this._differ=null}set ngStyle(e){this._ngStyle=e,!this._differ&&e&&(this._differ=this._differs.find(e).create())}ngDoCheck(){if(this._differ){const e=this._differ.diff(this._ngStyle);e&&this._applyChanges(e)}}_setStyle(e,r){const[s,i]=e.split(".");null!=(r=null!=r&&i?`${r}${i}`:r)?this._renderer.setStyle(this._ngEl.nativeElement,s,r):this._renderer.removeStyle(this._ngEl.nativeElement,s)}_applyChanges(e){e.forEachRemovedItem(r=>this._setStyle(r.key,null)),e.forEachAddedItem(r=>this._setStyle(r.key,r.currentValue)),e.forEachChangedItem(r=>this._setStyle(r.key,r.currentValue))}}return n.\u0275fac=function(e){return new(e||n)(oe(Cn),oe(qd),oe(Cm))},n.\u0275dir=un({type:n,selectors:[["","ngStyle",""]],inputs:{ngStyle:"ngStyle"}}),n})(),Wm=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({}),n})();const ZR="browser";let DK=(()=>{class n{}return n.\u0275prov=Ve({token:n,providedIn:"root",factory:()=>new SK(ee(_t),window)}),n})();class SK{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function EK(n,t){const e=n.getElementById(t)||n.getElementsByName(t)[0];if(e)return e;if("function"==typeof n.createTreeWalker&&n.body&&(n.body.createShadowRoot||n.body.attachShadow)){const r=n.createTreeWalker(n.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const i=s.shadowRoot;if(i){const o=i.getElementById(t)||i.querySelector(`[name="${t}"]`);if(o)return o}s=r.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),r=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,i=this.offset();this.window.scrollTo(r-i[0],s-i[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=QR(this.window.history)||QR(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch(t){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(t){return!1}}}function QR(n){return Object.getOwnPropertyDescriptor(n,"scrollRestoration")}class Tx extends class TK extends class J8{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){!function Q8(n){Om||(Om=n)}(new Tx)}onAndCancel(t,e,r){return t.addEventListener(e,r,!1),()=>{t.removeEventListener(e,r,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=function kK(){return Zd=Zd||document.querySelector("base"),Zd?Zd.getAttribute("href"):null}();return null==e?null:function NK(n){Gm=Gm||document.createElement("a"),Gm.setAttribute("href",n);const t=Gm.pathname;return"/"===t.charAt(0)?t:`/${t}`}(e)}resetBaseElement(){Zd=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function j5(n,t){t=encodeURIComponent(t);for(const e of n.split(";")){const r=e.indexOf("="),[s,i]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===t)return decodeURIComponent(i)}return null}(document.cookie,t)}}let Gm,Zd=null;const JR=new Fe("TRANSITION_ID"),RK=[{provide:J0,useFactory:function AK(n,t,e){return()=>{e.get(ex).donePromise.then(()=>{const r=ma(),s=t.querySelectorAll(`style[ng-transition="${n}"]`);for(let i=0;i<s.length;i++)r.remove(s[i])})}},deps:[JR,_t,Tn],multi:!0}];class kx{static init(){!function S8(n){ax=n}(new kx)}addToWindow(t){en.getAngularTestability=(r,s=!0)=>{const i=t.findTestabilityInTree(r,s);if(null==i)throw new Error("Could not find testability for element.");return i},en.getAllAngularTestabilities=()=>t.getAllTestabilities(),en.getAllAngularRootElements=()=>t.getAllRootElements(),en.frameworkStabilizers||(en.frameworkStabilizers=[]),en.frameworkStabilizers.push(r=>{const s=en.getAllAngularTestabilities();let i=s.length,o=!1;const a=function(l){o=o||l,i--,0==i&&r(o)};s.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(t,e,r){if(null==e)return null;const s=t.getTestability(e);return null!=s?s:r?ma().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null}}let MK=(()=>{class n{build(){return new XMLHttpRequest}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();const qm=new Fe("EventManagerPlugins");let Km=(()=>{class n{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>s.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}addGlobalEventListener(e,r,s){return this._findPluginFor(r).addGlobalEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const s=this._plugins;for(let i=0;i<s.length;i++){const o=s[i];if(o.supports(e))return this._eventNameToPlugin.set(e,o),o}throw new Error(`No event manager plugin found for event ${e}`)}}return n.\u0275fac=function(e){return new(e||n)(ee(qm),ee(Ct))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();class eM{constructor(t){this._doc=t}addGlobalEventListener(t,e,r){const s=ma().getGlobalEventTarget(this._doc,t);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,r)}}let tM=(()=>{class n{constructor(){this._stylesSet=new Set}addStyles(e){const r=new Set;e.forEach(s=>{this._stylesSet.has(s)||(this._stylesSet.add(s),r.add(s))}),this.onStylesAdded(r)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})(),Qd=(()=>{class n extends tM{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,r,s){e.forEach(i=>{const o=this._doc.createElement("style");o.textContent=i,s.push(r.appendChild(o))})}addHost(e){const r=[];this._addStylesToHost(this._stylesSet,e,r),this._hostNodes.set(e,r)}removeHost(e){const r=this._hostNodes.get(e);r&&r.forEach(nM),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((r,s)=>{this._addStylesToHost(e,s,r)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(nM))}}return n.\u0275fac=function(e){return new(e||n)(ee(_t))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();function nM(n){ma().remove(n)}const Nx={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},Ax=/%COMP%/g;function Xm(n,t,e){for(let r=0;r<t.length;r++){let s=t[r];Array.isArray(s)?Xm(n,s,e):(s=s.replace(Ax,n),e.push(s))}return e}function iM(n){return t=>{if("__ngUnwrap__"===t)return n;!1===n(t)&&(t.preventDefault(),t.returnValue=!1)}}let Ym=(()=>{class n{constructor(e,r,s){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.rendererByCompId=new Map,this.defaultRenderer=new Rx(e)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;switch(r.encapsulation){case xi.Emulated:{let s=this.rendererByCompId.get(r.id);return s||(s=new VK(this.eventManager,this.sharedStylesHost,r,this.appId),this.rendererByCompId.set(r.id,s)),s.applyToHost(e),s}case 1:case xi.ShadowDom:return new BK(this.eventManager,this.sharedStylesHost,e,r);default:if(!this.rendererByCompId.has(r.id)){const s=Xm(r.id,r.styles,[]);this.sharedStylesHost.addStyles(s),this.rendererByCompId.set(r.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return n.\u0275fac=function(e){return new(e||n)(ee(Km),ee(Qd),ee(Gd))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();class Rx{constructor(t){this.eventManager=t,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(t,e){return e?document.createElementNS(Nx[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){t.appendChild(e)}insertBefore(t,e,r){t&&t.insertBefore(e,r)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let r="string"==typeof t?document.querySelector(t):t;if(!r)throw new Error(`The selector "${t}" did not match any elements`);return e||(r.textContent=""),r}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,r,s){if(s){e=s+":"+e;const i=Nx[s];i?t.setAttributeNS(i,e,r):t.setAttribute(e,r)}else t.setAttribute(e,r)}removeAttribute(t,e,r){if(r){const s=Nx[r];s?t.removeAttributeNS(s,e):t.removeAttribute(`${r}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,r,s){s&(As.DashCase|As.Important)?t.style.setProperty(e,r,s&As.Important?"important":""):t.style[e]=r}removeStyle(t,e,r){r&As.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,r){t[e]=r}setValue(t,e){t.nodeValue=e}listen(t,e,r){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,iM(r)):this.eventManager.addEventListener(t,e,iM(r))}}class VK extends Rx{constructor(t,e,r,s){super(t),this.component=r;const i=Xm(s+"-"+r.id,r.styles,[]);e.addStyles(i),this.contentAttr=function PK(n){return"_ngcontent-%COMP%".replace(Ax,n)}(s+"-"+r.id),this.hostAttr=function $K(n){return"_nghost-%COMP%".replace(Ax,n)}(s+"-"+r.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const r=super.createElement(t,e);return super.setAttribute(r,this.contentAttr,""),r}}class BK extends Rx{constructor(t,e,r,s){super(t),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const i=Xm(s.id,s.styles,[]);for(let o=0;o<i.length;o++){const a=document.createElement("style");a.textContent=i[o],this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,r){return super.insertBefore(this.nodeOrShadowRoot(t),e,r)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let zK=(()=>{class n extends eM{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return n.\u0275fac=function(e){return new(e||n)(ee(_t))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();const aM=["alt","control","meta","shift"],HK={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},lM={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},jK={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey};let WK=(()=>{class n extends eM{constructor(e){super(e)}supports(e){return null!=n.parseEventName(e)}addEventListener(e,r,s){const i=n.parseEventName(r),o=n.eventCallback(i.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>ma().onAndCancel(e,i.domEventName,o))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const i=n._normalizeKey(r.pop());let o="";if(aM.forEach(l=>{const c=r.indexOf(l);c>-1&&(r.splice(c,1),o+=l+".")}),o+=i,0!=r.length||0===i.length)return null;const a={};return a.domEventName=s,a.fullKey=o,a}static getEventFullKey(e){let r="",s=function GK(n){let t=n.key;if(null==t){if(t=n.keyIdentifier,null==t)return"Unidentified";t.startsWith("U+")&&(t=String.fromCharCode(parseInt(t.substring(2),16)),3===n.location&&lM.hasOwnProperty(t)&&(t=lM[t]))}return HK[t]||t}(e);return s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),aM.forEach(i=>{i!=s&&jK[i](e)&&(r+=i+".")}),r+=s,r}static eventCallback(e,r,s){return i=>{n.getEventFullKey(i)===e&&s.runGuarded(()=>r(i))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return n.\u0275fac=function(e){return new(e||n)(ee(_t))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();const YK=yR(X8,"browser",[{provide:nx,useValue:ZR},{provide:uR,useValue:function qK(){Tx.makeCurrent(),kx.init()},multi:!0},{provide:_t,useFactory:function XK(){return function rH(n){Qv=n}(document),document},deps:[]}]),ZK=[{provide:f0,useValue:"root"},{provide:ca,useFactory:function KK(){return new ca},deps:[]},{provide:qm,useClass:zK,multi:!0,deps:[_t,Ct,nx]},{provide:qm,useClass:WK,multi:!0,deps:[_t]},{provide:Ym,useClass:Ym,deps:[Km,Qd,Gd]},{provide:zd,useExisting:Ym},{provide:tM,useExisting:Qd},{provide:Qd,useClass:Qd,deps:[_t]},{provide:ox,useClass:ox,deps:[Ct]},{provide:Km,useClass:Km,deps:[qm,Ct]},{provide:class IK{},useClass:MK,deps:[]}];let cM=(()=>{class n{constructor(e){if(e)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(e){return{ngModule:n,providers:[{provide:Gd,useValue:e.appId},{provide:JR,useExisting:Gd},RK]}}}return n.\u0275fac=function(e){return new(e||n)(ee(n,12))},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({providers:ZK,imports:[Wm,Y8]}),n})();"undefined"!=typeof window&&window;let Ox=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:function(e){let r=null;return r=e?new(e||n):ee(hM),r},providedIn:"root"}),n})(),hM=(()=>{class n extends Ox{constructor(e){super(),this._doc=e}sanitize(e,r){if(null==r)return null;switch(e){case Wt.NONE:return r;case Wt.HTML:return Zi(r,"HTML")?Ns(r):f1(this._doc,String(r)).toString();case Wt.STYLE:return Zi(r,"Style")?Ns(r):r;case Wt.SCRIPT:if(Zi(r,"Script"))return Ns(r);throw new Error("unsafe value used in a script context");case Wt.URL:return s1(r),Zi(r,"URL")?Ns(r):Cd(String(r));case Wt.RESOURCE_URL:if(Zi(r,"ResourceURL"))return Ns(r);throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");default:throw new Error(`Unexpected SecurityContext ${e} (see https://g.co/ng/security#xss)`)}}bypassSecurityTrustHtml(e){return function _4(n){return new f4(n)}(e)}bypassSecurityTrustStyle(e){return function v4(n){return new p4(n)}(e)}bypassSecurityTrustScript(e){return function b4(n){return new m4(n)}(e)}bypassSecurityTrustUrl(e){return function x4(n){return new g4(n)}(e)}bypassSecurityTrustResourceUrl(e){return function w4(n){return new y4(n)}(e)}}return n.\u0275fac=function(e){return new(e||n)(ee(_t))},n.\u0275prov=Ve({token:n,factory:function(e){let r=null;return r=e?new e:function aX(n){return new hM(n.get(_t))}(ee(Tn)),r},providedIn:"root"}),n})();const lX=new Fe("cdk-dir-doc",{providedIn:"root",factory:function cX(){return Kp(_t)}}),uX=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;let Fx,ya=(()=>{class n{constructor(e){if(this.value="ltr",this.change=new Bt,e){const s=e.documentElement?e.documentElement.dir:null;this.value=function dX(n){const t=(null==n?void 0:n.toLowerCase())||"";return"auto"===t&&"undefined"!=typeof navigator&&(null==navigator?void 0:navigator.language)?uX.test(navigator.language)?"rtl":"ltr":"rtl"===t?"rtl":"ltr"}((e.body?e.body.dir:null)||s||"ltr")}}ngOnDestroy(){this.change.complete()}}return n.\u0275fac=function(e){return new(e||n)(ee(lX,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Jd=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({}),n})();try{Fx="undefined"!=typeof Intl&&Intl.v8BreakIterator}catch(n){Fx=!1}let eh,Zm,ml,Px,ys=(()=>{class n{constructor(e){this._platformId=e,this.isBrowser=this._platformId?function CK(n){return n===ZR}(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!Fx)&&"undefined"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return n.\u0275fac=function(e){return new(e||n)(ee(nx))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function pl(n){return function hX(){if(null==eh&&"undefined"!=typeof window)try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>eh=!0}))}finally{eh=eh||!1}return eh}()?n:!!n.capture}function mM(){if(null==ml){if("object"!=typeof document||!document||"function"!=typeof Element||!Element)return ml=!1,ml;if("scrollBehavior"in document.documentElement.style)ml=!0;else{const n=Element.prototype.scrollTo;ml=!!n&&!/\{\s*\[native code\]\s*\}/.test(n.toString())}}return ml}function th(){if("object"!=typeof document||!document)return 0;if(null==Zm){const n=document.createElement("div"),t=n.style;n.dir="rtl",t.width="1px",t.overflow="auto",t.visibility="hidden",t.pointerEvents="none",t.position="absolute";const e=document.createElement("div"),r=e.style;r.width="2px",r.height="1px",n.appendChild(e),document.body.appendChild(n),Zm=0,0===n.scrollLeft&&(n.scrollLeft=1,Zm=0===n.scrollLeft?1:2),n.remove()}return Zm}function $x(n){if(function fX(){if(null==Px){const n="undefined"!=typeof document?document.head:null;Px=!(!n||!n.createShadowRoot&&!n.attachShadow)}return Px}()){const t=n.getRootNode?n.getRootNode():null;if("undefined"!=typeof ShadowRoot&&ShadowRoot&&t instanceof ShadowRoot)return t}return null}function Lx(){let n="undefined"!=typeof document&&document?document.activeElement:null;for(;n&&n.shadowRoot;){const t=n.shadowRoot.activeElement;if(t===n)break;n=t}return n}function Pi(n){return n.composedPath?n.composedPath()[0]:n.target}function Vx(){return"undefined"!=typeof __karma__&&!!__karma__||"undefined"!=typeof jasmine&&!!jasmine||"undefined"!=typeof jest&&!!jest||"undefined"!=typeof Mocha&&!!Mocha}class ri extends Ge{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){const{hasError:t,thrownError:e,_value:r}=this;if(t)throw e;return this._throwIfClosed(),r}next(t){super.next(this._value=t)}}function it(...n){return Ar(n,sd(n))}function yM(n,...t){return t.length?t.some(e=>n[e]):n.altKey||n.shiftKey||n.ctrlKey||n.metaKey}function ur(n,t){return jn((e,r)=>{let s=0;e.subscribe(In(r,i=>n.call(t,i,s++)&&r.next(i)))})}function _M(n){return ur((t,e)=>n<=e)}function Bx(n,t=gn){return n=null!=n?n:vX,jn((e,r)=>{let s,i=!0;e.subscribe(In(r,o=>{const a=t(o);(i||!n(s,a))&&(i=!1,s=a,r.next(o))}))})}function vX(n,t){return n===t}function dr(n){return jn((t,e)=>{Ds(n).subscribe(In(e,()=>e.complete(),Ye)),!e.closed&&t.subscribe(e)})}function Rr(n){return null!=n&&"false"!=`${n}`}function nh(n,t=0){return function bX(n){return!isNaN(parseFloat(n))&&!isNaN(Number(n))}(n)?Number(n):t}function rh(n){return Array.isArray(n)?n:[n]}function Jn(n){return null==n?"":"string"==typeof n?n:`${n}px`}function hr(n){return n instanceof Cn?n.nativeElement:n}let zx=(()=>{class n{constructor(e){this._platform=e}isDisabled(e){return e.hasAttribute("disabled")}isVisible(e){return function DX(n){return!!(n.offsetWidth||n.offsetHeight||"function"==typeof n.getClientRects&&n.getClientRects().length)}(e)&&"visible"===getComputedStyle(e).visibility}isTabbable(e){if(!this._platform.isBrowser)return!1;const r=function CX(n){try{return n.frameElement}catch(t){return null}}(function RX(n){return n.ownerDocument&&n.ownerDocument.defaultView||window}(e));if(r&&(-1===wM(r)||!this.isVisible(r)))return!1;let s=e.nodeName.toLowerCase(),i=wM(e);return e.hasAttribute("contenteditable")?-1!==i:!("iframe"===s||"object"===s||this._platform.WEBKIT&&this._platform.IOS&&!function NX(n){let t=n.nodeName.toLowerCase(),e="input"===t&&n.type;return"text"===e||"password"===e||"select"===t||"textarea"===t}(e))&&("audio"===s?!!e.hasAttribute("controls")&&-1!==i:"video"===s?-1!==i&&(null!==i||this._platform.FIREFOX||e.hasAttribute("controls")):e.tabIndex>=0)}isFocusable(e,r){return function AX(n){return!function EX(n){return function TX(n){return"input"==n.nodeName.toLowerCase()}(n)&&"hidden"==n.type}(n)&&(function SX(n){let t=n.nodeName.toLowerCase();return"input"===t||"select"===t||"button"===t||"textarea"===t}(n)||function IX(n){return function kX(n){return"a"==n.nodeName.toLowerCase()}(n)&&n.hasAttribute("href")}(n)||n.hasAttribute("contenteditable")||xM(n))}(e)&&!this.isDisabled(e)&&((null==r?void 0:r.ignoreVisibility)||this.isVisible(e))}}return n.\u0275fac=function(e){return new(e||n)(ee(ys))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function xM(n){if(!n.hasAttribute("tabindex")||void 0===n.tabIndex)return!1;let t=n.getAttribute("tabindex");return!(!t||isNaN(parseInt(t,10)))}function wM(n){if(!xM(n))return null;const t=parseInt(n.getAttribute("tabindex")||"",10);return isNaN(t)?-1:t}class MX{constructor(t,e,r,s,i=!1){this._element=t,this._checker=e,this._ngZone=r,this._document=s,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,i||this.attachAnchors()}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}destroy(){const t=this._startAnchor,e=this._endAnchor;t&&(t.removeEventListener("focus",this.startAnchorListener),t.remove()),e&&(e.removeEventListener("focus",this.endAnchorListener),e.remove()),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener("focus",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener("focus",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusInitialElement(t)))})}focusFirstTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusFirstTabbableElement(t)))})}focusLastTabbableElementWhenReady(t){return new Promise(e=>{this._executeOnStable(()=>e(this.focusLastTabbableElement(t)))})}_getRegionBoundary(t){const e=this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);return"start"==t?e.length?e[0]:this._getFirstTabbableElement(this._element):e.length?e[e.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(t){const e=this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");if(e){if(!this._checker.isFocusable(e)){const r=this._getFirstTabbableElement(e);return null==r||r.focus(t),!!r}return e.focus(t),!0}return this.focusFirstTabbableElement(t)}focusFirstTabbableElement(t){const e=this._getRegionBoundary("start");return e&&e.focus(t),!!e}focusLastTabbableElement(t){const e=this._getRegionBoundary("end");return e&&e.focus(t),!!e}hasAttached(){return this._hasAttached}_getFirstTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;const e=t.children;for(let r=0;r<e.length;r++){const s=e[r].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(e[r]):null;if(s)return s}return null}_getLastTabbableElement(t){if(this._checker.isFocusable(t)&&this._checker.isTabbable(t))return t;const e=t.children;for(let r=e.length-1;r>=0;r--){const s=e[r].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(e[r]):null;if(s)return s}return null}_createAnchor(){const t=this._document.createElement("div");return this._toggleAnchorTabIndex(this._enabled,t),t.classList.add("cdk-visually-hidden"),t.classList.add("cdk-focus-trap-anchor"),t.setAttribute("aria-hidden","true"),t}_toggleAnchorTabIndex(t,e){t?e.setAttribute("tabindex","0"):e.removeAttribute("tabindex")}toggleAnchors(t){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}_executeOnStable(t){this._ngZone.isStable?t():this._ngZone.onStable.pipe(Br(1)).subscribe(t)}}let CM=(()=>{class n{constructor(e,r,s){this._checker=e,this._ngZone=r,this._document=s}create(e,r=!1){return new MX(e,this._checker,this._ngZone,this._document,r)}}return n.\u0275fac=function(e){return new(e||n)(ee(zx),ee(Ct),ee(_t))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Ux(n){return 0===n.buttons||0===n.offsetX&&0===n.offsetY}function Hx(n){const t=n.touches&&n.touches[0]||n.changedTouches&&n.changedTouches[0];return!(!t||-1!==t.identifier||null!=t.radiusX&&1!==t.radiusX||null!=t.radiusY&&1!==t.radiusY)}const OX=new Fe("cdk-input-modality-detector-options"),FX={ignoreKeys:[18,17,224,91,16]},Qc=pl({passive:!0,capture:!0});let PX=(()=>{class n{constructor(e,r,s,i){this._platform=e,this._mostRecentTarget=null,this._modality=new ri(null),this._lastTouchMs=0,this._onKeydown=o=>{var a,l;(null===(l=null===(a=this._options)||void 0===a?void 0:a.ignoreKeys)||void 0===l?void 0:l.some(c=>c===o.keyCode))||(this._modality.next("keyboard"),this._mostRecentTarget=Pi(o))},this._onMousedown=o=>{Date.now()-this._lastTouchMs<650||(this._modality.next(Ux(o)?"keyboard":"mouse"),this._mostRecentTarget=Pi(o))},this._onTouchstart=o=>{Hx(o)?this._modality.next("keyboard"):(this._lastTouchMs=Date.now(),this._modality.next("touch"),this._mostRecentTarget=Pi(o))},this._options=Object.assign(Object.assign({},FX),i),this.modalityDetected=this._modality.pipe(_M(1)),this.modalityChanged=this.modalityDetected.pipe(Bx()),e.isBrowser&&r.runOutsideAngular(()=>{s.addEventListener("keydown",this._onKeydown,Qc),s.addEventListener("mousedown",this._onMousedown,Qc),s.addEventListener("touchstart",this._onTouchstart,Qc)})}get mostRecentModality(){return this._modality.value}ngOnDestroy(){this._modality.complete(),this._platform.isBrowser&&(document.removeEventListener("keydown",this._onKeydown,Qc),document.removeEventListener("mousedown",this._onMousedown,Qc),document.removeEventListener("touchstart",this._onTouchstart,Qc))}}return n.\u0275fac=function(e){return new(e||n)(ee(ys),ee(Ct),ee(_t),ee(OX,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const $X=new Fe("liveAnnouncerElement",{providedIn:"root",factory:function LX(){return null}}),VX=new Fe("LIVE_ANNOUNCER_DEFAULT_OPTIONS");let SM=(()=>{class n{constructor(e,r,s,i){this._ngZone=r,this._defaultOptions=i,this._document=s,this._liveElement=e||this._createLiveElement()}announce(e,...r){const s=this._defaultOptions;let i,o;return 1===r.length&&"number"==typeof r[0]?o=r[0]:[i,o]=r,this.clear(),clearTimeout(this._previousTimeout),i||(i=s&&s.politeness?s.politeness:"polite"),null==o&&s&&(o=s.duration),this._liveElement.setAttribute("aria-live",i),this._ngZone.runOutsideAngular(()=>(this._currentPromise||(this._currentPromise=new Promise(a=>this._currentResolve=a)),clearTimeout(this._previousTimeout),this._previousTimeout=setTimeout(()=>{this._liveElement.textContent=e,"number"==typeof o&&(this._previousTimeout=setTimeout(()=>this.clear(),o)),this._currentResolve(),this._currentPromise=this._currentResolve=void 0},100),this._currentPromise))}clear(){this._liveElement&&(this._liveElement.textContent="")}ngOnDestroy(){var e,r;clearTimeout(this._previousTimeout),null===(e=this._liveElement)||void 0===e||e.remove(),this._liveElement=null,null===(r=this._currentResolve)||void 0===r||r.call(this),this._currentPromise=this._currentResolve=void 0}_createLiveElement(){const e="cdk-live-announcer-element",r=this._document.getElementsByClassName(e),s=this._document.createElement("div");for(let i=0;i<r.length;i++)r[i].remove();return s.classList.add(e),s.classList.add("cdk-visually-hidden"),s.setAttribute("aria-atomic","true"),s.setAttribute("aria-live","polite"),this._document.body.appendChild(s),s}}return n.\u0275fac=function(e){return new(e||n)(ee($X,8),ee(Ct),ee(_t),ee(VX,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const BX=new Fe("cdk-focus-monitor-default-options"),Qm=pl({passive:!0,capture:!0});let jx=(()=>{class n{constructor(e,r,s,i,o){this._ngZone=e,this._platform=r,this._inputModalityDetector=s,this._origin=null,this._windowFocused=!1,this._originFromTouchInteraction=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=window.setTimeout(()=>this._windowFocused=!1)},this._stopInputModalityDetector=new Ge,this._rootNodeFocusAndBlurListener=a=>{const l=Pi(a),c="focus"===a.type?this._onFocus:this._onBlur;for(let u=l;u;u=u.parentElement)c.call(this,a,u)},this._document=i,this._detectionMode=(null==o?void 0:o.detectionMode)||0}monitor(e,r=!1){const s=hr(e);if(!this._platform.isBrowser||1!==s.nodeType)return it(null);const i=$x(s)||this._getDocument(),o=this._elementInfo.get(s);if(o)return r&&(o.checkChildren=!0),o.subject;const a={checkChildren:r,subject:new Ge,rootNode:i};return this._elementInfo.set(s,a),this._registerGlobalListeners(a),a.subject}stopMonitoring(e){const r=hr(e),s=this._elementInfo.get(r);s&&(s.subject.complete(),this._setClasses(r),this._elementInfo.delete(r),this._removeGlobalListeners(s))}focusVia(e,r,s){const i=hr(e);i===this._getDocument().activeElement?this._getClosestElementsInfo(i).forEach(([a,l])=>this._originChanged(a,r,l)):(this._setOrigin(r),"function"==typeof i.focus&&i.focus(s))}ngOnDestroy(){this._elementInfo.forEach((e,r)=>this.stopMonitoring(r))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_getFocusOrigin(e){return this._origin?this._originFromTouchInteraction?this._shouldBeAttributedToTouch(e)?"touch":"program":this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:"program"}_shouldBeAttributedToTouch(e){return 1===this._detectionMode||!!(null==e?void 0:e.contains(this._inputModalityDetector._mostRecentTarget))}_setClasses(e,r){e.classList.toggle("cdk-focused",!!r),e.classList.toggle("cdk-touch-focused","touch"===r),e.classList.toggle("cdk-keyboard-focused","keyboard"===r),e.classList.toggle("cdk-mouse-focused","mouse"===r),e.classList.toggle("cdk-program-focused","program"===r)}_setOrigin(e,r=!1){this._ngZone.runOutsideAngular(()=>{this._origin=e,this._originFromTouchInteraction="touch"===e&&r,0===this._detectionMode&&(clearTimeout(this._originTimeoutId),this._originTimeoutId=setTimeout(()=>this._origin=null,this._originFromTouchInteraction?650:1))})}_onFocus(e,r){const s=this._elementInfo.get(r),i=Pi(e);!s||!s.checkChildren&&r!==i||this._originChanged(r,this._getFocusOrigin(i),s)}_onBlur(e,r){const s=this._elementInfo.get(r);!s||s.checkChildren&&e.relatedTarget instanceof Node&&r.contains(e.relatedTarget)||(this._setClasses(r),this._emitOrigin(s.subject,null))}_emitOrigin(e,r){this._ngZone.run(()=>e.next(r))}_registerGlobalListeners(e){if(!this._platform.isBrowser)return;const r=e.rootNode,s=this._rootNodeFocusListenerCount.get(r)||0;s||this._ngZone.runOutsideAngular(()=>{r.addEventListener("focus",this._rootNodeFocusAndBlurListener,Qm),r.addEventListener("blur",this._rootNodeFocusAndBlurListener,Qm)}),this._rootNodeFocusListenerCount.set(r,s+1),1==++this._monitoredElementCount&&(this._ngZone.runOutsideAngular(()=>{this._getWindow().addEventListener("focus",this._windowFocusListener)}),this._inputModalityDetector.modalityDetected.pipe(dr(this._stopInputModalityDetector)).subscribe(i=>{this._setOrigin(i,!0)}))}_removeGlobalListeners(e){const r=e.rootNode;if(this._rootNodeFocusListenerCount.has(r)){const s=this._rootNodeFocusListenerCount.get(r);s>1?this._rootNodeFocusListenerCount.set(r,s-1):(r.removeEventListener("focus",this._rootNodeFocusAndBlurListener,Qm),r.removeEventListener("blur",this._rootNodeFocusAndBlurListener,Qm),this._rootNodeFocusListenerCount.delete(r))}--this._monitoredElementCount||(this._getWindow().removeEventListener("focus",this._windowFocusListener),this._stopInputModalityDetector.next(),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._originTimeoutId))}_originChanged(e,r,s){this._setClasses(e,r),this._emitOrigin(s.subject,r),this._lastFocusOrigin=r}_getClosestElementsInfo(e){const r=[];return this._elementInfo.forEach((s,i)=>{(i===e||s.checkChildren&&i.contains(e))&&r.push([i,s])}),r}}return n.\u0275fac=function(e){return new(e||n)(ee(Ct),ee(ys),ee(PX),ee(_t,8),ee(BX,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const EM="cdk-high-contrast-black-on-white",IM="cdk-high-contrast-white-on-black",Wx="cdk-high-contrast-active";let zX=(()=>{class n{constructor(e,r){this._platform=e,this._document=r}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement("div");e.style.backgroundColor="rgb(1,2,3)",e.style.position="absolute",this._document.body.appendChild(e);const r=this._document.defaultView||window,s=r&&r.getComputedStyle?r.getComputedStyle(e):null,i=(s&&s.backgroundColor||"").replace(/ /g,"");switch(e.remove(),i){case"rgb(0,0,0)":return 2;case"rgb(255,255,255)":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const e=this._document.body.classList;e.remove(Wx),e.remove(EM),e.remove(IM),this._hasCheckedHighContrastMode=!0;const r=this.getHighContrastMode();1===r?(e.add(Wx),e.add(EM)):2===r&&(e.add(Wx),e.add(IM))}}}return n.\u0275fac=function(e){return new(e||n)(ee(ys),ee(_t))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class TM{}const Bo="*";function Jm(n,t){return{type:7,name:n,definitions:t,options:{}}}function gl(n,t=null){return{type:4,styles:t,timings:n}}function kM(n,t=null){return{type:3,steps:n,options:t}}function NM(n,t=null){return{type:2,steps:n,options:t}}function Os(n){return{type:6,styles:n,offset:null}}function yl(n,t,e){return{type:0,name:n,styles:t,options:e}}function _l(n,t,e=null){return{type:1,expr:n,animation:t,options:e}}function AM(n=null){return{type:9,options:n}}function RM(n,t,e=null){return{type:11,selector:n,animation:t,options:e}}function MM(n){Promise.resolve(null).then(n)}class sh{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){MM(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class OM{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,r=0,s=0;const i=this.players.length;0==i?MM(()=>this._onFinish()):this.players.forEach(o=>{o.onDone(()=>{++e==i&&this._onFinish()}),o.onDestroy(()=>{++r==i&&this._onDestroy()}),o.onStart(()=>{++s==i&&this._onStart()})}),this.totalTime=this.players.reduce((o,a)=>Math.max(o,a.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(r=>{const s=r.totalTime?Math.min(1,e/r.totalTime):1;r.setPosition(s)})}getPosition(){const t=this.players.reduce((e,r)=>null===e||r.totalTime>e.totalTime?r:e,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}const Mt=!1;function FM(n){return new je(3e3,Mt)}function w7(){return"undefined"!=typeof window&&void 0!==window.document}function qx(){return"undefined"!=typeof process&&"[object process]"==={}.toString.call(process)}function _a(n){switch(n.length){case 0:return new sh;case 1:return n[0];default:return new OM(n)}}function PM(n,t,e,r,s={},i={}){const o=[],a=[];let l=-1,c=null;if(r.forEach(u=>{const d=u.offset,h=d==l,f=h&&c||{};Object.keys(u).forEach(p=>{let m=p,g=u[p];if("offset"!==p)switch(m=t.normalizePropertyName(m,o),g){case"!":g=s[p];break;case Bo:g=i[p];break;default:g=t.normalizeStyleValue(p,m,g,o)}f[m]=g}),h||a.push(f),c=f,l=d}),o.length)throw function d7(n){return new je(3502,Mt)}();return a}function Kx(n,t,e,r){switch(t){case"start":n.onStart(()=>r(e&&Xx(e,"start",n)));break;case"done":n.onDone(()=>r(e&&Xx(e,"done",n)));break;case"destroy":n.onDestroy(()=>r(e&&Xx(e,"destroy",n)))}}function Xx(n,t,e){const r=e.totalTime,i=Yx(n.element,n.triggerName,n.fromState,n.toState,t||n.phaseName,null==r?n.totalTime:r,!!e.disabled),o=n._data;return null!=o&&(i._data=o),i}function Yx(n,t,e,r,s="",i=0,o){return{element:n,triggerName:t,fromState:e,toState:r,phaseName:s,totalTime:i,disabled:!!o}}function Fs(n,t,e){let r;return n instanceof Map?(r=n.get(t),r||n.set(t,r=e)):(r=n[t],r||(r=n[t]=e)),r}function $M(n){const t=n.indexOf(":");return[n.substring(1,t),n.substr(t+1)]}let Zx=(n,t)=>!1,LM=(n,t,e)=>[],VM=null;function Qx(n){const t=n.parentNode||n.host;return t===VM?null:t}(qx()||"undefined"!=typeof Element)&&(w7()?(VM=(()=>document.documentElement)(),Zx=(n,t)=>{for(;t;){if(t===n)return!0;t=Qx(t)}return!1}):Zx=(n,t)=>n.contains(t),LM=(n,t,e)=>{if(e)return Array.from(n.querySelectorAll(t));const r=n.querySelector(t);return r?[r]:[]});let vl=null,BM=!1;function zM(n){vl||(vl=function D7(){return"undefined"!=typeof document?document.body:null}()||{},BM=!!vl.style&&"WebkitAppearance"in vl.style);let t=!0;return vl.style&&!function C7(n){return"ebkit"==n.substring(1,6)}(n)&&(t=n in vl.style,!t&&BM&&(t="Webkit"+n.charAt(0).toUpperCase()+n.substr(1)in vl.style)),t}const UM=Zx,HM=LM;let jM=(()=>{class n{validateStyleProperty(e){return zM(e)}matchesElement(e,r){return!1}containsElement(e,r){return UM(e,r)}getParentElement(e){return Qx(e)}query(e,r,s){return HM(e,r,s)}computeStyle(e,r,s){return s||""}animate(e,r,s,i,o,a=[],l){return new sh(s,i)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})(),Jx=(()=>{class n{}return n.NOOP=new jM,n})();const ew="ng-enter",tg="ng-leave",ng="ng-trigger",rg=".ng-trigger",GM="ng-animating",tw=".ng-animating";function bl(n){if("number"==typeof n)return n;const t=n.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length<2?0:nw(parseFloat(t[1]),t[2])}function nw(n,t){return"s"===t?1e3*n:n}function sg(n,t,e){return n.hasOwnProperty("duration")?n:function I7(n,t,e){let s,i=0,o="";if("string"==typeof n){const a=n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===a)return t.push(FM()),{duration:0,delay:0,easing:""};s=nw(parseFloat(a[1]),a[2]);const l=a[3];null!=l&&(i=nw(parseFloat(l),a[4]));const c=a[5];c&&(o=c)}else s=n;if(!e){let a=!1,l=t.length;s<0&&(t.push(function HX(){return new je(3100,Mt)}()),a=!0),i<0&&(t.push(function jX(){return new je(3101,Mt)}()),a=!0),a&&t.splice(l,0,FM())}return{duration:s,delay:i,easing:o}}(n,t,e)}function Jc(n,t={}){return Object.keys(n).forEach(e=>{t[e]=n[e]}),t}function va(n,t,e={}){if(t)for(let r in n)e[r]=n[r];else Jc(n,e);return e}function KM(n,t,e){return e?t+":"+e+";":""}function XM(n){let t="";for(let e=0;e<n.style.length;e++){const r=n.style.item(e);t+=KM(0,r,n.style.getPropertyValue(r))}for(const e in n.style)n.style.hasOwnProperty(e)&&!e.startsWith("_")&&(t+=KM(0,N7(e),n.style[e]));n.setAttribute("style",t)}function ao(n,t,e){n.style&&(Object.keys(t).forEach(r=>{const s=sw(r);e&&!e.hasOwnProperty(r)&&(e[r]=n.style[s]),n.style[s]=t[r]}),qx()&&XM(n))}function xl(n,t){n.style&&(Object.keys(t).forEach(e=>{const r=sw(e);n.style[r]=""}),qx()&&XM(n))}function ih(n){return Array.isArray(n)?1==n.length?n[0]:NM(n):n}const rw=new RegExp("{{\\s*(.+?)\\s*}}","g");function YM(n){let t=[];if("string"==typeof n){let e;for(;e=rw.exec(n);)t.push(e[1]);rw.lastIndex=0}return t}function ig(n,t,e){const r=n.toString(),s=r.replace(rw,(i,o)=>{let a=t[o];return t.hasOwnProperty(o)||(e.push(function GX(n){return new je(3003,Mt)}()),a=""),a.toString()});return s==r?n:s}function og(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return t}const k7=/-+([a-z0-9])/g;function sw(n){return n.replace(k7,(...t)=>t[1].toUpperCase())}function N7(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function Ps(n,t,e){switch(t.type){case 7:return n.visitTrigger(t,e);case 0:return n.visitState(t,e);case 1:return n.visitTransition(t,e);case 2:return n.visitSequence(t,e);case 3:return n.visitGroup(t,e);case 4:return n.visitAnimate(t,e);case 5:return n.visitKeyframes(t,e);case 6:return n.visitStyle(t,e);case 8:return n.visitReference(t,e);case 9:return n.visitAnimateChild(t,e);case 10:return n.visitAnimateRef(t,e);case 11:return n.visitQuery(t,e);case 12:return n.visitStagger(t,e);default:throw function qX(n){return new je(3004,Mt)}()}}function ZM(n,t){return window.getComputedStyle(n)[t]}function P7(n,t){const e=[];return"string"==typeof n?n.split(/\s*,\s*/).forEach(r=>function $7(n,t,e){if(":"==n[0]){const l=function L7(n,t){switch(n){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,r)=>parseFloat(r)>parseFloat(e);case":decrement":return(e,r)=>parseFloat(r)<parseFloat(e);default:return t.push(function a7(n){return new je(3016,Mt)}()),"* => *"}}(n,e);if("function"==typeof l)return void t.push(l);n=l}const r=n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==r||r.length<4)return e.push(function o7(n){return new je(3015,Mt)}()),t;const s=r[1],i=r[2],o=r[3];t.push(QM(s,o));"<"==i[0]&&!("*"==s&&"*"==o)&&t.push(QM(o,s))}(r,e,t)):e.push(n),e}const ug=new Set(["true","1"]),dg=new Set(["false","0"]);function QM(n,t){const e=ug.has(n)||dg.has(n),r=ug.has(t)||dg.has(t);return(s,i)=>{let o="*"==n||n==s,a="*"==t||t==i;return!o&&e&&"boolean"==typeof s&&(o=s?ug.has(n):dg.has(n)),!a&&r&&"boolean"==typeof i&&(a=i?ug.has(t):dg.has(t)),o&&a}}const V7=new RegExp("s*:selfs*,?","g");function iw(n,t,e,r){return new B7(n).build(t,e,r)}class B7{constructor(t){this._driver=t}build(t,e,r){const s=new H7(e);this._resetContextStyleTimingState(s);const i=Ps(this,ih(t),s);return s.unsupportedCSSPropertiesFound.size&&s.unsupportedCSSPropertiesFound.keys(),i}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles={},t.collectedStyles[""]={},t.currentTime=0}visitTrigger(t,e){let r=e.queryCount=0,s=e.depCount=0;const i=[],o=[];return"@"==t.name.charAt(0)&&e.errors.push(function XX(){return new je(3006,Mt)}()),t.definitions.forEach(a=>{if(this._resetContextStyleTimingState(e),0==a.type){const l=a,c=l.name;c.toString().split(/\s*,\s*/).forEach(u=>{l.name=u,i.push(this.visitState(l,e))}),l.name=c}else if(1==a.type){const l=this.visitTransition(a,e);r+=l.queryCount,s+=l.depCount,o.push(l)}else e.errors.push(function YX(){return new je(3007,Mt)}())}),{type:7,name:t.name,states:i,transitions:o,queryCount:r,depCount:s,options:null}}visitState(t,e){const r=this.visitStyle(t.styles,e),s=t.options&&t.options.params||null;if(r.containsDynamicStyles){const i=new Set,o=s||{};r.styles.forEach(a=>{if(hg(a)){const l=a;Object.keys(l).forEach(c=>{YM(l[c]).forEach(u=>{o.hasOwnProperty(u)||i.add(u)})})}}),i.size&&(og(i.values()),e.errors.push(function ZX(n,t){return new je(3008,Mt)}()))}return{type:0,name:t.name,style:r,options:s?{params:s}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const r=Ps(this,ih(t.animation),e);return{type:1,matchers:P7(t.expr,e.errors),animation:r,queryCount:e.queryCount,depCount:e.depCount,options:wl(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(r=>Ps(this,r,e)),options:wl(t.options)}}visitGroup(t,e){const r=e.currentTime;let s=0;const i=t.steps.map(o=>{e.currentTime=r;const a=Ps(this,o,e);return s=Math.max(s,e.currentTime),a});return e.currentTime=s,{type:3,steps:i,options:wl(t.options)}}visitAnimate(t,e){const r=function W7(n,t){if(n.hasOwnProperty("duration"))return n;if("number"==typeof n)return ow(sg(n,t).duration,0,"");const e=n;if(e.split(/\s+/).some(i=>"{"==i.charAt(0)&&"{"==i.charAt(1))){const i=ow(0,0,"");return i.dynamic=!0,i.strValue=e,i}const s=sg(e,t);return ow(s.duration,s.delay,s.easing)}(t.timings,e.errors);e.currentAnimateTimings=r;let s,i=t.styles?t.styles:Os({});if(5==i.type)s=this.visitKeyframes(i,e);else{let o=t.styles,a=!1;if(!o){a=!0;const c={};r.easing&&(c.easing=r.easing),o=Os(c)}e.currentTime+=r.duration+r.delay;const l=this.visitStyle(o,e);l.isEmptyStep=a,s=l}return e.currentAnimateTimings=null,{type:4,timings:r,style:s,options:null}}visitStyle(t,e){const r=this._makeStyleAst(t,e);return this._validateStyleAst(r,e),r}_makeStyleAst(t,e){const r=[];Array.isArray(t.styles)?t.styles.forEach(o=>{"string"==typeof o?o==Bo?r.push(o):e.errors.push(function QX(n){return new je(3002,Mt)}()):r.push(o)}):r.push(t.styles);let s=!1,i=null;return r.forEach(o=>{if(hg(o)){const a=o,l=a.easing;if(l&&(i=l,delete a.easing),!s)for(let c in a)if(a[c].toString().indexOf("{{")>=0){s=!0;break}}}),{type:6,styles:r,easing:i,offset:t.offset,containsDynamicStyles:s,options:null}}_validateStyleAst(t,e){const r=e.currentAnimateTimings;let s=e.currentTime,i=e.currentTime;r&&i>0&&(i-=r.duration+r.delay),t.styles.forEach(o=>{"string"!=typeof o&&Object.keys(o).forEach(a=>{if(!this._driver.validateStyleProperty(a))return delete o[a],void e.unsupportedCSSPropertiesFound.add(a);const l=e.collectedStyles[e.currentQuerySelector],c=l[a];let u=!0;c&&(i!=s&&i>=c.startTime&&s<=c.endTime&&(e.errors.push(function JX(n,t,e,r,s){return new je(3010,Mt)}()),u=!1),i=c.startTime),u&&(l[a]={startTime:i,endTime:s}),e.options&&function T7(n,t,e){const r=t.params||{},s=YM(n);s.length&&s.forEach(i=>{r.hasOwnProperty(i)||e.push(function WX(n){return new je(3001,Mt)}())})}(o[a],e.options,e.errors)})})}visitKeyframes(t,e){const r={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(function e7(){return new je(3011,Mt)}()),r;let i=0;const o=[];let a=!1,l=!1,c=0;const u=t.steps.map(_=>{const y=this._makeStyleAst(_,e);let v=null!=y.offset?y.offset:function j7(n){if("string"==typeof n)return null;let t=null;if(Array.isArray(n))n.forEach(e=>{if(hg(e)&&e.hasOwnProperty("offset")){const r=e;t=parseFloat(r.offset),delete r.offset}});else if(hg(n)&&n.hasOwnProperty("offset")){const e=n;t=parseFloat(e.offset),delete e.offset}return t}(y.styles),b=0;return null!=v&&(i++,b=y.offset=v),l=l||b<0||b>1,a=a||b<c,c=b,o.push(b),y});l&&e.errors.push(function t7(){return new je(3012,Mt)}()),a&&e.errors.push(function n7(){return new je(3200,Mt)}());const d=t.steps.length;let h=0;i>0&&i<d?e.errors.push(function r7(){return new je(3202,Mt)}()):0==i&&(h=1/(d-1));const f=d-1,p=e.currentTime,m=e.currentAnimateTimings,g=m.duration;return u.forEach((_,y)=>{const v=h>0?y==f?1:h*y:o[y],b=v*g;e.currentTime=p+m.delay+b,m.duration=b,this._validateStyleAst(_,e),_.offset=v,r.styles.push(_)}),r}visitReference(t,e){return{type:8,animation:Ps(this,ih(t.animation),e),options:wl(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:wl(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:wl(t.options)}}visitQuery(t,e){const r=e.currentQuerySelector,s=t.options||{};e.queryCount++,e.currentQuery=t;const[i,o]=function z7(n){const t=!!n.split(/\s*,\s*/).find(e=>":self"==e);return t&&(n=n.replace(V7,"")),n=n.replace(/@\*/g,rg).replace(/@\w+/g,e=>rg+"-"+e.substr(1)).replace(/:animating/g,tw),[n,t]}(t.selector);e.currentQuerySelector=r.length?r+" "+i:i,Fs(e.collectedStyles,e.currentQuerySelector,{});const a=Ps(this,ih(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=r,{type:11,selector:i,limit:s.limit||0,optional:!!s.optional,includeSelf:o,animation:a,originalSelector:t.selector,options:wl(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push(function s7(){return new je(3013,Mt)}());const r="full"===t.timings?{duration:0,delay:0,easing:"full"}:sg(t.timings,e.errors,!0);return{type:12,animation:Ps(this,ih(t.animation),e),timings:r,options:null}}}class H7{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles={},this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function hg(n){return!Array.isArray(n)&&"object"==typeof n}function wl(n){return n?(n=Jc(n)).params&&(n.params=function U7(n){return n?Jc(n):null}(n.params)):n={},n}function ow(n,t,e){return{duration:n,delay:t,easing:e}}function aw(n,t,e,r,s,i,o=null,a=!1){return{type:1,element:n,keyframes:t,preStyleProps:e,postStyleProps:r,duration:s,delay:i,totalTime:s+i,easing:o,subTimeline:a}}class fg{constructor(){this._map=new Map}get(t){return this._map.get(t)||[]}append(t,e){let r=this._map.get(t);r||this._map.set(t,r=[]),r.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const K7=new RegExp(":enter","g"),Y7=new RegExp(":leave","g");function lw(n,t,e,r,s,i={},o={},a,l,c=[]){return(new Z7).buildKeyframes(n,t,e,r,s,i,o,a,l,c)}class Z7{buildKeyframes(t,e,r,s,i,o,a,l,c,u=[]){c=c||new fg;const d=new cw(t,e,c,s,i,u,[]);d.options=l,d.currentTimeline.setStyles([o],null,d.errors,l),Ps(this,r,d);const h=d.timelines.filter(f=>f.containsAnimation());if(Object.keys(a).length){let f;for(let p=h.length-1;p>=0;p--){const m=h[p];if(m.element===e){f=m;break}}f&&!f.allowOnlyTimelineStyles()&&f.setStyles([a],null,d.errors,l)}return h.length?h.map(f=>f.buildKeyframes()):[aw(e,[],[],[],0,0,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const r=e.subInstructions.get(e.element);if(r){const s=e.createSubContext(t.options),i=e.currentTimeline.currentTime,o=this._visitSubInstructions(r,s,s.options);i!=o&&e.transformIntoNewTimeline(o)}e.previousNode=t}visitAnimateRef(t,e){const r=e.createSubContext(t.options);r.transformIntoNewTimeline(),this.visitReference(t.animation,r),e.transformIntoNewTimeline(r.currentTimeline.currentTime),e.previousNode=t}_visitSubInstructions(t,e,r){let i=e.currentTimeline.currentTime;const o=null!=r.duration?bl(r.duration):null,a=null!=r.delay?bl(r.delay):null;return 0!==o&&t.forEach(l=>{const c=e.appendInstructionToTimeline(l,o,a);i=Math.max(i,c.duration+c.delay)}),i}visitReference(t,e){e.updateOptions(t.options,!0),Ps(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const r=e.subContextCount;let s=e;const i=t.options;if(i&&(i.params||i.delay)&&(s=e.createSubContext(i),s.transformIntoNewTimeline(),null!=i.delay)){6==s.previousNode.type&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=pg);const o=bl(i.delay);s.delayNextStep(o)}t.steps.length&&(t.steps.forEach(o=>Ps(this,o,s)),s.currentTimeline.applyStylesToKeyframe(),s.subContextCount>r&&s.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const r=[];let s=e.currentTimeline.currentTime;const i=t.options&&t.options.delay?bl(t.options.delay):0;t.steps.forEach(o=>{const a=e.createSubContext(t.options);i&&a.delayNextStep(i),Ps(this,o,a),s=Math.max(s,a.currentTimeline.currentTime),r.push(a.currentTimeline)}),r.forEach(o=>e.currentTimeline.mergeTimelineCollectedStyles(o)),e.transformIntoNewTimeline(s),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const r=t.strValue;return sg(e.params?ig(r,e.params,e.errors):r,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const r=e.currentAnimateTimings=this._visitTiming(t.timings,e),s=e.currentTimeline;r.delay&&(e.incrementTime(r.delay),s.snapshotCurrentStyles());const i=t.style;5==i.type?this.visitKeyframes(i,e):(e.incrementTime(r.duration),this.visitStyle(i,e),s.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const r=e.currentTimeline,s=e.currentAnimateTimings;!s&&r.getCurrentStyleProperties().length&&r.forwardFrame();const i=s&&s.easing||t.easing;t.isEmptyStep?r.applyEmptyStep(i):r.setStyles(t.styles,i,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const r=e.currentAnimateTimings,s=e.currentTimeline.duration,i=r.duration,a=e.createSubContext().currentTimeline;a.easing=r.easing,t.styles.forEach(l=>{a.forwardTime((l.offset||0)*i),a.setStyles(l.styles,l.easing,e.errors,e.options),a.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(a),e.transformIntoNewTimeline(s+i),e.previousNode=t}visitQuery(t,e){const r=e.currentTimeline.currentTime,s=t.options||{},i=s.delay?bl(s.delay):0;i&&(6===e.previousNode.type||0==r&&e.currentTimeline.getCurrentStyleProperties().length)&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=pg);let o=r;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!s.optional,e.errors);e.currentQueryTotal=a.length;let l=null;a.forEach((c,u)=>{e.currentQueryIndex=u;const d=e.createSubContext(t.options,c);i&&d.delayNextStep(i),c===e.element&&(l=d.currentTimeline),Ps(this,t.animation,d),d.currentTimeline.applyStylesToKeyframe(),o=Math.max(o,d.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(o),l&&(e.currentTimeline.mergeTimelineCollectedStyles(l),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const r=e.parentContext,s=e.currentTimeline,i=t.timings,o=Math.abs(i.duration),a=o*(e.currentQueryTotal-1);let l=o*e.currentQueryIndex;switch(i.duration<0?"reverse":i.easing){case"reverse":l=a-l;break;case"full":l=r.currentStaggerTime}const u=e.currentTimeline;l&&u.delayNextStep(l);const d=u.currentTime;Ps(this,t.animation,e),e.previousNode=t,r.currentStaggerTime=s.currentTime-d+(s.startTime-r.currentTimeline.startTime)}}const pg={};class cw{constructor(t,e,r,s,i,o,a,l){this._driver=t,this.element=e,this.subInstructions=r,this._enterClassName=s,this._leaveClassName=i,this.errors=o,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=pg,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=l||new mg(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const r=t;let s=this.options;null!=r.duration&&(s.duration=bl(r.duration)),null!=r.delay&&(s.delay=bl(r.delay));const i=r.params;if(i){let o=s.params;o||(o=this.options.params={}),Object.keys(i).forEach(a=>{(!e||!o.hasOwnProperty(a))&&(o[a]=ig(i[a],o,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const r=t.params={};Object.keys(e).forEach(s=>{r[s]=e[s]})}}return t}createSubContext(t=null,e,r){const s=e||this.element,i=new cw(this._driver,s,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(s,r||0));return i.previousNode=this.previousNode,i.currentAnimateTimings=this.currentAnimateTimings,i.options=this._copyOptions(),i.updateOptions(t),i.currentQueryIndex=this.currentQueryIndex,i.currentQueryTotal=this.currentQueryTotal,i.parentContext=this,this.subContextCount++,i}transformIntoNewTimeline(t){return this.previousNode=pg,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,r){const s={duration:null!=e?e:t.duration,delay:this.currentTimeline.currentTime+(null!=r?r:0)+t.delay,easing:""},i=new Q7(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,s,t.stretchStartingKeyframe);return this.timelines.push(i),s}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,r,s,i,o){let a=[];if(s&&a.push(this.element),t.length>0){t=(t=t.replace(K7,"."+this._enterClassName)).replace(Y7,"."+this._leaveClassName);let c=this._driver.query(this.element,t,1!=r);0!==r&&(c=r<0?c.slice(c.length+r,c.length):c.slice(0,r)),a.push(...c)}return!i&&0==a.length&&o.push(function i7(n){return new je(3014,Mt)}()),a}}class mg{constructor(t,e,r,s){this._driver=t,this.element=e,this.startTime=r,this._elementTimelineStylesLookup=s,this.duration=0,this._previousKeyframe={},this._currentKeyframe={},this._keyframes=new Map,this._styleSummary={},this._pendingStyles={},this._backFill={},this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._localTimelineStyles=Object.create(this._backFill,{}),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.getCurrentStyleProperties().length>0;default:return!0}}getCurrentStyleProperties(){return Object.keys(this._currentKeyframe)}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1==this._keyframes.size&&Object.keys(this._pendingStyles).length;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new mg(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=Object.create(this._backFill,{}),this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles[t]=e,this._globalTimelineStyles[t]=e,this._styleSummary[t]={time:this.currentTime,value:e}}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&(this._previousKeyframe.easing=t),Object.keys(this._globalTimelineStyles).forEach(e=>{this._backFill[e]=this._globalTimelineStyles[e]||Bo,this._currentKeyframe[e]=Bo}),this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,r,s){e&&(this._previousKeyframe.easing=e);const i=s&&s.params||{},o=function J7(n,t){const e={};let r;return n.forEach(s=>{"*"===s?(r=r||Object.keys(t),r.forEach(i=>{e[i]=Bo})):va(s,!1,e)}),e}(t,this._globalTimelineStyles);Object.keys(o).forEach(a=>{const l=ig(o[a],i,r);this._pendingStyles[a]=l,this._localTimelineStyles.hasOwnProperty(a)||(this._backFill[a]=this._globalTimelineStyles.hasOwnProperty(a)?this._globalTimelineStyles[a]:Bo),this._updateStyle(a,l)})}applyStylesToKeyframe(){const t=this._pendingStyles,e=Object.keys(t);0!=e.length&&(this._pendingStyles={},e.forEach(r=>{this._currentKeyframe[r]=t[r]}),Object.keys(this._localTimelineStyles).forEach(r=>{this._currentKeyframe.hasOwnProperty(r)||(this._currentKeyframe[r]=this._localTimelineStyles[r])}))}snapshotCurrentStyles(){Object.keys(this._localTimelineStyles).forEach(t=>{const e=this._localTimelineStyles[t];this._pendingStyles[t]=e,this._updateStyle(t,e)})}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){Object.keys(t._styleSummary).forEach(e=>{const r=this._styleSummary[e],s=t._styleSummary[e];(!r||s.time>r.time)&&this._updateStyle(e,s.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,r=1===this._keyframes.size&&0===this.duration;let s=[];this._keyframes.forEach((a,l)=>{const c=va(a,!0);Object.keys(c).forEach(u=>{const d=c[u];"!"==d?t.add(u):d==Bo&&e.add(u)}),r||(c.offset=l/this.duration),s.push(c)});const i=t.size?og(t.values()):[],o=e.size?og(e.values()):[];if(r){const a=s[0],l=Jc(a);a.offset=0,l.offset=1,s=[a,l]}return aw(this.element,s,i,o,this.duration,this.startTime,this.easing,!1)}}class Q7 extends mg{constructor(t,e,r,s,i,o,a=!1){super(t,e,o.delay),this.keyframes=r,this.preStyleProps=s,this.postStyleProps=i,this._stretchStartingKeyframe=a,this.timings={duration:o.duration,delay:o.delay,easing:o.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:r,easing:s}=this.timings;if(this._stretchStartingKeyframe&&e){const i=[],o=r+e,a=e/o,l=va(t[0],!1);l.offset=0,i.push(l);const c=va(t[0],!1);c.offset=tO(a),i.push(c);const u=t.length-1;for(let d=1;d<=u;d++){let h=va(t[d],!1);h.offset=tO((e+h.offset*r)/o),i.push(h)}r=o,e=0,s="",t=i}return aw(this.element,t,this.preStyleProps,this.postStyleProps,r,e,s,!0)}}function tO(n,t=3){const e=Math.pow(10,t-1);return Math.round(n*e)/e}class uw{}class eY extends uw{normalizePropertyName(t,e){return sw(t)}normalizeStyleValue(t,e,r,s){let i="";const o=r.toString().trim();if(tY[e]&&0!==r&&"0"!==r)if("number"==typeof r)i="px";else{const a=r.match(/^[+-]?[\d\.]+([a-z]*)$/);a&&0==a[1].length&&s.push(function KX(n,t){return new je(3005,Mt)}())}return o+i}}const tY=(()=>function nY(n){const t={};return n.forEach(e=>t[e]=!0),t}("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();function nO(n,t,e,r,s,i,o,a,l,c,u,d,h){return{type:0,element:n,triggerName:t,isRemovalTransition:s,fromState:e,fromStyles:i,toState:r,toStyles:o,timelines:a,queriedElements:l,preStyleProps:c,postStyleProps:u,totalTime:d,errors:h}}const dw={};class rO{constructor(t,e,r){this._triggerName=t,this.ast=e,this._stateStyles=r}match(t,e,r,s){return function rY(n,t,e,r,s){return n.some(i=>i(t,e,r,s))}(this.ast.matchers,t,e,r,s)}buildStyles(t,e,r){const s=this._stateStyles["*"],i=this._stateStyles[t],o=s?s.buildStyles(e,r):{};return i?i.buildStyles(e,r):o}build(t,e,r,s,i,o,a,l,c,u){const d=[],h=this.ast.options&&this.ast.options.params||dw,p=this.buildStyles(r,a&&a.params||dw,d),m=l&&l.params||dw,g=this.buildStyles(s,m,d),_=new Set,y=new Map,v=new Map,b="void"===s,w={params:Object.assign(Object.assign({},h),m)},C=u?[]:lw(t,e,this.ast.animation,i,o,p,g,w,c,d);let E=0;if(C.forEach(M=>{E=Math.max(M.duration+M.delay,E)}),d.length)return nO(e,this._triggerName,r,s,b,p,g,[],[],y,v,E,d);C.forEach(M=>{const O=M.element,K=Fs(y,O,{});M.preStyleProps.forEach(Q=>K[Q]=!0);const X=Fs(v,O,{});M.postStyleProps.forEach(Q=>X[Q]=!0),O!==e&&_.add(O)});const k=og(_.values());return nO(e,this._triggerName,r,s,b,p,g,C,k,y,v,E)}}class sY{constructor(t,e,r){this.styles=t,this.defaultParams=e,this.normalizer=r}buildStyles(t,e){const r={},s=Jc(this.defaultParams);return Object.keys(t).forEach(i=>{const o=t[i];null!=o&&(s[i]=o)}),this.styles.styles.forEach(i=>{if("string"!=typeof i){const o=i;Object.keys(o).forEach(a=>{let l=o[a];l.length>1&&(l=ig(l,s,e));const c=this.normalizer.normalizePropertyName(a,e);l=this.normalizer.normalizeStyleValue(a,c,l,e),r[c]=l})}}),r}}class oY{constructor(t,e,r){this.name=t,this.ast=e,this._normalizer=r,this.transitionFactories=[],this.states={},e.states.forEach(s=>{this.states[s.name]=new sY(s.style,s.options&&s.options.params||{},r)}),sO(this.states,"true","1"),sO(this.states,"false","0"),e.transitions.forEach(s=>{this.transitionFactories.push(new rO(t,s,this.states))}),this.fallbackTransition=function aY(n,t,e){return new rO(n,{type:1,animation:{type:2,steps:[],options:null},matchers:[(o,a)=>!0],options:null,queryCount:0,depCount:0},t)}(t,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,r,s){return this.transitionFactories.find(o=>o.match(t,e,r,s))||null}matchStyles(t,e,r){return this.fallbackTransition.buildStyles(t,e,r)}}function sO(n,t,e){n.hasOwnProperty(t)?n.hasOwnProperty(e)||(n[e]=n[t]):n.hasOwnProperty(e)&&(n[t]=n[e])}const lY=new fg;class cY{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._animations={},this._playersById={},this.players=[]}register(t,e){const r=[],i=iw(this._driver,e,r,[]);if(r.length)throw function h7(n){return new je(3503,Mt)}();this._animations[t]=i}_buildPlayer(t,e,r){const s=t.element,i=PM(0,this._normalizer,0,t.keyframes,e,r);return this._driver.animate(s,i,t.duration,t.delay,t.easing,[],!0)}create(t,e,r={}){const s=[],i=this._animations[t];let o;const a=new Map;if(i?(o=lw(this._driver,e,i,ew,tg,{},{},r,lY,s),o.forEach(u=>{const d=Fs(a,u.element,{});u.postStyleProps.forEach(h=>d[h]=null)})):(s.push(function f7(){return new je(3300,Mt)}()),o=[]),s.length)throw function p7(n){return new je(3504,Mt)}();a.forEach((u,d)=>{Object.keys(u).forEach(h=>{u[h]=this._driver.computeStyle(d,h,Bo)})});const c=_a(o.map(u=>{const d=a.get(u.element);return this._buildPlayer(u,{},d)}));return this._playersById[t]=c,c.onDestroy(()=>this.destroy(t)),this.players.push(c),c}destroy(t){const e=this._getPlayer(t);e.destroy(),delete this._playersById[t];const r=this.players.indexOf(e);r>=0&&this.players.splice(r,1)}_getPlayer(t){const e=this._playersById[t];if(!e)throw function m7(n){return new je(3301,Mt)}();return e}listen(t,e,r,s){const i=Yx(e,"","","");return Kx(this._getPlayer(t),r,i,s),()=>{}}command(t,e,r,s){if("register"==r)return void this.register(t,s[0]);if("create"==r)return void this.create(t,e,s[0]||{});const i=this._getPlayer(t);switch(r){case"play":i.play();break;case"pause":i.pause();break;case"reset":i.reset();break;case"restart":i.restart();break;case"finish":i.finish();break;case"init":i.init();break;case"setPosition":i.setPosition(parseFloat(s[0]));break;case"destroy":this.destroy(t)}}}const iO="ng-animate-queued",hw="ng-animate-disabled",pY=[],oO={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},mY={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},si="__ng_removed";class fw{constructor(t,e=""){this.namespaceId=e;const r=t&&t.hasOwnProperty("value");if(this.value=function vY(n){return null!=n?n:null}(r?t.value:t),r){const i=Jc(t);delete i.value,this.options=i}else this.options={};this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const r=this.options.params;Object.keys(e).forEach(s=>{null==r[s]&&(r[s]=e[s])})}}}const oh="void",pw=new fw(oh);class gY{constructor(t,e,r){this.id=t,this.hostElement=e,this._engine=r,this.players=[],this._triggers={},this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,ii(e,this._hostClassName)}listen(t,e,r,s){if(!this._triggers.hasOwnProperty(e))throw function g7(n,t){return new je(3302,Mt)}();if(null==r||0==r.length)throw function y7(n){return new je(3303,Mt)}();if(!function bY(n){return"start"==n||"done"==n}(r))throw function _7(n,t){return new je(3400,Mt)}();const i=Fs(this._elementListeners,t,[]),o={name:e,phase:r,callback:s};i.push(o);const a=Fs(this._engine.statesByElement,t,{});return a.hasOwnProperty(e)||(ii(t,ng),ii(t,ng+"-"+e),a[e]=pw),()=>{this._engine.afterFlush(()=>{const l=i.indexOf(o);l>=0&&i.splice(l,1),this._triggers[e]||delete a[e]})}}register(t,e){return!this._triggers[t]&&(this._triggers[t]=e,!0)}_getTrigger(t){const e=this._triggers[t];if(!e)throw function v7(n){return new je(3401,Mt)}();return e}trigger(t,e,r,s=!0){const i=this._getTrigger(e),o=new mw(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(ii(t,ng),ii(t,ng+"-"+e),this._engine.statesByElement.set(t,a={}));let l=a[e];const c=new fw(r,this.id);if(!(r&&r.hasOwnProperty("value"))&&l&&c.absorbOptions(l.options),a[e]=c,l||(l=pw),c.value!==oh&&l.value===c.value){if(!function CY(n,t){const e=Object.keys(n),r=Object.keys(t);if(e.length!=r.length)return!1;for(let s=0;s<e.length;s++){const i=e[s];if(!t.hasOwnProperty(i)||n[i]!==t[i])return!1}return!0}(l.params,c.params)){const m=[],g=i.matchStyles(l.value,l.params,m),_=i.matchStyles(c.value,c.params,m);m.length?this._engine.reportError(m):this._engine.afterFlush(()=>{xl(t,g),ao(t,_)})}return}const h=Fs(this._engine.playersByElement,t,[]);h.forEach(m=>{m.namespaceId==this.id&&m.triggerName==e&&m.queued&&m.destroy()});let f=i.matchTransition(l.value,c.value,t,c.params),p=!1;if(!f){if(!s)return;f=i.fallbackTransition,p=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:f,fromState:l,toState:c,player:o,isFallbackTransition:p}),p||(ii(t,iO),o.onStart(()=>{eu(t,iO)})),o.onDone(()=>{let m=this.players.indexOf(o);m>=0&&this.players.splice(m,1);const g=this._engine.playersByElement.get(t);if(g){let _=g.indexOf(o);_>=0&&g.splice(_,1)}}),this.players.push(o),h.push(o),o}deregister(t){delete this._triggers[t],this._engine.statesByElement.forEach((e,r)=>{delete e[t]}),this._elementListeners.forEach((e,r)=>{this._elementListeners.set(r,e.filter(s=>s.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(r=>r.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const r=this._engine.driver.query(t,rg,!0);r.forEach(s=>{if(s[si])return;const i=this._engine.fetchNamespacesByElement(s);i.size?i.forEach(o=>o.triggerLeaveAnimation(s,e,!1,!0)):this.clearElementCache(s)}),this._engine.afterFlushAnimationsDone(()=>r.forEach(s=>this.clearElementCache(s)))}triggerLeaveAnimation(t,e,r,s){const i=this._engine.statesByElement.get(t),o=new Map;if(i){const a=[];if(Object.keys(i).forEach(l=>{if(o.set(l,i[l].value),this._triggers[l]){const c=this.trigger(t,l,oh,s);c&&a.push(c)}}),a.length)return this._engine.markElementAsRemoved(this.id,t,!0,e,o),r&&_a(a).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),r=this._engine.statesByElement.get(t);if(e&&r){const s=new Set;e.forEach(i=>{const o=i.name;if(s.has(o))return;s.add(o);const l=this._triggers[o].fallbackTransition,c=r[o]||pw,u=new fw(oh),d=new mw(this.id,o,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:o,transition:l,fromState:c,toState:u,player:d,isFallbackTransition:!0})})}}removeNode(t,e){const r=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let s=!1;if(r.totalAnimations){const i=r.players.length?r.playersByQueriedElement.get(t):[];if(i&&i.length)s=!0;else{let o=t;for(;o=o.parentNode;)if(r.statesByElement.get(o)){s=!0;break}}}if(this.prepareLeaveAnimationListeners(t),s)r.markElementAsRemoved(this.id,t,!1,e);else{const i=t[si];(!i||i===oO)&&(r.afterFlush(()=>this.clearElementCache(t)),r.destroyInnerAnimations(t),r._onRemovalComplete(t,e))}}insertNode(t,e){ii(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(r=>{const s=r.player;if(s.destroyed)return;const i=r.element,o=this._elementListeners.get(i);o&&o.forEach(a=>{if(a.name==r.triggerName){const l=Yx(i,r.triggerName,r.fromState.value,r.toState.value);l._data=t,Kx(r.player,a.phase,l,a.callback)}}),s.markedForDestroy?this._engine.afterFlush(()=>{s.destroy()}):e.push(r)}),this._queue=[],e.sort((r,s)=>{const i=r.transition.ast.depCount,o=s.transition.ast.depCount;return 0==i||0==o?i-o:this._engine.driver.containsElement(r.element,s.element)?1:-1})}destroy(t){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(r=>r.element===t)||e,e}}class yY{constructor(t,e,r){this.bodyNode=t,this.driver=e,this._normalizer=r,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(s,i)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(r=>{r.queued&&t.push(r)})}),t}createNamespace(t,e){const r=new gY(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(r,e):(this.newHostElements.set(e,r),this.collectEnterElement(e)),this._namespaceLookup[t]=r}_balanceNamespaceList(t,e){const r=this._namespaceList,s=this.namespacesByHostElement,i=r.length-1;if(i>=0){let o=!1;if(void 0!==this.driver.getParentElement){let a=this.driver.getParentElement(e);for(;a;){const l=s.get(a);if(l){const c=r.indexOf(l);r.splice(c+1,0,t),o=!0;break}a=this.driver.getParentElement(a)}}else for(let a=i;a>=0;a--)if(this.driver.containsElement(r[a].hostElement,e)){r.splice(a+1,0,t),o=!0;break}o||r.unshift(t)}else r.push(t);return s.set(e,t),t}register(t,e){let r=this._namespaceLookup[t];return r||(r=this.createNamespace(t,e)),r}registerTrigger(t,e,r){let s=this._namespaceLookup[t];s&&s.register(e,r)&&this.totalAnimations++}destroy(t,e){if(!t)return;const r=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(r.hostElement),delete this._namespaceLookup[t];const s=this._namespaceList.indexOf(r);s>=0&&this._namespaceList.splice(s,1)}),this.afterFlushAnimationsDone(()=>r.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,r=this.statesByElement.get(t);if(r){const s=Object.keys(r);for(let i=0;i<s.length;i++){const o=r[s[i]].namespaceId;if(o){const a=this._fetchNamespace(o);a&&e.add(a)}}}return e}trigger(t,e,r,s){if(gg(e)){const i=this._fetchNamespace(t);if(i)return i.trigger(e,r,s),!0}return!1}insertNode(t,e,r,s){if(!gg(e))return;const i=e[si];if(i&&i.setForRemoval){i.setForRemoval=!1,i.setForMove=!0;const o=this.collectedLeaveElements.indexOf(e);o>=0&&this.collectedLeaveElements.splice(o,1)}if(t){const o=this._fetchNamespace(t);o&&o.insertNode(e,r)}s&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),ii(t,hw)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),eu(t,hw))}removeNode(t,e,r,s){if(gg(e)){const i=t?this._fetchNamespace(t):null;if(i?i.removeNode(e,s):this.markElementAsRemoved(t,e,!1,s),r){const o=this.namespacesByHostElement.get(e);o&&o.id!==t&&o.removeNode(e,s)}}else this._onRemovalComplete(e,s)}markElementAsRemoved(t,e,r,s,i){this.collectedLeaveElements.push(e),e[si]={namespaceId:t,setForRemoval:s,hasAnimation:r,removedBeforeQueried:!1,previousTriggersValues:i}}listen(t,e,r,s,i){return gg(e)?this._fetchNamespace(t).listen(e,r,s,i):()=>{}}_buildInstruction(t,e,r,s,i){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,r,s,t.fromState.options,t.toState.options,e,i)}destroyInnerAnimations(t){let e=this.driver.query(t,rg,!0);e.forEach(r=>this.destroyActiveAnimationsForElement(r)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,tw,!0),e.forEach(r=>this.finishActiveQueriedAnimationOnElement(r)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(r=>{r.queued?r.markedForDestroy=!0:r.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(r=>r.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return _a(this.players).onDone(()=>t());t()})}processLeaveNode(t){var e;const r=t[si];if(r&&r.setForRemoval){if(t[si]=oO,r.namespaceId){this.destroyInnerAnimations(t);const s=this._fetchNamespace(r.namespaceId);s&&s.clearElementCache(t)}this._onRemovalComplete(t,r.setForRemoval)}(null===(e=t.classList)||void 0===e?void 0:e.contains(hw))&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(s=>{this.markElementAsDisabled(s,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((r,s)=>this._balanceNamespaceList(r,s)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let r=0;r<this.collectedEnterElements.length;r++)ii(this.collectedEnterElements[r],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const r=[];try{e=this._flushAnimations(r,t)}finally{for(let s=0;s<r.length;s++)r[s]()}}else for(let r=0;r<this.collectedLeaveElements.length;r++)this.processLeaveNode(this.collectedLeaveElements[r]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(r=>r()),this._flushFns=[],this._whenQuietFns.length){const r=this._whenQuietFns;this._whenQuietFns=[],e.length?_a(e).onDone(()=>{r.forEach(s=>s())}):r.forEach(s=>s())}}reportError(t){throw function b7(n){return new je(3402,Mt)}()}_flushAnimations(t,e){const r=new fg,s=[],i=new Map,o=[],a=new Map,l=new Map,c=new Map,u=new Set;this.disabledNodes.forEach(V=>{u.add(V);const G=this.driver.query(V,".ng-animate-queued",!0);for(let W=0;W<G.length;W++)u.add(G[W])});const d=this.bodyNode,h=Array.from(this.statesByElement.keys()),f=cO(h,this.collectedEnterElements),p=new Map;let m=0;f.forEach((V,G)=>{const W=ew+m++;p.set(G,W),V.forEach(J=>ii(J,W))});const g=[],_=new Set,y=new Set;for(let V=0;V<this.collectedLeaveElements.length;V++){const G=this.collectedLeaveElements[V],W=G[si];W&&W.setForRemoval&&(g.push(G),_.add(G),W.hasAnimation?this.driver.query(G,".ng-star-inserted",!0).forEach(J=>_.add(J)):y.add(G))}const v=new Map,b=cO(h,Array.from(_));b.forEach((V,G)=>{const W=tg+m++;v.set(G,W),V.forEach(J=>ii(J,W))}),t.push(()=>{f.forEach((V,G)=>{const W=p.get(G);V.forEach(J=>eu(J,W))}),b.forEach((V,G)=>{const W=v.get(G);V.forEach(J=>eu(J,W))}),g.forEach(V=>{this.processLeaveNode(V)})});const w=[],C=[];for(let V=this._namespaceList.length-1;V>=0;V--)this._namespaceList[V].drainQueuedTransitions(e).forEach(W=>{const J=W.player,ue=W.element;if(w.push(J),this.collectedEnterElements.length){const Ae=ue[si];if(Ae&&Ae.setForMove){if(Ae.previousTriggersValues&&Ae.previousTriggersValues.has(W.triggerName)){const qe=Ae.previousTriggersValues.get(W.triggerName),Ke=this.statesByElement.get(W.element);Ke&&Ke[W.triggerName]&&(Ke[W.triggerName].value=qe)}return void J.destroy()}}const me=!d||!this.driver.containsElement(d,ue),De=v.get(ue),be=p.get(ue),Se=this._buildInstruction(W,r,be,De,me);if(Se.errors&&Se.errors.length)return void C.push(Se);if(me)return J.onStart(()=>xl(ue,Se.fromStyles)),J.onDestroy(()=>ao(ue,Se.toStyles)),void s.push(J);if(W.isFallbackTransition)return J.onStart(()=>xl(ue,Se.fromStyles)),J.onDestroy(()=>ao(ue,Se.toStyles)),void s.push(J);const Ie=[];Se.timelines.forEach(Ae=>{Ae.stretchStartingKeyframe=!0,this.disabledNodes.has(Ae.element)||Ie.push(Ae)}),Se.timelines=Ie,r.append(ue,Se.timelines),o.push({instruction:Se,player:J,element:ue}),Se.queriedElements.forEach(Ae=>Fs(a,Ae,[]).push(J)),Se.preStyleProps.forEach((Ae,qe)=>{const Ke=Object.keys(Ae);if(Ke.length){let ot=l.get(qe);ot||l.set(qe,ot=new Set),Ke.forEach(vt=>ot.add(vt))}}),Se.postStyleProps.forEach((Ae,qe)=>{const Ke=Object.keys(Ae);let ot=c.get(qe);ot||c.set(qe,ot=new Set),Ke.forEach(vt=>ot.add(vt))})});if(C.length){const V=[];C.forEach(G=>{V.push(function x7(n,t){return new je(3505,Mt)}())}),w.forEach(G=>G.destroy()),this.reportError(V)}const E=new Map,k=new Map;o.forEach(V=>{const G=V.element;r.has(G)&&(k.set(G,G),this._beforeAnimationBuild(V.player.namespaceId,V.instruction,E))}),s.forEach(V=>{const G=V.element;this._getPreviousPlayers(G,!1,V.namespaceId,V.triggerName,null).forEach(J=>{Fs(E,G,[]).push(J),J.destroy()})});const M=g.filter(V=>dO(V,l,c)),O=new Map;lO(O,this.driver,y,c,Bo).forEach(V=>{dO(V,l,c)&&M.push(V)});const X=new Map;f.forEach((V,G)=>{lO(X,this.driver,new Set(V),l,"!")}),M.forEach(V=>{const G=O.get(V),W=X.get(V);O.set(V,Object.assign(Object.assign({},G),W))});const Q=[],re=[],ne={};o.forEach(V=>{const{element:G,player:W,instruction:J}=V;if(r.has(G)){if(u.has(G))return W.onDestroy(()=>ao(G,J.toStyles)),W.disabled=!0,W.overrideTotalTime(J.totalTime),void s.push(W);let ue=ne;if(k.size>1){let De=G;const be=[];for(;De=De.parentNode;){const Se=k.get(De);if(Se){ue=Se;break}be.push(De)}be.forEach(Se=>k.set(Se,ue))}const me=this._buildAnimation(W.namespaceId,J,E,i,X,O);if(W.setRealPlayer(me),ue===ne)Q.push(W);else{const De=this.playersByElement.get(ue);De&&De.length&&(W.parentPlayer=_a(De)),s.push(W)}}else xl(G,J.fromStyles),W.onDestroy(()=>ao(G,J.toStyles)),re.push(W),u.has(G)&&s.push(W)}),re.forEach(V=>{const G=i.get(V.element);if(G&&G.length){const W=_a(G);V.setRealPlayer(W)}}),s.forEach(V=>{V.parentPlayer?V.syncPlayerEvents(V.parentPlayer):V.destroy()});for(let V=0;V<g.length;V++){const G=g[V],W=G[si];if(eu(G,tg),W&&W.hasAnimation)continue;let J=[];if(a.size){let me=a.get(G);me&&me.length&&J.push(...me);let De=this.driver.query(G,tw,!0);for(let be=0;be<De.length;be++){let Se=a.get(De[be]);Se&&Se.length&&J.push(...Se)}}const ue=J.filter(me=>!me.destroyed);ue.length?xY(this,G,ue):this.processLeaveNode(G)}return g.length=0,Q.forEach(V=>{this.players.push(V),V.onDone(()=>{V.destroy();const G=this.players.indexOf(V);this.players.splice(G,1)}),V.play()}),Q}elementContainsData(t,e){let r=!1;const s=e[si];return s&&s.setForRemoval&&(r=!0),this.playersByElement.has(e)&&(r=!0),this.playersByQueriedElement.has(e)&&(r=!0),this.statesByElement.has(e)&&(r=!0),this._fetchNamespace(t).elementContainsData(e)||r}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,r,s,i){let o=[];if(e){const a=this.playersByQueriedElement.get(t);a&&(o=a)}else{const a=this.playersByElement.get(t);if(a){const l=!i||i==oh;a.forEach(c=>{c.queued||!l&&c.triggerName!=s||o.push(c)})}}return(r||s)&&(o=o.filter(a=>!(r&&r!=a.namespaceId||s&&s!=a.triggerName))),o}_beforeAnimationBuild(t,e,r){const i=e.element,o=e.isRemovalTransition?void 0:t,a=e.isRemovalTransition?void 0:e.triggerName;for(const l of e.timelines){const c=l.element,u=c!==i,d=Fs(r,c,[]);this._getPreviousPlayers(c,u,o,a,e.toState).forEach(f=>{const p=f.getRealPlayer();p.beforeDestroy&&p.beforeDestroy(),f.destroy(),d.push(f)})}xl(i,e.fromStyles)}_buildAnimation(t,e,r,s,i,o){const a=e.triggerName,l=e.element,c=[],u=new Set,d=new Set,h=e.timelines.map(p=>{const m=p.element;u.add(m);const g=m[si];if(g&&g.removedBeforeQueried)return new sh(p.duration,p.delay);const _=m!==l,y=function wY(n){const t=[];return uO(n,t),t}((r.get(m)||pY).map(E=>E.getRealPlayer())).filter(E=>!!E.element&&E.element===m),v=i.get(m),b=o.get(m),w=PM(0,this._normalizer,0,p.keyframes,v,b),C=this._buildPlayer(p,w,y);if(p.subTimeline&&s&&d.add(m),_){const E=new mw(t,a,m);E.setRealPlayer(C),c.push(E)}return C});c.forEach(p=>{Fs(this.playersByQueriedElement,p.element,[]).push(p),p.onDone(()=>function _Y(n,t,e){let r;if(n instanceof Map){if(r=n.get(t),r){if(r.length){const s=r.indexOf(e);r.splice(s,1)}0==r.length&&n.delete(t)}}else if(r=n[t],r){if(r.length){const s=r.indexOf(e);r.splice(s,1)}0==r.length&&delete n[t]}return r}(this.playersByQueriedElement,p.element,p))}),u.forEach(p=>ii(p,GM));const f=_a(h);return f.onDestroy(()=>{u.forEach(p=>eu(p,GM)),ao(l,e.toStyles)}),d.forEach(p=>{Fs(s,p,[]).push(f)}),f}_buildPlayer(t,e,r){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,r):new sh(t.duration,t.delay)}}class mw{constructor(t,e,r){this.namespaceId=t,this.triggerName=e,this.element=r,this._player=new sh,this._containsRealPlayer=!1,this._queuedCallbacks={},this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,Object.keys(this._queuedCallbacks).forEach(e=>{this._queuedCallbacks[e].forEach(r=>Kx(t,e,void 0,r))}),this._queuedCallbacks={},this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){Fs(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function gg(n){return n&&1===n.nodeType}function aO(n,t){const e=n.style.display;return n.style.display=null!=t?t:"none",e}function lO(n,t,e,r,s){const i=[];e.forEach(l=>i.push(aO(l)));const o=[];r.forEach((l,c)=>{const u={};l.forEach(d=>{const h=u[d]=t.computeStyle(c,d,s);(!h||0==h.length)&&(c[si]=mY,o.push(c))}),n.set(c,u)});let a=0;return e.forEach(l=>aO(l,i[a++])),o}function cO(n,t){const e=new Map;if(n.forEach(a=>e.set(a,[])),0==t.length)return e;const s=new Set(t),i=new Map;function o(a){if(!a)return 1;let l=i.get(a);if(l)return l;const c=a.parentNode;return l=e.has(c)?c:s.has(c)?1:o(c),i.set(a,l),l}return t.forEach(a=>{const l=o(a);1!==l&&e.get(l).push(a)}),e}function ii(n,t){var e;null===(e=n.classList)||void 0===e||e.add(t)}function eu(n,t){var e;null===(e=n.classList)||void 0===e||e.remove(t)}function xY(n,t,e){_a(e).onDone(()=>n.processLeaveNode(t))}function uO(n,t){for(let e=0;e<n.length;e++){const r=n[e];r instanceof OM?uO(r.players,t):t.push(r)}}function dO(n,t,e){const r=e.get(n);if(!r)return!1;let s=t.get(n);return s?r.forEach(i=>s.add(i)):t.set(n,r),e.delete(n),!0}class yg{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._triggerCache={},this.onRemovalComplete=(s,i)=>{},this._transitionEngine=new yY(t,e,r),this._timelineEngine=new cY(t,e,r),this._transitionEngine.onRemovalComplete=(s,i)=>this.onRemovalComplete(s,i)}registerTrigger(t,e,r,s,i){const o=t+"-"+s;let a=this._triggerCache[o];if(!a){const l=[],u=iw(this._driver,i,l,[]);if(l.length)throw function u7(n,t){return new je(3404,Mt)}();a=function iY(n,t,e){return new oY(n,t,e)}(s,u,this._normalizer),this._triggerCache[o]=a}this._transitionEngine.registerTrigger(e,s,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,r,s){this._transitionEngine.insertNode(t,e,r,s)}onRemove(t,e,r,s){this._transitionEngine.removeNode(t,e,s||!1,r)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,r,s){if("@"==r.charAt(0)){const[i,o]=$M(r);this._timelineEngine.command(i,e,o,s)}else this._transitionEngine.trigger(t,e,r,s)}listen(t,e,r,s,i){if("@"==r.charAt(0)){const[o,a]=$M(r);return this._timelineEngine.listen(o,e,a,i)}return this._transitionEngine.listen(t,e,r,s,i)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}let SY=(()=>{class n{constructor(e,r,s){this._element=e,this._startStyles=r,this._endStyles=s,this._state=0;let i=n.initialStylesByElement.get(e);i||n.initialStylesByElement.set(e,i={}),this._initialStyles=i}start(){this._state<1&&(this._startStyles&&ao(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(ao(this._element,this._initialStyles),this._endStyles&&(ao(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(n.initialStylesByElement.delete(this._element),this._startStyles&&(xl(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(xl(this._element,this._endStyles),this._endStyles=null),ao(this._element,this._initialStyles),this._state=3)}}return n.initialStylesByElement=new WeakMap,n})();function gw(n){let t=null;const e=Object.keys(n);for(let r=0;r<e.length;r++){const s=e[r];EY(s)&&(t=t||{},t[s]=n[s])}return t}function EY(n){return"display"===n||"position"===n}class hO{constructor(t,e,r,s){this.element=t,this.keyframes=e,this.options=r,this._specialStyles=s,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this.time=0,this.parentPlayer=null,this.currentSnapshot={},this._duration=r.duration,this._delay=r.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:{},this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_triggerWebAnimation(t,e,r){return t.animate(e,r)}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t={};if(this.hasStarted()){const e=this._finalKeyframe;Object.keys(e).forEach(r=>{"offset"!=r&&(t[r]=this._finished?e[r]:ZM(this.element,r))})}this.currentSnapshot=t}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class IY{validateStyleProperty(t){return zM(t)}matchesElement(t,e){return!1}containsElement(t,e){return UM(t,e)}getParentElement(t){return Qx(t)}query(t,e,r){return HM(t,e,r)}computeStyle(t,e,r){return window.getComputedStyle(t)[e]}animate(t,e,r,s,i,o=[]){const l={duration:r,delay:s,fill:0==s?"both":"forwards"};i&&(l.easing=i);const c={},u=o.filter(h=>h instanceof hO);(function A7(n,t){return 0===n||0===t})(r,s)&&u.forEach(h=>{let f=h.currentSnapshot;Object.keys(f).forEach(p=>c[p]=f[p])}),e=function R7(n,t,e){const r=Object.keys(e);if(r.length&&t.length){let i=t[0],o=[];if(r.forEach(a=>{i.hasOwnProperty(a)||o.push(a),i[a]=e[a]}),o.length)for(var s=1;s<t.length;s++){let a=t[s];o.forEach(function(l){a[l]=ZM(n,l)})}}return t}(t,e=e.map(h=>va(h,!1)),c);const d=function DY(n,t){let e=null,r=null;return Array.isArray(t)&&t.length?(e=gw(t[0]),t.length>1&&(r=gw(t[t.length-1]))):t&&(e=gw(t)),e||r?new SY(n,e,r):null}(t,e);return new hO(t,e,l,d)}}let TY=(()=>{class n extends TM{constructor(e,r){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(r.body,{id:"0",encapsulation:xi.None,styles:[],data:{animation:[]}})}build(e){const r=this._nextAnimationId.toString();this._nextAnimationId++;const s=Array.isArray(e)?NM(e):e;return fO(this._renderer,null,r,"register",[s]),new kY(r,this._renderer)}}return n.\u0275fac=function(e){return new(e||n)(ee(zd),ee(_t))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();class kY extends class UX{}{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new NY(this._id,t,e||{},this._renderer)}}class NY{constructor(t,e,r,s){this.id=t,this.element=e,this._renderer=s,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",r)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return fO(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){var t,e;return null!==(e=null===(t=this._renderer.engine.players[+this.id])||void 0===t?void 0:t.getPosition())&&void 0!==e?e:0}}function fO(n,t,e,r,s){return n.setProperty(t,`@@${e}:${r}`,s)}const pO="@.disabled";let AY=(()=>{class n{constructor(e,r,s){this.delegate=e,this.engine=r,this._zone=s,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),r.onRemovalComplete=(i,o)=>{const a=null==o?void 0:o.parentNode(i);a&&o.removeChild(a,i)}}createRenderer(e,r){const i=this.delegate.createRenderer(e,r);if(!(e&&r&&r.data&&r.data.animation)){let u=this._rendererCache.get(i);return u||(u=new mO("",i,this.engine),this._rendererCache.set(i,u)),u}const o=r.id,a=r.id+"-"+this._currentId;this._currentId++,this.engine.register(a,e);const l=u=>{Array.isArray(u)?u.forEach(l):this.engine.registerTrigger(o,a,e,u.name,u)};return r.data.animation.forEach(l),new RY(this,a,i,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,r,s){e>=0&&e<this._microtaskId?this._zone.run(()=>r(s)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(i=>{const[o,a]=i;o(a)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([r,s]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return n.\u0275fac=function(e){return new(e||n)(ee(zd),ee(yg),ee(Ct))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();class mO{constructor(t,e,r){this.namespaceId=t,this.delegate=e,this.engine=r,this.destroyNode=this.delegate.destroyNode?s=>e.destroyNode(s):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,r,s=!0){this.delegate.insertBefore(t,e,r),this.engine.onInsert(this.namespaceId,e,t,s)}removeChild(t,e,r){this.engine.onRemove(this.namespaceId,e,this.delegate,r)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,r,s){this.delegate.setAttribute(t,e,r,s)}removeAttribute(t,e,r){this.delegate.removeAttribute(t,e,r)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,r,s){this.delegate.setStyle(t,e,r,s)}removeStyle(t,e,r){this.delegate.removeStyle(t,e,r)}setProperty(t,e,r){"@"==e.charAt(0)&&e==pO?this.disableAnimations(t,!!r):this.delegate.setProperty(t,e,r)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,r){return this.delegate.listen(t,e,r)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class RY extends mO{constructor(t,e,r,s){super(e,r,s),this.factory=t,this.namespaceId=e}setProperty(t,e,r){"@"==e.charAt(0)?"."==e.charAt(1)&&e==pO?this.disableAnimations(t,r=void 0===r||!!r):this.engine.process(this.namespaceId,t,e.substr(1),r):this.delegate.setProperty(t,e,r)}listen(t,e,r){if("@"==e.charAt(0)){const s=function MY(n){switch(n){case"body":return document.body;case"document":return document;case"window":return window;default:return n}}(t);let i=e.substr(1),o="";return"@"!=i.charAt(0)&&([i,o]=function OY(n){const t=n.indexOf(".");return[n.substring(0,t),n.substr(t+1)]}(i)),this.engine.listen(this.namespaceId,s,i,o,a=>{this.factory.scheduleListenerCallback(a._data||-1,r,a)})}return this.delegate.listen(t,e,r)}}let FY=(()=>{class n extends yg{constructor(e,r,s){super(e.body,r,s)}ngOnDestroy(){this.flush()}}return n.\u0275fac=function(e){return new(e||n)(ee(_t),ee(Jx),ee(uw))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();const tu=new Fe("AnimationModuleType"),gO=[{provide:TM,useClass:TY},{provide:uw,useFactory:function PY(){return new eY}},{provide:yg,useClass:FY},{provide:zd,useFactory:function $Y(n,t,e){return new AY(n,t,e)},deps:[Ym,yg,Ct]}],yO=[{provide:Jx,useFactory:()=>new IY},{provide:tu,useValue:"BrowserAnimations"},...gO],LY=[{provide:Jx,useClass:jM},{provide:tu,useValue:"NoopAnimations"},...gO];let VY=(()=>{class n{static withConfig(e){return{ngModule:n,providers:e.disableAnimations?LY:yO}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({providers:yO,imports:[cM]}),n})();const zY=new Fe("mat-sanity-checks",{providedIn:"root",factory:function BY(){return!0}});let fr=(()=>{class n{constructor(e,r,s){this._sanityChecks=r,this._document=s,this._hasDoneGlobalChecks=!1,e._applyBodyHighContrastModeCssClasses(),this._hasDoneGlobalChecks||(this._hasDoneGlobalChecks=!0)}_checkIsEnabled(e){return!Vx()&&("boolean"==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[e])}}return n.\u0275fac=function(e){return new(e||n)(ee(zX),ee(zY,8),ee(_t))},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({imports:[[Jd],Jd]}),n})();function UY(n){return class extends n{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=Rr(t)}}}function yw(n,t){return class extends n{constructor(...e){super(...e),this.defaultColor=t,this.color=t}get color(){return this._color}set color(e){const r=e||this.defaultColor;r!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),r&&this._elementRef.nativeElement.classList.add(`mat-${r}`),this._color=r)}}}function HY(n){return class extends n{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=Rr(t)}}}let WY=(()=>{class n{isErrorState(e,r){return!!(e&&e.invalid&&(e.touched||r&&r.submitted))}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class GY{constructor(t,e,r){this._renderer=t,this.element=e,this.config=r,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const vO={enterDuration:225,exitDuration:150},_w=pl({passive:!0}),bO=["mousedown","touchstart"],xO=["mouseup","mouseleave","touchend","touchcancel"];class KY{constructor(t,e,r,s){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,s.isBrowser&&(this._containerElement=hr(r))}fadeInRipple(t,e,r={}){const s=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),i=Object.assign(Object.assign({},vO),r.animation);r.centered&&(t=s.left+s.width/2,e=s.top+s.height/2);const o=r.radius||function YY(n,t,e){const r=Math.max(Math.abs(n-e.left),Math.abs(n-e.right)),s=Math.max(Math.abs(t-e.top),Math.abs(t-e.bottom));return Math.sqrt(r*r+s*s)}(t,e,s),a=t-s.left,l=e-s.top,c=i.enterDuration,u=document.createElement("div");u.classList.add("mat-ripple-element"),u.style.left=a-o+"px",u.style.top=l-o+"px",u.style.height=2*o+"px",u.style.width=2*o+"px",null!=r.color&&(u.style.backgroundColor=r.color),u.style.transitionDuration=`${c}ms`,this._containerElement.appendChild(u),function XY(n){window.getComputedStyle(n).getPropertyValue("opacity")}(u),u.style.transform="scale(1)";const d=new GY(this,u,r);return d.state=0,this._activeRipples.add(d),r.persistent||(this._mostRecentTransientRipple=d),this._runTimeoutOutsideZone(()=>{const h=d===this._mostRecentTransientRipple;d.state=1,!r.persistent&&(!h||!this._isPointerDown)&&d.fadeOut()},c),d}fadeOutRipple(t){const e=this._activeRipples.delete(t);if(t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!e)return;const r=t.element,s=Object.assign(Object.assign({},vO),t.config.animation);r.style.transitionDuration=`${s.exitDuration}ms`,r.style.opacity="0",t.state=2,this._runTimeoutOutsideZone(()=>{t.state=3,r.remove()},s.exitDuration)}fadeOutAll(){this._activeRipples.forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._activeRipples.forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=hr(t);!e||e===this._triggerElement||(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(bO))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(xO),this._pointerUpEventsRegistered=!0)}_onMousedown(t){const e=Ux(t),r=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;!this._target.rippleDisabled&&!e&&!r&&(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!Hx(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let r=0;r<e.length;r++)this.fadeInRipple(e[r].clientX,e[r].clientY,this._target.rippleConfig)}}_onPointerUp(){!this._isPointerDown||(this._isPointerDown=!1,this._activeRipples.forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_runTimeoutOutsideZone(t,e=0){this._ngZone.runOutsideAngular(()=>setTimeout(t,e))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(e=>{this._triggerElement.addEventListener(e,this,_w)})})}_removeTriggerEvents(){this._triggerElement&&(bO.forEach(t=>{this._triggerElement.removeEventListener(t,this,_w)}),this._pointerUpEventsRegistered&&xO.forEach(t=>{this._triggerElement.removeEventListener(t,this,_w)}))}}const ZY=new Fe("mat-ripple-global-options");let wO=(()=>{class n{constructor(e,r,s,i,o){this._elementRef=e,this._animationMode=o,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=i||{},this._rippleRenderer=new KY(this,r,e,s)}get disabled(){return this._disabled}set disabled(e){e&&this.fadeOutAllNonPersistent(),this._disabled=e,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(e){this._trigger=e,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),"NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(e,r=0,s){return"number"==typeof e?this._rippleRenderer.fadeInRipple(e,r,Object.assign(Object.assign({},this.rippleConfig),s)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),e))}}return n.\u0275fac=function(e){return new(e||n)(oe(Cn),oe(Ct),oe(ys),oe(ZY,8),oe(tu,8))},n.\u0275dir=un({type:n,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(e,r){2&e&&ms("mat-ripple-unbounded",r.unbounded)},inputs:{color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],radius:["matRippleRadius","radius"],animation:["matRippleAnimation","animation"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"]},exportAs:["matRipple"]}),n})(),QY=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({imports:[[fr],fr]}),n})();const JY=["*",[["mat-toolbar-row"]]],e9=["*","mat-toolbar-row"],t9=yw(class{constructor(n){this._elementRef=n}});let n9=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=un({type:n,selectors:[["mat-toolbar-row"]],hostAttrs:[1,"mat-toolbar-row"],exportAs:["matToolbarRow"]}),n})(),r9=(()=>{class n extends t9{constructor(e,r,s){super(e),this._platform=r,this._document=s}ngAfterViewInit(){this._platform.isBrowser&&(this._checkToolbarMixedModes(),this._toolbarRows.changes.subscribe(()=>this._checkToolbarMixedModes()))}_checkToolbarMixedModes(){}}return n.\u0275fac=function(e){return new(e||n)(oe(Cn),oe(ys),oe(_t))},n.\u0275cmp=Wn({type:n,selectors:[["mat-toolbar"]],contentQueries:function(e,r,s){if(1&e&&Po(s,n9,5),2&e){let i;rs(i=ss())&&(r._toolbarRows=i)}},hostAttrs:[1,"mat-toolbar"],hostVars:4,hostBindings:function(e,r){2&e&&ms("mat-toolbar-multiple-rows",r._toolbarRows.length>0)("mat-toolbar-single-row",0===r._toolbarRows.length)},inputs:{color:"color"},exportAs:["matToolbar"],features:[ki],ngContentSelectors:e9,decls:2,vars:0,template:function(e,r){1&e&&(fa(JY),Ni(0),Ni(1,1))},styles:[".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"],encapsulation:2,changeDetection:0}),n})(),s9=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({imports:[[fr],fr]}),n})();function lh(n,t){const e=de(n)?n:()=>n,r=s=>s.error(e());return new ct(t?s=>t.schedule(r,0,s):r)}const{isArray:i9}=Array,{getPrototypeOf:o9,prototype:a9,keys:l9}=Object;function CO(n){if(1===n.length){const t=n[0];if(i9(t))return{args:t,keys:null};if(function c9(n){return n&&"object"==typeof n&&o9(n)===a9}(t)){const e=l9(t);return{args:e.map(r=>t[r]),keys:e}}}return{args:n,keys:null}}const{isArray:u9}=Array;function vw(n){return Et(t=>function d9(n,t){return u9(t)?n(...t):n(t)}(n,t))}function DO(n,t){return n.reduce((e,r,s)=>(e[r]=t[s],e),{})}function Mr(n,t,e){const r=de(n)||t||e?{next:n,error:t,complete:e}:n;return r?jn((s,i)=>{var o;null===(o=r.subscribe)||void 0===o||o.call(r);let a=!0;s.subscribe(In(i,l=>{var c;null===(c=r.next)||void 0===c||c.call(r,l),i.next(l)},()=>{var l;a=!1,null===(l=r.complete)||void 0===l||l.call(r),i.complete()},l=>{var c;a=!1,null===(c=r.error)||void 0===c||c.call(r,l),i.error(l)},()=>{var l,c;a&&(null===(l=r.unsubscribe)||void 0===l||l.call(r)),null===(c=r.finalize)||void 0===c||c.call(r)}))}):gn}function zo(n){return jn((t,e)=>{let i,r=null,s=!1;r=t.subscribe(In(e,void 0,void 0,o=>{i=Ds(n(o,zo(n)(t))),r?(r.unsubscribe(),r=null,i.subscribe(e)):s=!0})),s&&(r.unsubscribe(),r=null,i.subscribe(e))})}function SO(n){return jn((t,e)=>{try{t.subscribe(e)}finally{e.add(n)}})}function nu(n,t){return de(t)?ir(n,t,1):ir(n,1)}class f9{}class ba{constructor(t){this.normalizedNames=new Map,this.lazyUpdate=null,t?this.lazyInit="string"==typeof t?()=>{this.headers=new Map,t.split("\n").forEach(e=>{const r=e.indexOf(":");if(r>0){const s=e.slice(0,r),i=s.toLowerCase(),o=e.slice(r+1).trim();this.maybeSetNormalizedName(s,i),this.headers.has(i)?this.headers.get(i).push(o):this.headers.set(i,[o])}})}:()=>{this.headers=new Map,Object.keys(t).forEach(e=>{let r=t[e];const s=e.toLowerCase();"string"==typeof r&&(r=[r]),r.length>0&&(this.headers.set(s,r),this.maybeSetNormalizedName(e,s))})}:this.headers=new Map}has(t){return this.init(),this.headers.has(t.toLowerCase())}get(t){this.init();const e=this.headers.get(t.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(t){return this.init(),this.headers.get(t.toLowerCase())||null}append(t,e){return this.clone({name:t,value:e,op:"a"})}set(t,e){return this.clone({name:t,value:e,op:"s"})}delete(t,e){return this.clone({name:t,value:e,op:"d"})}maybeSetNormalizedName(t,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,t)}init(){this.lazyInit&&(this.lazyInit instanceof ba?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(t=>this.applyUpdate(t)),this.lazyUpdate=null))}copyFrom(t){t.init(),Array.from(t.headers.keys()).forEach(e=>{this.headers.set(e,t.headers.get(e)),this.normalizedNames.set(e,t.normalizedNames.get(e))})}clone(t){const e=new ba;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof ba?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([t]),e}applyUpdate(t){const e=t.name.toLowerCase();switch(t.op){case"a":case"s":let r=t.value;if("string"==typeof r&&(r=[r]),0===r.length)return;this.maybeSetNormalizedName(t.name,e);const s=("a"===t.op?this.headers.get(e):void 0)||[];s.push(...r),this.headers.set(e,s);break;case"d":const i=t.value;if(i){let o=this.headers.get(e);if(!o)return;o=o.filter(a=>-1===i.indexOf(a)),0===o.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,o)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(t){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>t(this.normalizedNames.get(e),this.headers.get(e)))}}class p9{encodeKey(t){return EO(t)}encodeValue(t){return EO(t)}decodeKey(t){return decodeURIComponent(t)}decodeValue(t){return decodeURIComponent(t)}}const g9=/%(\d[a-f0-9])/gi,y9={40:"@","3A":":",24:"$","2C":",","3B":";","2B":"+","3D":"=","3F":"?","2F":"/"};function EO(n){return encodeURIComponent(n).replace(g9,(t,e)=>{var r;return null!==(r=y9[e])&&void 0!==r?r:t})}function IO(n){return`${n}`}class xa{constructor(t={}){if(this.updates=null,this.cloneFrom=null,this.encoder=t.encoder||new p9,t.fromString){if(t.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function m9(n,t){const e=new Map;return n.length>0&&n.replace(/^\?/,"").split("&").forEach(s=>{const i=s.indexOf("="),[o,a]=-1==i?[t.decodeKey(s),""]:[t.decodeKey(s.slice(0,i)),t.decodeValue(s.slice(i+1))],l=e.get(o)||[];l.push(a),e.set(o,l)}),e}(t.fromString,this.encoder)}else t.fromObject?(this.map=new Map,Object.keys(t.fromObject).forEach(e=>{const r=t.fromObject[e];this.map.set(e,Array.isArray(r)?r:[r])})):this.map=null}has(t){return this.init(),this.map.has(t)}get(t){this.init();const e=this.map.get(t);return e?e[0]:null}getAll(t){return this.init(),this.map.get(t)||null}keys(){return this.init(),Array.from(this.map.keys())}append(t,e){return this.clone({param:t,value:e,op:"a"})}appendAll(t){const e=[];return Object.keys(t).forEach(r=>{const s=t[r];Array.isArray(s)?s.forEach(i=>{e.push({param:r,value:i,op:"a"})}):e.push({param:r,value:s,op:"a"})}),this.clone(e)}set(t,e){return this.clone({param:t,value:e,op:"s"})}delete(t,e){return this.clone({param:t,value:e,op:"d"})}toString(){return this.init(),this.keys().map(t=>{const e=this.encoder.encodeKey(t);return this.map.get(t).map(r=>e+"="+this.encoder.encodeValue(r)).join("&")}).filter(t=>""!==t).join("&")}clone(t){const e=new xa({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(t),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(t=>this.map.set(t,this.cloneFrom.map.get(t))),this.updates.forEach(t=>{switch(t.op){case"a":case"s":const e=("a"===t.op?this.map.get(t.param):void 0)||[];e.push(IO(t.value)),this.map.set(t.param,e);break;case"d":if(void 0===t.value){this.map.delete(t.param);break}{let r=this.map.get(t.param)||[];const s=r.indexOf(IO(t.value));-1!==s&&r.splice(s,1),r.length>0?this.map.set(t.param,r):this.map.delete(t.param)}}}),this.cloneFrom=this.updates=null)}}class _9{constructor(){this.map=new Map}set(t,e){return this.map.set(t,e),this}get(t){return this.map.has(t)||this.map.set(t,t.defaultValue()),this.map.get(t)}delete(t){return this.map.delete(t),this}has(t){return this.map.has(t)}keys(){return this.map.keys()}}function TO(n){return"undefined"!=typeof ArrayBuffer&&n instanceof ArrayBuffer}function kO(n){return"undefined"!=typeof Blob&&n instanceof Blob}function NO(n){return"undefined"!=typeof FormData&&n instanceof FormData}class ch{constructor(t,e,r,s){let i;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=t.toUpperCase(),function v9(n){switch(n){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||s?(this.body=void 0!==r?r:null,i=s):i=r,i&&(this.reportProgress=!!i.reportProgress,this.withCredentials=!!i.withCredentials,i.responseType&&(this.responseType=i.responseType),i.headers&&(this.headers=i.headers),i.context&&(this.context=i.context),i.params&&(this.params=i.params)),this.headers||(this.headers=new ba),this.context||(this.context=new _9),this.params){const o=this.params.toString();if(0===o.length)this.urlWithParams=e;else{const a=e.indexOf("?");this.urlWithParams=e+(-1===a?"?":a<e.length-1?"&":"")+o}}else this.params=new xa,this.urlWithParams=e}serializeBody(){return null===this.body?null:TO(this.body)||kO(this.body)||NO(this.body)||function b9(n){return"undefined"!=typeof URLSearchParams&&n instanceof URLSearchParams}(this.body)||"string"==typeof this.body?this.body:this.body instanceof xa?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||NO(this.body)?null:kO(this.body)?this.body.type||null:TO(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof xa?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?"application/json":null}clone(t={}){var e;const r=t.method||this.method,s=t.url||this.url,i=t.responseType||this.responseType,o=void 0!==t.body?t.body:this.body,a=void 0!==t.withCredentials?t.withCredentials:this.withCredentials,l=void 0!==t.reportProgress?t.reportProgress:this.reportProgress;let c=t.headers||this.headers,u=t.params||this.params;const d=null!==(e=t.context)&&void 0!==e?e:this.context;return void 0!==t.setHeaders&&(c=Object.keys(t.setHeaders).reduce((h,f)=>h.set(f,t.setHeaders[f]),c)),t.setParams&&(u=Object.keys(t.setParams).reduce((h,f)=>h.set(f,t.setParams[f]),u)),new ch(r,s,o,{params:u,headers:c,context:d,reportProgress:l,responseType:i,withCredentials:a})}}var Or=(()=>((Or=Or||{})[Or.Sent=0]="Sent",Or[Or.UploadProgress=1]="UploadProgress",Or[Or.ResponseHeader=2]="ResponseHeader",Or[Or.DownloadProgress=3]="DownloadProgress",Or[Or.Response=4]="Response",Or[Or.User=5]="User",Or))();class bw extends class x9{constructor(t,e=200,r="OK"){this.headers=t.headers||new ba,this.status=void 0!==t.status?t.status:e,this.statusText=t.statusText||r,this.url=t.url||null,this.ok=this.status>=200&&this.status<300}}{constructor(t={}){super(t),this.type=Or.Response,this.body=void 0!==t.body?t.body:null}clone(t={}){return new bw({body:void 0!==t.body?t.body:this.body,headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}function xw(n,t){return{body:t,headers:n.headers,context:n.context,observe:n.observe,params:n.params,reportProgress:n.reportProgress,responseType:n.responseType,withCredentials:n.withCredentials}}let RO=(()=>{class n{constructor(e){this.handler=e}request(e,r,s={}){let i;if(e instanceof ch)i=e;else{let l,c;l=s.headers instanceof ba?s.headers:new ba(s.headers),s.params&&(c=s.params instanceof xa?s.params:new xa({fromObject:s.params})),i=new ch(e,r,void 0!==s.body?s.body:null,{headers:l,context:s.context,params:c,reportProgress:s.reportProgress,responseType:s.responseType||"json",withCredentials:s.withCredentials})}const o=it(i).pipe(nu(l=>this.handler.handle(l)));if(e instanceof ch||"events"===s.observe)return o;const a=o.pipe(ur(l=>l instanceof bw));switch(s.observe||"body"){case"body":switch(i.responseType){case"arraybuffer":return a.pipe(Et(l=>{if(null!==l.body&&!(l.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return l.body}));case"blob":return a.pipe(Et(l=>{if(null!==l.body&&!(l.body instanceof Blob))throw new Error("Response is not a Blob.");return l.body}));case"text":return a.pipe(Et(l=>{if(null!==l.body&&"string"!=typeof l.body)throw new Error("Response is not a string.");return l.body}));default:return a.pipe(Et(l=>l.body))}case"response":return a;default:throw new Error(`Unreachable: unhandled observe type ${s.observe}}`)}}delete(e,r={}){return this.request("DELETE",e,r)}get(e,r={}){return this.request("GET",e,r)}head(e,r={}){return this.request("HEAD",e,r)}jsonp(e,r){return this.request("JSONP",e,{params:(new xa).append(r,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(e,r={}){return this.request("OPTIONS",e,r)}patch(e,r,s={}){return this.request("PATCH",e,xw(s,r))}post(e,r,s={}){return this.request("POST",e,xw(s,r))}put(e,r,s={}){return this.request("PUT",e,xw(s,r))}}return n.\u0275fac=function(e){return new(e||n)(ee(f9))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();const C9=["*"];let vg;function uh(n){var t;return(null===(t=function D9(){if(void 0===vg&&(vg=null,"undefined"!=typeof window)){const n=window;void 0!==n.trustedTypes&&(vg=n.trustedTypes.createPolicy("angular#components",{createHTML:t=>t}))}return vg}())||void 0===t?void 0:t.createHTML(n))||n}function MO(n){return Error(`Unable to find icon with the name "${n}"`)}function OO(n){return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${n}".`)}function FO(n){return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${n}".`)}class Cl{constructor(t,e,r){this.url=t,this.svgText=e,this.options=r}}let bg=(()=>{class n{constructor(e,r,s,i){this._httpClient=e,this._sanitizer=r,this._errorHandler=i,this._svgIconConfigs=new Map,this._iconSetConfigs=new Map,this._cachedIconsByUrl=new Map,this._inProgressUrlFetches=new Map,this._fontCssClassesByAlias=new Map,this._resolvers=[],this._defaultFontSetClass="material-icons",this._document=s}addSvgIcon(e,r,s){return this.addSvgIconInNamespace("",e,r,s)}addSvgIconLiteral(e,r,s){return this.addSvgIconLiteralInNamespace("",e,r,s)}addSvgIconInNamespace(e,r,s,i){return this._addSvgIconConfig(e,r,new Cl(s,null,i))}addSvgIconResolver(e){return this._resolvers.push(e),this}addSvgIconLiteralInNamespace(e,r,s,i){const o=this._sanitizer.sanitize(Wt.HTML,s);if(!o)throw FO(s);const a=uh(o);return this._addSvgIconConfig(e,r,new Cl("",a,i))}addSvgIconSet(e,r){return this.addSvgIconSetInNamespace("",e,r)}addSvgIconSetLiteral(e,r){return this.addSvgIconSetLiteralInNamespace("",e,r)}addSvgIconSetInNamespace(e,r,s){return this._addSvgIconSetConfig(e,new Cl(r,null,s))}addSvgIconSetLiteralInNamespace(e,r,s){const i=this._sanitizer.sanitize(Wt.HTML,r);if(!i)throw FO(r);const o=uh(i);return this._addSvgIconSetConfig(e,new Cl("",o,s))}registerFontClassAlias(e,r=e){return this._fontCssClassesByAlias.set(e,r),this}classNameForFontAlias(e){return this._fontCssClassesByAlias.get(e)||e}setDefaultFontSetClass(e){return this._defaultFontSetClass=e,this}getDefaultFontSetClass(){return this._defaultFontSetClass}getSvgIconFromUrl(e){const r=this._sanitizer.sanitize(Wt.RESOURCE_URL,e);if(!r)throw OO(e);const s=this._cachedIconsByUrl.get(r);return s?it(xg(s)):this._loadSvgIconFromConfig(new Cl(e,null)).pipe(Mr(i=>this._cachedIconsByUrl.set(r,i)),Et(i=>xg(i)))}getNamedSvgIcon(e,r=""){const s=PO(r,e);let i=this._svgIconConfigs.get(s);if(i)return this._getSvgFromConfig(i);if(i=this._getIconConfigFromResolvers(r,e),i)return this._svgIconConfigs.set(s,i),this._getSvgFromConfig(i);const o=this._iconSetConfigs.get(r);return o?this._getSvgFromIconSetConfigs(e,o):lh(MO(s))}ngOnDestroy(){this._resolvers=[],this._svgIconConfigs.clear(),this._iconSetConfigs.clear(),this._cachedIconsByUrl.clear()}_getSvgFromConfig(e){return e.svgText?it(xg(this._svgElementFromConfig(e))):this._loadSvgIconFromConfig(e).pipe(Et(r=>xg(r)))}_getSvgFromIconSetConfigs(e,r){const s=this._extractIconWithNameFromAnySet(e,r);return s?it(s):function h9(...n){const t=ZI(n),{args:e,keys:r}=CO(n),s=new ct(i=>{const{length:o}=e;if(!o)return void i.complete();const a=new Array(o);let l=o,c=o;for(let u=0;u<o;u++){let d=!1;Ds(e[u]).subscribe(In(i,h=>{d||(d=!0,c--),a[u]=h},()=>l--,void 0,()=>{(!l||!d)&&(c||i.next(r?DO(r,a):a),i.complete())}))}});return t?s.pipe(vw(t)):s}(r.filter(o=>!o.svgText).map(o=>this._loadSvgIconSetFromConfig(o).pipe(zo(a=>{const c=`Loading icon set URL: ${this._sanitizer.sanitize(Wt.RESOURCE_URL,o.url)} failed: ${a.message}`;return this._errorHandler.handleError(new Error(c)),it(null)})))).pipe(Et(()=>{const o=this._extractIconWithNameFromAnySet(e,r);if(!o)throw MO(e);return o}))}_extractIconWithNameFromAnySet(e,r){for(let s=r.length-1;s>=0;s--){const i=r[s];if(i.svgText&&i.svgText.toString().indexOf(e)>-1){const o=this._svgElementFromConfig(i),a=this._extractSvgIconFromSet(o,e,i.options);if(a)return a}}return null}_loadSvgIconFromConfig(e){return this._fetchIcon(e).pipe(Mr(r=>e.svgText=r),Et(()=>this._svgElementFromConfig(e)))}_loadSvgIconSetFromConfig(e){return e.svgText?it(null):this._fetchIcon(e).pipe(Mr(r=>e.svgText=r))}_extractSvgIconFromSet(e,r,s){const i=e.querySelector(`[id="${r}"]`);if(!i)return null;const o=i.cloneNode(!0);if(o.removeAttribute("id"),"svg"===o.nodeName.toLowerCase())return this._setSvgAttributes(o,s);if("symbol"===o.nodeName.toLowerCase())return this._setSvgAttributes(this._toSvgElement(o),s);const a=this._svgElementFromString(uh("<svg></svg>"));return a.appendChild(o),this._setSvgAttributes(a,s)}_svgElementFromString(e){const r=this._document.createElement("DIV");r.innerHTML=e;const s=r.querySelector("svg");if(!s)throw Error("<svg> tag not found");return s}_toSvgElement(e){const r=this._svgElementFromString(uh("<svg></svg>")),s=e.attributes;for(let i=0;i<s.length;i++){const{name:o,value:a}=s[i];"id"!==o&&r.setAttribute(o,a)}for(let i=0;i<e.childNodes.length;i++)e.childNodes[i].nodeType===this._document.ELEMENT_NODE&&r.appendChild(e.childNodes[i].cloneNode(!0));return r}_setSvgAttributes(e,r){return e.setAttribute("fit",""),e.setAttribute("height","100%"),e.setAttribute("width","100%"),e.setAttribute("preserveAspectRatio","xMidYMid meet"),e.setAttribute("focusable","false"),r&&r.viewBox&&e.setAttribute("viewBox",r.viewBox),e}_fetchIcon(e){var r;const{url:s,options:i}=e,o=null!==(r=null==i?void 0:i.withCredentials)&&void 0!==r&&r;if(!this._httpClient)throw function S9(){return Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.")}();if(null==s)throw Error(`Cannot fetch icon from URL "${s}".`);const a=this._sanitizer.sanitize(Wt.RESOURCE_URL,s);if(!a)throw OO(s);const l=this._inProgressUrlFetches.get(a);if(l)return l;const c=this._httpClient.get(a,{responseType:"text",withCredentials:o}).pipe(Et(u=>uh(u)),SO(()=>this._inProgressUrlFetches.delete(a)),tT());return this._inProgressUrlFetches.set(a,c),c}_addSvgIconConfig(e,r,s){return this._svgIconConfigs.set(PO(e,r),s),this}_addSvgIconSetConfig(e,r){const s=this._iconSetConfigs.get(e);return s?s.push(r):this._iconSetConfigs.set(e,[r]),this}_svgElementFromConfig(e){if(!e.svgElement){const r=this._svgElementFromString(e.svgText);this._setSvgAttributes(r,e.options),e.svgElement=r}return e.svgElement}_getIconConfigFromResolvers(e,r){for(let s=0;s<this._resolvers.length;s++){const i=this._resolvers[s](r,e);if(i)return I9(i)?new Cl(i.url,null,i.options):new Cl(i,null)}}}return n.\u0275fac=function(e){return new(e||n)(ee(RO,8),ee(Ox),ee(_t,8),ee(ca))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function xg(n){return n.cloneNode(!0)}function PO(n,t){return n+":"+t}function I9(n){return!(!n.url||!n.options)}const T9=yw(class{constructor(n){this._elementRef=n}}),k9=new Fe("mat-icon-location",{providedIn:"root",factory:function N9(){const n=Kp(_t),t=n?n.location:null;return{getPathname:()=>t?t.pathname+t.search:""}}}),$O=["clip-path","color-profile","src","cursor","fill","filter","marker","marker-start","marker-mid","marker-end","mask","stroke"],A9=$O.map(n=>`[${n}]`).join(", "),R9=/^url\(['"]?#(.*?)['"]?\)$/;let M9=(()=>{class n extends T9{constructor(e,r,s,i,o){super(e),this._iconRegistry=r,this._location=i,this._errorHandler=o,this._inline=!1,this._currentIconFetch=x.EMPTY,s||e.nativeElement.setAttribute("aria-hidden","true")}get inline(){return this._inline}set inline(e){this._inline=Rr(e)}get svgIcon(){return this._svgIcon}set svgIcon(e){e!==this._svgIcon&&(e?this._updateSvgIcon(e):this._svgIcon&&this._clearSvgElement(),this._svgIcon=e)}get fontSet(){return this._fontSet}set fontSet(e){const r=this._cleanupFontValue(e);r!==this._fontSet&&(this._fontSet=r,this._updateFontIconClasses())}get fontIcon(){return this._fontIcon}set fontIcon(e){const r=this._cleanupFontValue(e);r!==this._fontIcon&&(this._fontIcon=r,this._updateFontIconClasses())}_splitIconName(e){if(!e)return["",""];const r=e.split(":");switch(r.length){case 1:return["",r[0]];case 2:return r;default:throw Error(`Invalid icon name: "${e}"`)}}ngOnInit(){this._updateFontIconClasses()}ngAfterViewChecked(){const e=this._elementsWithExternalReferences;if(e&&e.size){const r=this._location.getPathname();r!==this._previousPath&&(this._previousPath=r,this._prependPathToReferences(r))}}ngOnDestroy(){this._currentIconFetch.unsubscribe(),this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear()}_usingFontIcon(){return!this.svgIcon}_setSvgElement(e){this._clearSvgElement();const r=this._location.getPathname();this._previousPath=r,this._cacheChildrenWithExternalReferences(e),this._prependPathToReferences(r),this._elementRef.nativeElement.appendChild(e)}_clearSvgElement(){const e=this._elementRef.nativeElement;let r=e.childNodes.length;for(this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear();r--;){const s=e.childNodes[r];(1!==s.nodeType||"svg"===s.nodeName.toLowerCase())&&s.remove()}}_updateFontIconClasses(){if(!this._usingFontIcon())return;const e=this._elementRef.nativeElement,r=this.fontSet?this._iconRegistry.classNameForFontAlias(this.fontSet):this._iconRegistry.getDefaultFontSetClass();r!=this._previousFontSetClass&&(this._previousFontSetClass&&e.classList.remove(this._previousFontSetClass),r&&e.classList.add(r),this._previousFontSetClass=r),this.fontIcon!=this._previousFontIconClass&&(this._previousFontIconClass&&e.classList.remove(this._previousFontIconClass),this.fontIcon&&e.classList.add(this.fontIcon),this._previousFontIconClass=this.fontIcon)}_cleanupFontValue(e){return"string"==typeof e?e.trim().split(" ")[0]:e}_prependPathToReferences(e){const r=this._elementsWithExternalReferences;r&&r.forEach((s,i)=>{s.forEach(o=>{i.setAttribute(o.name,`url('${e}#${o.value}')`)})})}_cacheChildrenWithExternalReferences(e){const r=e.querySelectorAll(A9),s=this._elementsWithExternalReferences=this._elementsWithExternalReferences||new Map;for(let i=0;i<r.length;i++)$O.forEach(o=>{const a=r[i],l=a.getAttribute(o),c=l?l.match(R9):null;if(c){let u=s.get(a);u||(u=[],s.set(a,u)),u.push({name:o,value:c[1]})}})}_updateSvgIcon(e){if(this._svgNamespace=null,this._svgName=null,this._currentIconFetch.unsubscribe(),e){const[r,s]=this._splitIconName(e);r&&(this._svgNamespace=r),s&&(this._svgName=s),this._currentIconFetch=this._iconRegistry.getNamedSvgIcon(s,r).pipe(Br(1)).subscribe(i=>this._setSvgElement(i),i=>{this._errorHandler.handleError(new Error(`Error retrieving icon ${r}:${s}! ${i.message}`))})}}}return n.\u0275fac=function(e){return new(e||n)(oe(Cn),oe(bg),pc("aria-hidden"),oe(k9),oe(ca))},n.\u0275cmp=Wn({type:n,selectors:[["mat-icon"]],hostAttrs:["role","img",1,"mat-icon","notranslate"],hostVars:7,hostBindings:function(e,r){2&e&&(no("data-mat-icon-type",r._usingFontIcon()?"font":"svg")("data-mat-icon-name",r._svgName||r.fontIcon)("data-mat-icon-namespace",r._svgNamespace||r.fontSet),ms("mat-icon-inline",r.inline)("mat-icon-no-color","primary"!==r.color&&"accent"!==r.color&&"warn"!==r.color))},inputs:{color:"color",inline:"inline",svgIcon:"svgIcon",fontSet:"fontSet",fontIcon:"fontIcon"},exportAs:["matIcon"],features:[ki],ngContentSelectors:C9,decls:1,vars:0,template:function(e,r){1&e&&(fa(),Ni(0))},styles:[".mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"],encapsulation:2,changeDetection:0}),n})(),O9=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({imports:[[fr],fr]}),n})();function LO(...n){const t=sd(n),e=ZI(n),{args:r,keys:s}=CO(n);if(0===r.length)return Ar([],t);const i=new ct(function F9(n,t,e=gn){return r=>{VO(t,()=>{const{length:s}=n,i=new Array(s);let o=s,a=s;for(let l=0;l<s;l++)VO(t,()=>{const c=Ar(n[l],t);let u=!1;c.subscribe(In(r,d=>{i[l]=d,u||(u=!0,a--),a||r.next(e(i.slice()))},()=>{--o||r.complete()}))},r)},r)}}(r,t,s?o=>DO(s,o):gn));return e?i.pipe(vw(e)):i}function VO(n,t,e){n?So(e,n,t):t()}const wg=xe(n=>function(){n(this),this.name="EmptyError",this.message="no elements in sequence"});function Cg(...n){return function P9(){return rd(1)}()(Ar(n,sd(n)))}function ww(n){return new ct(t=>{Ds(n()).subscribe(t)})}function BO(){return jn((n,t)=>{let e=null;n._refCount++;const r=In(t,void 0,void 0,void 0,()=>{if(!n||n._refCount<=0||0<--n._refCount)return void(e=null);const s=n._connection,i=e;e=null,s&&(!i||s===i)&&s.unsubscribe(),t.unsubscribe()});n.subscribe(r),r.closed||(e=n.connect())})}class $9 extends ct{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,$I(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:t}=this;this._subject=this._connection=null,null==t||t.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new x;const e=this.getSubject();t.add(this.source.subscribe(In(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),t.closed&&(this._connection=null,t=x.EMPTY)}return t}refCount(){return BO()(this)}}function wa(n,t){return jn((e,r)=>{let s=null,i=0,o=!1;const a=()=>o&&!s&&r.complete();e.subscribe(In(r,l=>{null==s||s.unsubscribe();let c=0;const u=i++;Ds(n(l,u)).subscribe(s=In(r,d=>r.next(t?t(l,d,u,c++):d),()=>{s=null,a()}))},()=>{o=!0,a()}))})}function Uo(...n){const t=sd(n);return jn((e,r)=>{(t?Cg(n,e,t):Cg(n,e)).subscribe(r)})}function L9(n,t,e,r,s){return(i,o)=>{let a=e,l=t,c=0;i.subscribe(In(o,u=>{const d=c++;l=a?n(l,u,d):(a=!0,u),r&&o.next(l)},s&&(()=>{a&&o.next(l),o.complete()})))}}function zO(n,t){return jn(L9(n,t,arguments.length>=2,!0))}function Cw(n){return n<=0?()=>Eo:jn((t,e)=>{let r=[];t.subscribe(In(e,s=>{r.push(s),n<r.length&&r.shift()},()=>{for(const s of r)e.next(s);e.complete()},void 0,()=>{r=null}))})}function UO(n=V9){return jn((t,e)=>{let r=!1;t.subscribe(In(e,s=>{r=!0,e.next(s)},()=>r?e.complete():e.error(n())))})}function V9(){return new wg}function HO(n){return jn((t,e)=>{let r=!1;t.subscribe(In(e,s=>{r=!0,e.next(s)},()=>{r||e.next(n),e.complete()}))})}function ru(n,t){const e=arguments.length>=2;return r=>r.pipe(n?ur((s,i)=>n(s,i,r)):gn,Br(1),e?HO(t):UO(()=>new wg))}class Ho{constructor(t,e){this.id=t,this.url=e}}class Dw extends Ho{constructor(t,e,r="imperative",s=null){super(t,e),this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class dh extends Ho{constructor(t,e,r){super(t,e),this.urlAfterRedirects=r}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class jO extends Ho{constructor(t,e,r){super(t,e),this.reason=r}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class z9 extends Ho{constructor(t,e,r){super(t,e),this.error=r}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class U9 extends Ho{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class H9 extends Ho{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class j9 extends Ho{constructor(t,e,r,s,i){super(t,e),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=i}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class W9 extends Ho{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class G9 extends Ho{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class WO{constructor(t){this.route=t}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class GO{constructor(t){this.route=t}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class q9{constructor(t){this.snapshot=t}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class K9{constructor(t){this.snapshot=t}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class X9{constructor(t){this.snapshot=t}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Y9{constructor(t){this.snapshot=t}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class qO{constructor(t,e,r){this.routerEvent=t,this.position=e,this.anchor=r}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const kt="primary";class Z9{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function su(n){return new Z9(n)}const KO="ngNavigationCancelingError";function Sw(n){const t=Error("NavigationCancelingError: "+n);return t[KO]=!0,t}function J9(n,t,e){const r=e.path.split("/");if(r.length>n.length||"full"===e.pathMatch&&(t.hasChildren()||r.length<n.length))return null;const s={};for(let i=0;i<r.length;i++){const o=r[i],a=n[i];if(o.startsWith(":"))s[o.substring(1)]=a;else if(o!==a.path)return null}return{consumed:n.slice(0,r.length),posParams:s}}function lo(n,t){const e=n?Object.keys(n):void 0,r=t?Object.keys(t):void 0;if(!e||!r||e.length!=r.length)return!1;let s;for(let i=0;i<e.length;i++)if(s=e[i],!XO(n[s],t[s]))return!1;return!0}function XO(n,t){if(Array.isArray(n)&&Array.isArray(t)){if(n.length!==t.length)return!1;const e=[...n].sort(),r=[...t].sort();return e.every((s,i)=>r[i]===s)}return n===t}function YO(n){return Array.prototype.concat.apply([],n)}function ZO(n){return n.length>0?n[n.length-1]:null}function Fr(n,t){for(const e in n)n.hasOwnProperty(e)&&t(n[e],e)}function co(n){return uN(n)?n:fm(n)?Ar(Promise.resolve(n)):it(n)}const nZ={exact:function eF(n,t,e){if(!Sl(n.segments,t.segments)||!Dg(n.segments,t.segments,e)||n.numberOfChildren!==t.numberOfChildren)return!1;for(const r in t.children)if(!n.children[r]||!eF(n.children[r],t.children[r],e))return!1;return!0},subset:tF},QO={exact:function rZ(n,t){return lo(n,t)},subset:function sZ(n,t){return Object.keys(t).length<=Object.keys(n).length&&Object.keys(t).every(e=>XO(n[e],t[e]))},ignored:()=>!0};function JO(n,t,e){return nZ[e.paths](n.root,t.root,e.matrixParams)&&QO[e.queryParams](n.queryParams,t.queryParams)&&!("exact"===e.fragment&&n.fragment!==t.fragment)}function tF(n,t,e){return nF(n,t,t.segments,e)}function nF(n,t,e,r){if(n.segments.length>e.length){const s=n.segments.slice(0,e.length);return!(!Sl(s,e)||t.hasChildren()||!Dg(s,e,r))}if(n.segments.length===e.length){if(!Sl(n.segments,e)||!Dg(n.segments,e,r))return!1;for(const s in t.children)if(!n.children[s]||!tF(n.children[s],t.children[s],r))return!1;return!0}{const s=e.slice(0,n.segments.length),i=e.slice(n.segments.length);return!!(Sl(n.segments,s)&&Dg(n.segments,s,r)&&n.children[kt])&&nF(n.children[kt],t,i,r)}}function Dg(n,t,e){return t.every((r,s)=>QO[e](n[s].parameters,r.parameters))}class Dl{constructor(t,e,r){this.root=t,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=su(this.queryParams)),this._queryParamMap}toString(){return aZ.serialize(this)}}class Ot{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Fr(e,(r,s)=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Sg(this)}}class hh{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=su(this.parameters)),this._parameterMap}toString(){return aF(this)}}function Sl(n,t){return n.length===t.length&&n.every((e,r)=>e.path===t[r].path)}class rF{}class sF{parse(t){const e=new gZ(t);return new Dl(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){const e=`/${fh(t.root,!0)}`,r=function uZ(n){const t=Object.keys(n).map(e=>{const r=n[e];return Array.isArray(r)?r.map(s=>`${Eg(e)}=${Eg(s)}`).join("&"):`${Eg(e)}=${Eg(r)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(t.queryParams);return`${e}${r}${"string"==typeof t.fragment?`#${function lZ(n){return encodeURI(n)}(t.fragment)}`:""}`}}const aZ=new sF;function Sg(n){return n.segments.map(t=>aF(t)).join("/")}function fh(n,t){if(!n.hasChildren())return Sg(n);if(t){const e=n.children[kt]?fh(n.children[kt],!1):"",r=[];return Fr(n.children,(s,i)=>{i!==kt&&r.push(`${i}:${fh(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function oZ(n,t){let e=[];return Fr(n.children,(r,s)=>{s===kt&&(e=e.concat(t(r,s)))}),Fr(n.children,(r,s)=>{s!==kt&&(e=e.concat(t(r,s)))}),e}(n,(r,s)=>s===kt?[fh(n.children[kt],!1)]:[`${s}:${fh(r,!1)}`]);return 1===Object.keys(n.children).length&&null!=n.children[kt]?`${Sg(n)}/${e[0]}`:`${Sg(n)}/(${e.join("//")})`}}function iF(n){return encodeURIComponent(n).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Eg(n){return iF(n).replace(/%3B/gi,";")}function Ew(n){return iF(n).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Ig(n){return decodeURIComponent(n)}function oF(n){return Ig(n.replace(/\+/g,"%20"))}function aF(n){return`${Ew(n.path)}${function cZ(n){return Object.keys(n).map(t=>`;${Ew(t)}=${Ew(n[t])}`).join("")}(n.parameters)}`}const dZ=/^[^\/()?;=#]+/;function Tg(n){const t=n.match(dZ);return t?t[0]:""}const hZ=/^[^=?&#]+/,pZ=/^[^&#]+/;class gZ{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new Ot([],{}):new Ot([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(r[kt]=new Ot(t,e)),r}parseSegment(){const t=Tg(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(t),new hh(Ig(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=Tg(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=Tg(this.remaining);s&&(r=s,this.capture(r))}t[Ig(e)]=Ig(r)}parseQueryParam(t){const e=function fZ(n){const t=n.match(hZ);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const o=function mZ(n){const t=n.match(pZ);return t?t[0]:""}(this.remaining);o&&(r=o,this.capture(r))}const s=oF(e),i=oF(r);if(t.hasOwnProperty(s)){let o=t[s];Array.isArray(o)||(o=[o],t[s]=o),o.push(i)}else t[s]=i}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=Tg(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new Error(`Cannot parse url '${this.url}'`);let i;r.indexOf(":")>-1?(i=r.substr(0,r.indexOf(":")),this.capture(i),this.capture(":")):t&&(i=kt);const o=this.parseChildren();e[i]=1===Object.keys(o).length?o[kt]:new Ot([],o),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new Error(`Expected "${t}".`)}}class lF{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=Iw(t,this._root);return e?e.children.map(r=>r.value):[]}firstChild(t){const e=Iw(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=Tw(t,this._root);return e.length<2?[]:e[e.length-2].children.map(s=>s.value).filter(s=>s!==t)}pathFromRoot(t){return Tw(t,this._root).map(e=>e.value)}}function Iw(n,t){if(n===t.value)return t;for(const e of t.children){const r=Iw(n,e);if(r)return r}return null}function Tw(n,t){if(n===t.value)return[t];for(const e of t.children){const r=Tw(n,e);if(r.length)return r.unshift(t),r}return[]}class jo{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function iu(n){const t={};return n&&n.children.forEach(e=>t[e.value.outlet]=e),t}class cF extends lF{constructor(t,e){super(t),this.snapshot=e,kw(this,t)}toString(){return this.snapshot.toString()}}function uF(n,t){const e=function yZ(n,t){const o=new kg([],{},{},"",{},kt,t,null,n.root,-1,{});return new hF("",new jo(o,[]))}(n,t),r=new ri([new hh("",{})]),s=new ri({}),i=new ri({}),o=new ri({}),a=new ri(""),l=new ou(r,s,o,a,i,kt,t,e.root);return l.snapshot=e.root,new cF(new jo(l,[]),e)}class ou{constructor(t,e,r,s,i,o,a,l){this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=i,this.outlet=o,this.component=a,this._futureSnapshot=l}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(Et(t=>su(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(Et(t=>su(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function dF(n,t="emptyOnly"){const e=n.pathFromRoot;let r=0;if("always"!==t)for(r=e.length-1;r>=1;){const s=e[r],i=e[r-1];if(s.routeConfig&&""===s.routeConfig.path)r--;else{if(i.component)break;r--}}return function _Z(n){return n.reduce((t,e)=>({params:Object.assign(Object.assign({},t.params),e.params),data:Object.assign(Object.assign({},t.data),e.data),resolve:Object.assign(Object.assign({},t.resolve),e._resolvedData)}),{params:{},data:{},resolve:{}})}(e.slice(r))}class kg{constructor(t,e,r,s,i,o,a,l,c,u,d){this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=i,this.outlet=o,this.component=a,this.routeConfig=l,this._urlSegment=c,this._lastPathIndex=u,this._resolve=d}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=su(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=su(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class hF extends lF{constructor(t,e){super(e),this.url=t,kw(this,e)}toString(){return fF(this._root)}}function kw(n,t){t.value._routerState=n,t.children.forEach(e=>kw(n,e))}function fF(n){const t=n.children.length>0?` { ${n.children.map(fF).join(", ")} } `:"";return`${n.value}${t}`}function Nw(n){if(n.snapshot){const t=n.snapshot,e=n._futureSnapshot;n.snapshot=e,lo(t.queryParams,e.queryParams)||n.queryParams.next(e.queryParams),t.fragment!==e.fragment&&n.fragment.next(e.fragment),lo(t.params,e.params)||n.params.next(e.params),function eZ(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(!lo(n[e],t[e]))return!1;return!0}(t.url,e.url)||n.url.next(e.url),lo(t.data,e.data)||n.data.next(e.data)}else n.snapshot=n._futureSnapshot,n.data.next(n._futureSnapshot.data)}function Aw(n,t){const e=lo(n.params,t.params)&&function iZ(n,t){return Sl(n,t)&&n.every((e,r)=>lo(e.parameters,t[r].parameters))}(n.url,t.url);return e&&!(!n.parent!=!t.parent)&&(!n.parent||Aw(n.parent,t.parent))}function ph(n,t,e){if(e&&n.shouldReuseRoute(t.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=t.value;const s=function bZ(n,t,e){return t.children.map(r=>{for(const s of e.children)if(n.shouldReuseRoute(r.value,s.value.snapshot))return ph(n,r,s);return ph(n,r)})}(n,t,e);return new jo(r,s)}{if(n.shouldAttach(t.value)){const i=n.retrieve(t.value);if(null!==i){const o=i.route;return o.value._futureSnapshot=t.value,o.children=t.children.map(a=>ph(n,a)),o}}const r=function xZ(n){return new ou(new ri(n.url),new ri(n.params),new ri(n.queryParams),new ri(n.fragment),new ri(n.data),n.outlet,n.component,n)}(t.value),s=t.children.map(i=>ph(n,i));return new jo(r,s)}}function Ng(n){return"object"==typeof n&&null!=n&&!n.outlets&&!n.segmentPath}function mh(n){return"object"==typeof n&&null!=n&&n.outlets}function Rw(n,t,e,r,s){let i={};if(r&&Fr(r,(a,l)=>{i[l]=Array.isArray(a)?a.map(c=>`${c}`):`${a}`}),n===t)return new Dl(e,i,s);const o=pF(n,t,e);return new Dl(o,i,s)}function pF(n,t,e){const r={};return Fr(n.children,(s,i)=>{r[i]=s===t?e:pF(s,t,e)}),new Ot(n.segments,r)}class mF{constructor(t,e,r){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=r,t&&r.length>0&&Ng(r[0]))throw new Error("Root segment cannot have matrix parameters");const s=r.find(mh);if(s&&s!==ZO(r))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Mw{constructor(t,e,r){this.segmentGroup=t,this.processChildren=e,this.index=r}}function gF(n,t,e){if(n||(n=new Ot([],{})),0===n.segments.length&&n.hasChildren())return Ag(n,t,e);const r=function IZ(n,t,e){let r=0,s=t;const i={match:!1,pathIndex:0,commandIndex:0};for(;s<n.segments.length;){if(r>=e.length)return i;const o=n.segments[s],a=e[r];if(mh(a))break;const l=`${a}`,c=r<e.length-1?e[r+1]:null;if(s>0&&void 0===l)break;if(l&&c&&"object"==typeof c&&void 0===c.outlets){if(!_F(l,c,o))return i;r+=2}else{if(!_F(l,{},o))return i;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(n,t,e),s=e.slice(r.commandIndex);if(r.match&&r.pathIndex<n.segments.length){const i=new Ot(n.segments.slice(0,r.pathIndex),{});return i.children[kt]=new Ot(n.segments.slice(r.pathIndex),n.children),Ag(i,0,s)}return r.match&&0===s.length?new Ot(n.segments,{}):r.match&&!n.hasChildren()?Ow(n,t,e):r.match?Ag(n,0,s):Ow(n,t,e)}function Ag(n,t,e){if(0===e.length)return new Ot(n.segments,{});{const r=function EZ(n){return mh(n[0])?n[0].outlets:{[kt]:n}}(e),s={};return Fr(r,(i,o)=>{"string"==typeof i&&(i=[i]),null!==i&&(s[o]=gF(n.children[o],t,i))}),Fr(n.children,(i,o)=>{void 0===r[o]&&(s[o]=i)}),new Ot(n.segments,s)}}function Ow(n,t,e){const r=n.segments.slice(0,t);let s=0;for(;s<e.length;){const i=e[s];if(mh(i)){const l=TZ(i.outlets);return new Ot(r,l)}if(0===s&&Ng(e[0])){r.push(new hh(n.segments[t].path,yF(e[0]))),s++;continue}const o=mh(i)?i.outlets[kt]:`${i}`,a=s<e.length-1?e[s+1]:null;o&&a&&Ng(a)?(r.push(new hh(o,yF(a))),s+=2):(r.push(new hh(o,{})),s++)}return new Ot(r,{})}function TZ(n){const t={};return Fr(n,(e,r)=>{"string"==typeof e&&(e=[e]),null!==e&&(t[r]=Ow(new Ot([],{}),0,e))}),t}function yF(n){const t={};return Fr(n,(e,r)=>t[r]=`${e}`),t}function _F(n,t,e){return n==e.path&&lo(t,e.parameters)}class NZ{constructor(t,e,r,s){this.routeReuseStrategy=t,this.futureState=e,this.currState=r,this.forwardEvent=s}activate(t){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,t),Nw(this.futureState.root),this.activateChildRoutes(e,r,t)}deactivateChildRoutes(t,e,r){const s=iu(e);t.children.forEach(i=>{const o=i.value.outlet;this.deactivateRoutes(i,s[o],r),delete s[o]}),Fr(s,(i,o)=>{this.deactivateRouteAndItsChildren(i,r)})}deactivateRoutes(t,e,r){const s=t.value,i=e?e.value:null;if(s===i)if(s.component){const o=r.getContext(s.outlet);o&&this.deactivateChildRoutes(t,e,o.children)}else this.deactivateChildRoutes(t,e,r);else i&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(t,e){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,i=iu(t);for(const o of Object.keys(i))this.deactivateRouteAndItsChildren(i[o],s);if(r&&r.outlet){const o=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:o,route:t,contexts:a})}}deactivateRouteAndOutlet(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,i=iu(t);for(const o of Object.keys(i))this.deactivateRouteAndItsChildren(i[o],s);r&&r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated(),r.attachRef=null,r.resolver=null,r.route=null)}activateChildRoutes(t,e,r){const s=iu(e);t.children.forEach(i=>{this.activateRoutes(i,s[i.value.outlet],r),this.forwardEvent(new Y9(i.value.snapshot))}),t.children.length&&this.forwardEvent(new K9(t.value.snapshot))}activateRoutes(t,e,r){const s=t.value,i=e?e.value:null;if(Nw(s),s===i)if(s.component){const o=r.getOrCreateContext(s.outlet);this.activateChildRoutes(t,e,o.children)}else this.activateChildRoutes(t,e,r);else if(s.component){const o=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),o.children.onOutletReAttached(a.contexts),o.attachRef=a.componentRef,o.route=a.route.value,o.outlet&&o.outlet.attach(a.componentRef,a.route.value),Nw(a.route.value),this.activateChildRoutes(t,null,o.children)}else{const a=function AZ(n){for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig;if(e&&e.component)return null}return null}(s.snapshot),l=a?a.module.componentFactoryResolver:null;o.attachRef=null,o.route=s,o.resolver=l,o.outlet&&o.outlet.activateWith(s,l),this.activateChildRoutes(t,null,o.children)}}else this.activateChildRoutes(t,null,r)}}class Fw{constructor(t,e){this.routes=t,this.module=e}}function Ca(n){return"function"==typeof n}function El(n){return n instanceof Dl}const gh=Symbol("INITIAL_VALUE");function yh(){return wa(n=>LO(n.map(t=>t.pipe(Br(1),Uo(gh)))).pipe(zO((t,e)=>{let r=!1;return e.reduce((s,i,o)=>s!==gh?s:(i===gh&&(r=!0),r||!1!==i&&o!==e.length-1&&!El(i)?s:i),t)},gh),ur(t=>t!==gh),Et(t=>El(t)?t:!0===t),Br(1)))}class $Z{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new _h,this.attachRef=null}}class _h{constructor(){this.contexts=new Map}onChildOutletCreated(t,e){const r=this.getOrCreateContext(t);r.outlet=e,this.contexts.set(t,r)}onChildOutletDestroyed(t){const e=this.getContext(t);e&&(e.outlet=null,e.attachRef=null)}onOutletDeactivated(){const t=this.contexts;return this.contexts=new Map,t}onOutletReAttached(t){this.contexts=t}getOrCreateContext(t){let e=this.getContext(t);return e||(e=new $Z,this.contexts.set(t,e)),e}getContext(t){return this.contexts.get(t)||null}}let vF=(()=>{class n{constructor(e,r,s,i,o){this.parentContexts=e,this.location=r,this.resolver=s,this.changeDetector=o,this.activated=null,this._activatedRoute=null,this.activateEvents=new Bt,this.deactivateEvents=new Bt,this.attachEvents=new Bt,this.detachEvents=new Bt,this.name=i||kt,e.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const e=this.parentContexts.getContext(this.name);e&&e.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=e;const o=(r=r||this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component),a=this.parentContexts.getOrCreateContext(this.name).children,l=new LZ(e,a,this.location.injector);this.activated=this.location.createComponent(o,this.location.length,l),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return n.\u0275fac=function(e){return new(e||n)(oe(_h),oe(Ms),oe(ul),pc("name"),oe(oo))},n.\u0275dir=un({type:n,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"]}),n})();class LZ{constructor(t,e,r){this.route=t,this.childContexts=e,this.parent=r}get(t,e){return t===ou?this.route:t===_h?this.childContexts:this.parent.get(t,e)}}let bF=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Wn({type:n,selectors:[["ng-component"]],decls:1,vars:0,template:function(e,r){1&e&&hn(0,"router-outlet")},directives:[vF],encapsulation:2}),n})();function xF(n,t=""){for(let e=0;e<n.length;e++){const r=n[e];VZ(r,BZ(t,r))}}function VZ(n,t){n.children&&xF(n.children,t)}function BZ(n,t){return t?n||t.path?n&&!t.path?`${n}/`:!n&&t.path?t.path:`${n}/${t.path}`:"":n}function Pw(n){const t=n.children&&n.children.map(Pw),e=t?Object.assign(Object.assign({},n),{children:t}):Object.assign({},n);return!e.component&&(t||e.loadChildren)&&e.outlet&&e.outlet!==kt&&(e.component=bF),e}function oi(n){return n.outlet||kt}function wF(n,t){const e=n.filter(r=>oi(r)===t);return e.push(...n.filter(r=>oi(r)!==t)),e}const CF={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function Rg(n,t,e){var r;if(""===t.path)return"full"===t.pathMatch&&(n.hasChildren()||e.length>0)?Object.assign({},CF):{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const i=(t.matcher||J9)(e,n,t);if(!i)return Object.assign({},CF);const o={};Fr(i.posParams,(l,c)=>{o[c]=l.path});const a=i.consumed.length>0?Object.assign(Object.assign({},o),i.consumed[i.consumed.length-1].parameters):o;return{matched:!0,consumedSegments:i.consumed,remainingSegments:e.slice(i.consumed.length),parameters:a,positionalParamSegments:null!==(r=i.posParams)&&void 0!==r?r:{}}}function Mg(n,t,e,r,s="corrected"){if(e.length>0&&function HZ(n,t,e){return e.some(r=>Og(n,t,r)&&oi(r)!==kt)}(n,e,r)){const o=new Ot(t,function UZ(n,t,e,r){const s={};s[kt]=r,r._sourceSegment=n,r._segmentIndexShift=t.length;for(const i of e)if(""===i.path&&oi(i)!==kt){const o=new Ot([],{});o._sourceSegment=n,o._segmentIndexShift=t.length,s[oi(i)]=o}return s}(n,t,r,new Ot(e,n.children)));return o._sourceSegment=n,o._segmentIndexShift=t.length,{segmentGroup:o,slicedSegments:[]}}if(0===e.length&&function jZ(n,t,e){return e.some(r=>Og(n,t,r))}(n,e,r)){const o=new Ot(n.segments,function zZ(n,t,e,r,s,i){const o={};for(const a of r)if(Og(n,e,a)&&!s[oi(a)]){const l=new Ot([],{});l._sourceSegment=n,l._segmentIndexShift="legacy"===i?n.segments.length:t.length,o[oi(a)]=l}return Object.assign(Object.assign({},s),o)}(n,t,e,r,n.children,s));return o._sourceSegment=n,o._segmentIndexShift=t.length,{segmentGroup:o,slicedSegments:e}}const i=new Ot(n.segments,n.children);return i._sourceSegment=n,i._segmentIndexShift=t.length,{segmentGroup:i,slicedSegments:e}}function Og(n,t,e){return(!(n.hasChildren()||t.length>0)||"full"!==e.pathMatch)&&""===e.path}function DF(n,t,e,r){return!!(oi(n)===r||r!==kt&&Og(t,e,n))&&("**"===n.path||Rg(t,n,e).matched)}function SF(n,t,e){return 0===t.length&&!n.children[e]}class Fg{constructor(t){this.segmentGroup=t||null}}class EF{constructor(t){this.urlTree=t}}function vh(n){return lh(new Fg(n))}function IF(n){return lh(new EF(n))}class KZ{constructor(t,e,r,s,i){this.configLoader=e,this.urlSerializer=r,this.urlTree=s,this.config=i,this.allowRedirects=!0,this.ngModule=t.get(Fo)}apply(){const t=Mg(this.urlTree.root,[],[],this.config).segmentGroup,e=new Ot(t.segments,t.children);return this.expandSegmentGroup(this.ngModule,this.config,e,kt).pipe(Et(i=>this.createUrlTree($w(i),this.urlTree.queryParams,this.urlTree.fragment))).pipe(zo(i=>{if(i instanceof EF)return this.allowRedirects=!1,this.match(i.urlTree);throw i instanceof Fg?this.noMatchError(i):i}))}match(t){return this.expandSegmentGroup(this.ngModule,this.config,t.root,kt).pipe(Et(s=>this.createUrlTree($w(s),t.queryParams,t.fragment))).pipe(zo(s=>{throw s instanceof Fg?this.noMatchError(s):s}))}noMatchError(t){return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`)}createUrlTree(t,e,r){const s=t.segments.length>0?new Ot([],{[kt]:t}):t;return new Dl(s,e,r)}expandSegmentGroup(t,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.expandChildren(t,e,r).pipe(Et(i=>new Ot([],i))):this.expandSegment(t,r,e,r.segments,s,!0)}expandChildren(t,e,r){const s=[];for(const i of Object.keys(r.children))"primary"===i?s.unshift(i):s.push(i);return Ar(s).pipe(nu(i=>{const o=r.children[i],a=wF(e,i);return this.expandSegmentGroup(t,a,o,i).pipe(Et(l=>({segment:l,outlet:i})))}),zO((i,o)=>(i[o.outlet]=o.segment,i),{}),function B9(n,t){const e=arguments.length>=2;return r=>r.pipe(n?ur((s,i)=>n(s,i,r)):gn,Cw(1),e?HO(t):UO(()=>new wg))}())}expandSegment(t,e,r,s,i,o){return Ar(r).pipe(nu(a=>this.expandSegmentAgainstRoute(t,e,r,a,s,i,o).pipe(zo(c=>{if(c instanceof Fg)return it(null);throw c}))),ru(a=>!!a),zo((a,l)=>{if(a instanceof wg||"EmptyError"===a.name)return SF(e,s,i)?it(new Ot([],{})):vh(e);throw a}))}expandSegmentAgainstRoute(t,e,r,s,i,o,a){return DF(s,e,i,o)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(t,e,s,i,o):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o):vh(e):vh(e)}expandSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,r,s,o):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,r,s){const i=this.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?IF(i):this.lineralizeSegments(r,i).pipe(ir(o=>{const a=new Ot(o,{});return this.expandSegment(t,a,e,o,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o){const{matched:a,consumedSegments:l,remainingSegments:c,positionalParamSegments:u}=Rg(e,s,i);if(!a)return vh(e);const d=this.applyRedirectCommands(l,s.redirectTo,u);return s.redirectTo.startsWith("/")?IF(d):this.lineralizeSegments(s,d).pipe(ir(h=>this.expandSegment(t,e,r,h.concat(c),o,!1)))}matchSegmentAgainstRoute(t,e,r,s,i){if("**"===r.path)return r.loadChildren?(r._loadedConfig?it(r._loadedConfig):this.configLoader.load(t.injector,r)).pipe(Et(d=>(r._loadedConfig=d,new Ot(s,{})))):it(new Ot(s,{}));const{matched:o,consumedSegments:a,remainingSegments:l}=Rg(e,r,s);return o?this.getChildConfig(t,r,s).pipe(ir(u=>{const d=u.module,h=u.routes,{segmentGroup:f,slicedSegments:p}=Mg(e,a,l,h),m=new Ot(f.segments,f.children);if(0===p.length&&m.hasChildren())return this.expandChildren(d,h,m).pipe(Et(v=>new Ot(a,v)));if(0===h.length&&0===p.length)return it(new Ot(a,{}));const g=oi(r)===i;return this.expandSegment(d,m,h,p,g?kt:i,!0).pipe(Et(y=>new Ot(a.concat(y.segments),y.children)))})):vh(e)}getChildConfig(t,e,r){return e.children?it(new Fw(e.children,t)):e.loadChildren?void 0!==e._loadedConfig?it(e._loadedConfig):this.runCanLoadGuards(t.injector,e,r).pipe(ir(s=>s?this.configLoader.load(t.injector,e).pipe(Et(i=>(e._loadedConfig=i,i))):function GZ(n){return lh(Sw(`Cannot load children because the guard of the route "path: '${n.path}'" returned false`))}(e))):it(new Fw([],t))}runCanLoadGuards(t,e,r){const s=e.canLoad;return s&&0!==s.length?it(s.map(o=>{const a=t.get(o);let l;if(function MZ(n){return n&&Ca(n.canLoad)}(a))l=a.canLoad(e,r);else{if(!Ca(a))throw new Error("Invalid CanLoad guard");l=a(e,r)}return co(l)})).pipe(yh(),Mr(o=>{if(!El(o))return;const a=Sw(`Redirecting to "${this.urlSerializer.serialize(o)}"`);throw a.url=o,a}),Et(o=>!0===o)):it(!0)}lineralizeSegments(t,e){let r=[],s=e.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return it(r);if(s.numberOfChildren>1||!s.children[kt])return lh(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t.redirectTo}'`));s=s.children[kt]}}applyRedirectCommands(t,e,r){return this.applyRedirectCreatreUrlTree(e,this.urlSerializer.parse(e),t,r)}applyRedirectCreatreUrlTree(t,e,r,s){const i=this.createSegmentGroup(t,e.root,r,s);return new Dl(i,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const r={};return Fr(t,(s,i)=>{if("string"==typeof s&&s.startsWith(":")){const a=s.substring(1);r[i]=e[a]}else r[i]=s}),r}createSegmentGroup(t,e,r,s){const i=this.createSegments(t,e.segments,r,s);let o={};return Fr(e.children,(a,l)=>{o[l]=this.createSegmentGroup(t,a,r,s)}),new Ot(i,o)}createSegments(t,e,r,s){return e.map(i=>i.path.startsWith(":")?this.findPosParam(t,i,s):this.findOrReturn(i,r))}findPosParam(t,e,r){const s=r[e.path.substring(1)];if(!s)throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`);return s}findOrReturn(t,e){let r=0;for(const s of e){if(s.path===t.path)return e.splice(r),s;r++}return t}}function $w(n){const t={};for(const r of Object.keys(n.children)){const i=$w(n.children[r]);(i.segments.length>0||i.hasChildren())&&(t[r]=i)}return function XZ(n){if(1===n.numberOfChildren&&n.children[kt]){const t=n.children[kt];return new Ot(n.segments.concat(t.segments),t.children)}return n}(new Ot(n.segments,t))}class TF{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class Pg{constructor(t,e){this.component=t,this.route=e}}function ZZ(n,t,e){const r=n._root;return bh(r,t?t._root:null,e,[r.value])}function $g(n,t,e){const r=function JZ(n){if(!n)return null;for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig}return null}(t);return(r?r.module.injector:e).get(n)}function bh(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const i=iu(t);return n.children.forEach(o=>{(function eQ(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const i=n.value,o=t?t.value:null,a=e?e.getContext(n.value.outlet):null;if(o&&i.routeConfig===o.routeConfig){const l=function tQ(n,t,e){if("function"==typeof e)return e(n,t);switch(e){case"pathParamsChange":return!Sl(n.url,t.url);case"pathParamsOrQueryParamsChange":return!Sl(n.url,t.url)||!lo(n.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Aw(n,t)||!lo(n.queryParams,t.queryParams);default:return!Aw(n,t)}}(o,i,i.routeConfig.runGuardsAndResolvers);l?s.canActivateChecks.push(new TF(r)):(i.data=o.data,i._resolvedData=o._resolvedData),bh(n,t,i.component?a?a.children:null:e,r,s),l&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new Pg(a.outlet.component,o))}else o&&xh(t,a,s),s.canActivateChecks.push(new TF(r)),bh(n,null,i.component?a?a.children:null:e,r,s)})(o,i[o.value.outlet],e,r.concat([o.value]),s),delete i[o.value.outlet]}),Fr(i,(o,a)=>xh(o,e.getContext(a),s)),s}function xh(n,t,e){const r=iu(n),s=n.value;Fr(r,(i,o)=>{xh(i,s.component?t?t.children.getContext(o):null:t,e)}),e.canDeactivateChecks.push(new Pg(s.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,s))}class uQ{}function kF(n){return new ct(t=>t.error(n))}class hQ{constructor(t,e,r,s,i,o){this.rootComponentType=t,this.config=e,this.urlTree=r,this.url=s,this.paramsInheritanceStrategy=i,this.relativeLinkResolution=o}recognize(){const t=Mg(this.urlTree.root,[],[],this.config.filter(o=>void 0===o.redirectTo),this.relativeLinkResolution).segmentGroup,e=this.processSegmentGroup(this.config,t,kt);if(null===e)return null;const r=new kg([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},kt,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new jo(r,e),i=new hF(this.url,s);return this.inheritParamsAndData(i._root),i}inheritParamsAndData(t){const e=t.value,r=dF(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),t.children.forEach(s=>this.inheritParamsAndData(s))}processSegmentGroup(t,e,r){return 0===e.segments.length&&e.hasChildren()?this.processChildren(t,e):this.processSegment(t,e,e.segments,r)}processChildren(t,e){const r=[];for(const i of Object.keys(e.children)){const o=e.children[i],a=wF(t,i),l=this.processSegmentGroup(a,o,i);if(null===l)return null;r.push(...l)}const s=NF(r);return function fQ(n){n.sort((t,e)=>t.value.outlet===kt?-1:e.value.outlet===kt?1:t.value.outlet.localeCompare(e.value.outlet))}(s),s}processSegment(t,e,r,s){for(const i of t){const o=this.processSegmentAgainstRoute(i,e,r,s);if(null!==o)return o}return SF(e,r,s)?[]:null}processSegmentAgainstRoute(t,e,r,s){if(t.redirectTo||!DF(t,e,r,s))return null;let i,o=[],a=[];if("**"===t.path){const f=r.length>0?ZO(r).parameters:{};i=new kg(r,f,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,MF(t),oi(t),t.component,t,AF(e),RF(e)+r.length,OF(t))}else{const f=Rg(e,t,r);if(!f.matched)return null;o=f.consumedSegments,a=f.remainingSegments,i=new kg(o,f.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,MF(t),oi(t),t.component,t,AF(e),RF(e)+o.length,OF(t))}const l=function pQ(n){return n.children?n.children:n.loadChildren?n._loadedConfig.routes:[]}(t),{segmentGroup:c,slicedSegments:u}=Mg(e,o,a,l.filter(f=>void 0===f.redirectTo),this.relativeLinkResolution);if(0===u.length&&c.hasChildren()){const f=this.processChildren(l,c);return null===f?null:[new jo(i,f)]}if(0===l.length&&0===u.length)return[new jo(i,[])];const d=oi(t)===s,h=this.processSegment(l,c,u,d?kt:s);return null===h?null:[new jo(i,h)]}}function mQ(n){const t=n.value.routeConfig;return t&&""===t.path&&void 0===t.redirectTo}function NF(n){const t=[],e=new Set;for(const r of n){if(!mQ(r)){t.push(r);continue}const s=t.find(i=>r.value.routeConfig===i.value.routeConfig);void 0!==s?(s.children.push(...r.children),e.add(s)):t.push(r)}for(const r of e){const s=NF(r.children);t.push(new jo(r.value,s))}return t.filter(r=>!e.has(r))}function AF(n){let t=n;for(;t._sourceSegment;)t=t._sourceSegment;return t}function RF(n){let t=n,e=t._segmentIndexShift?t._segmentIndexShift:0;for(;t._sourceSegment;)t=t._sourceSegment,e+=t._segmentIndexShift?t._segmentIndexShift:0;return e-1}function MF(n){return n.data||{}}function OF(n){return n.resolve||{}}function FF(n){return[...Object.keys(n),...Object.getOwnPropertySymbols(n)]}function Lw(n){return wa(t=>{const e=n(t);return e?Ar(e).pipe(Et(()=>t)):it(t)})}class CQ extends class wQ{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}{}const Vw=new Fe("ROUTES");class PF{constructor(t,e,r,s){this.injector=t,this.compiler=e,this.onLoadStartListener=r,this.onLoadEndListener=s}load(t,e){if(e._loader$)return e._loader$;this.onLoadStartListener&&this.onLoadStartListener(e);const s=this.loadModuleFactory(e.loadChildren).pipe(Et(i=>{this.onLoadEndListener&&this.onLoadEndListener(e);const o=i.create(t);return new Fw(YO(o.injector.get(Vw,void 0,ut.Self|ut.Optional)).map(Pw),o)}),zo(i=>{throw e._loader$=void 0,i}));return e._loader$=new $9(s,()=>new Ge).pipe(BO()),e._loader$}loadModuleFactory(t){return co(t()).pipe(ir(e=>e instanceof kA?it(e):Ar(this.compiler.compileModuleAsync(e))))}}class SQ{shouldProcessUrl(t){return!0}extract(t){return t}merge(t,e){return t}}function EQ(n){throw n}function IQ(n,t,e){return t.parse("/")}function $F(n,t){return it(null)}const TQ={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},kQ={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let $s=(()=>{class n{constructor(e,r,s,i,o,a,l){this.rootComponentType=e,this.urlSerializer=r,this.rootContexts=s,this.location=i,this.config=l,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new Ge,this.errorHandler=EQ,this.malformedUriErrorHandler=IQ,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:$F,afterPreactivation:$F},this.urlHandlingStrategy=new SQ,this.routeReuseStrategy=new CQ,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.canceledNavigationResolution="replace",this.ngModule=o.get(Fo),this.console=o.get(h8);const d=o.get(Ct);this.isNgZoneEnabled=d instanceof Ct&&Ct.isInAngularZone(),this.resetConfig(l),this.currentUrlTree=function tZ(){return new Dl(new Ot([],{}),{},null)}(),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new PF(o,a,h=>this.triggerEvent(new WO(h)),h=>this.triggerEvent(new GO(h))),this.routerState=uF(this.currentUrlTree,this.rootComponentType),this.transitions=new ri({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}get browserPageId(){var e;return null===(e=this.location.getState())||void 0===e?void 0:e.\u0275routerPageId}setupNavigations(e){const r=this.events;return e.pipe(ur(s=>0!==s.id),Et(s=>Object.assign(Object.assign({},s),{extractedUrl:this.urlHandlingStrategy.extract(s.rawUrl)})),wa(s=>{let i=!1,o=!1;return it(s).pipe(Mr(a=>{this.currentNavigation={id:a.id,initialUrl:a.currentRawUrl,extractedUrl:a.extractedUrl,trigger:a.source,extras:a.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),wa(a=>{const l=this.browserUrlTree.toString(),c=!this.navigated||a.extractedUrl.toString()!==l||l!==this.currentUrlTree.toString();if(("reload"===this.onSameUrlNavigation||c)&&this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl))return LF(a.source)&&(this.browserUrlTree=a.extractedUrl),it(a).pipe(wa(d=>{const h=this.transitions.getValue();return r.next(new Dw(d.id,this.serializeUrl(d.extractedUrl),d.source,d.restoredState)),h!==this.transitions.getValue()?Eo:Promise.resolve(d)}),function YZ(n,t,e,r){return wa(s=>function qZ(n,t,e,r,s){return new KZ(n,t,e,r,s).apply()}(n,t,e,s.extractedUrl,r).pipe(Et(i=>Object.assign(Object.assign({},s),{urlAfterRedirects:i}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),Mr(d=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:d.urlAfterRedirects})}),function gQ(n,t,e,r,s){return ir(i=>function dQ(n,t,e,r,s="emptyOnly",i="legacy"){try{const o=new hQ(n,t,e,r,s,i).recognize();return null===o?kF(new uQ):it(o)}catch(o){return kF(o)}}(n,t,i.urlAfterRedirects,e(i.urlAfterRedirects),r,s).pipe(Et(o=>Object.assign(Object.assign({},i),{targetSnapshot:o}))))}(this.rootComponentType,this.config,d=>this.serializeUrl(d),this.paramsInheritanceStrategy,this.relativeLinkResolution),Mr(d=>{if("eager"===this.urlUpdateStrategy){if(!d.extras.skipLocationChange){const f=this.urlHandlingStrategy.merge(d.urlAfterRedirects,d.rawUrl);this.setBrowserUrl(f,d)}this.browserUrlTree=d.urlAfterRedirects}const h=new U9(d.id,this.serializeUrl(d.extractedUrl),this.serializeUrl(d.urlAfterRedirects),d.targetSnapshot);r.next(h)}));if(c&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:h,extractedUrl:f,source:p,restoredState:m,extras:g}=a,_=new Dw(h,this.serializeUrl(f),p,m);r.next(_);const y=uF(f,this.rootComponentType).snapshot;return it(Object.assign(Object.assign({},a),{targetSnapshot:y,urlAfterRedirects:f,extras:Object.assign(Object.assign({},g),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=a.rawUrl,a.resolve(null),Eo}),Lw(a=>{const{targetSnapshot:l,id:c,extractedUrl:u,rawUrl:d,extras:{skipLocationChange:h,replaceUrl:f}}=a;return this.hooks.beforePreactivation(l,{navigationId:c,appliedUrlTree:u,rawUrlTree:d,skipLocationChange:!!h,replaceUrl:!!f})}),Mr(a=>{const l=new H9(a.id,this.serializeUrl(a.extractedUrl),this.serializeUrl(a.urlAfterRedirects),a.targetSnapshot);this.triggerEvent(l)}),Et(a=>Object.assign(Object.assign({},a),{guards:ZZ(a.targetSnapshot,a.currentSnapshot,this.rootContexts)})),function nQ(n,t){return ir(e=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:i,canDeactivateChecks:o}}=e;return 0===o.length&&0===i.length?it(Object.assign(Object.assign({},e),{guardsResult:!0})):function rQ(n,t,e,r){return Ar(n).pipe(ir(s=>function cQ(n,t,e,r,s){const i=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return i&&0!==i.length?it(i.map(a=>{const l=$g(a,t,s);let c;if(function PZ(n){return n&&Ca(n.canDeactivate)}(l))c=co(l.canDeactivate(n,t,e,r));else{if(!Ca(l))throw new Error("Invalid CanDeactivate guard");c=co(l(n,t,e,r))}return c.pipe(ru())})).pipe(yh()):it(!0)}(s.component,s.route,e,t,r)),ru(s=>!0!==s,!0))}(o,r,s,n).pipe(ir(a=>a&&function RZ(n){return"boolean"==typeof n}(a)?function sQ(n,t,e,r){return Ar(t).pipe(nu(s=>Cg(function oQ(n,t){return null!==n&&t&&t(new q9(n)),it(!0)}(s.route.parent,r),function iQ(n,t){return null!==n&&t&&t(new X9(n)),it(!0)}(s.route,r),function lQ(n,t,e){const r=t[t.length-1],i=t.slice(0,t.length-1).reverse().map(o=>function QZ(n){const t=n.routeConfig?n.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:n,guards:t}:null}(o)).filter(o=>null!==o).map(o=>ww(()=>it(o.guards.map(l=>{const c=$g(l,o.node,e);let u;if(function FZ(n){return n&&Ca(n.canActivateChild)}(c))u=co(c.canActivateChild(r,n));else{if(!Ca(c))throw new Error("Invalid CanActivateChild guard");u=co(c(r,n))}return u.pipe(ru())})).pipe(yh())));return it(i).pipe(yh())}(n,s.path,e),function aQ(n,t,e){const r=t.routeConfig?t.routeConfig.canActivate:null;if(!r||0===r.length)return it(!0);const s=r.map(i=>ww(()=>{const o=$g(i,t,e);let a;if(function OZ(n){return n&&Ca(n.canActivate)}(o))a=co(o.canActivate(t,n));else{if(!Ca(o))throw new Error("Invalid CanActivate guard");a=co(o(t,n))}return a.pipe(ru())}));return it(s).pipe(yh())}(n,s.route,e))),ru(s=>!0!==s,!0))}(r,i,n,t):it(a)),Et(a=>Object.assign(Object.assign({},e),{guardsResult:a})))})}(this.ngModule.injector,a=>this.triggerEvent(a)),Mr(a=>{if(El(a.guardsResult)){const c=Sw(`Redirecting to "${this.serializeUrl(a.guardsResult)}"`);throw c.url=a.guardsResult,c}const l=new j9(a.id,this.serializeUrl(a.extractedUrl),this.serializeUrl(a.urlAfterRedirects),a.targetSnapshot,!!a.guardsResult);this.triggerEvent(l)}),ur(a=>!!a.guardsResult||(this.restoreHistory(a),this.cancelNavigationTransition(a,""),!1)),Lw(a=>{if(a.guards.canActivateChecks.length)return it(a).pipe(Mr(l=>{const c=new W9(l.id,this.serializeUrl(l.extractedUrl),this.serializeUrl(l.urlAfterRedirects),l.targetSnapshot);this.triggerEvent(c)}),wa(l=>{let c=!1;return it(l).pipe(function yQ(n,t){return ir(e=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=e;if(!s.length)return it(e);let i=0;return Ar(s).pipe(nu(o=>function _Q(n,t,e,r){return function vQ(n,t,e,r){const s=FF(n);if(0===s.length)return it({});const i={};return Ar(s).pipe(ir(o=>function bQ(n,t,e,r){const s=$g(n,t,r);return co(s.resolve?s.resolve(t,e):s(t,e))}(n[o],t,e,r).pipe(Mr(a=>{i[o]=a}))),Cw(1),ir(()=>FF(i).length===s.length?it(i):Eo))}(n._resolve,n,t,r).pipe(Et(i=>(n._resolvedData=i,n.data=Object.assign(Object.assign({},n.data),dF(n,e).resolve),null)))}(o.route,r,n,t)),Mr(()=>i++),Cw(1),ir(o=>i===s.length?it(e):Eo))})}(this.paramsInheritanceStrategy,this.ngModule.injector),Mr({next:()=>c=!0,complete:()=>{c||(this.restoreHistory(l),this.cancelNavigationTransition(l,"At least one route resolver didn't emit any value."))}}))}),Mr(l=>{const c=new G9(l.id,this.serializeUrl(l.extractedUrl),this.serializeUrl(l.urlAfterRedirects),l.targetSnapshot);this.triggerEvent(c)}))}),Lw(a=>{const{targetSnapshot:l,id:c,extractedUrl:u,rawUrl:d,extras:{skipLocationChange:h,replaceUrl:f}}=a;return this.hooks.afterPreactivation(l,{navigationId:c,appliedUrlTree:u,rawUrlTree:d,skipLocationChange:!!h,replaceUrl:!!f})}),Et(a=>{const l=function vZ(n,t,e){const r=ph(n,t._root,e?e._root:void 0);return new cF(r,t)}(this.routeReuseStrategy,a.targetSnapshot,a.currentRouterState);return Object.assign(Object.assign({},a),{targetRouterState:l})}),Mr(a=>{this.currentUrlTree=a.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(a.urlAfterRedirects,a.rawUrl),this.routerState=a.targetRouterState,"deferred"===this.urlUpdateStrategy&&(a.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,a),this.browserUrlTree=a.urlAfterRedirects)}),((n,t,e)=>Et(r=>(new NZ(t,r.targetRouterState,r.currentRouterState,e).activate(n),r)))(this.rootContexts,this.routeReuseStrategy,a=>this.triggerEvent(a)),Mr({next(){i=!0},complete(){i=!0}}),SO(()=>{var a;i||o||this.cancelNavigationTransition(s,`Navigation ID ${s.id} is not equal to the current navigation id ${this.navigationId}`),(null===(a=this.currentNavigation)||void 0===a?void 0:a.id)===s.id&&(this.currentNavigation=null)}),zo(a=>{if(o=!0,function Q9(n){return n&&n[KO]}(a)){const l=El(a.url);l||(this.navigated=!0,this.restoreHistory(s,!0));const c=new jO(s.id,this.serializeUrl(s.extractedUrl),a.message);r.next(c),l?setTimeout(()=>{const u=this.urlHandlingStrategy.merge(a.url,this.rawUrlTree),d={skipLocationChange:s.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy||LF(s.source)};this.scheduleNavigation(u,"imperative",null,d,{resolve:s.resolve,reject:s.reject,promise:s.promise})},0):s.resolve(!1)}else{this.restoreHistory(s,!0);const l=new z9(s.id,this.serializeUrl(s.extractedUrl),a);r.next(l);try{s.resolve(this.errorHandler(a))}catch(c){s.reject(c)}}return Eo}))}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}setTransition(e){this.transitions.next(Object.assign(Object.assign({},this.transitions.value),e))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{var s;const i={replaceUrl:!0},o=(null===(s=e.state)||void 0===s?void 0:s.navigationId)?e.state:null;if(o){const l=Object.assign({},o);delete l.navigationId,delete l.\u0275routerPageId,0!==Object.keys(l).length&&(i.state=l)}const a=this.parseUrl(e.url);this.scheduleNavigation(a,r,o,i)},0)}))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){xF(e),this.config=e.map(Pw),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:s,queryParams:i,fragment:o,queryParamsHandling:a,preserveFragment:l}=r,c=s||this.routerState.root,u=l?this.currentUrlTree.fragment:o;let d=null;switch(a){case"merge":d=Object.assign(Object.assign({},this.currentUrlTree.queryParams),i);break;case"preserve":d=this.currentUrlTree.queryParams;break;default:d=i||null}return null!==d&&(d=this.removeEmptyProps(d)),function wZ(n,t,e,r,s){if(0===e.length)return Rw(t.root,t.root,t.root,r,s);const i=function CZ(n){if("string"==typeof n[0]&&1===n.length&&"/"===n[0])return new mF(!0,0,n);let t=0,e=!1;const r=n.reduce((s,i,o)=>{if("object"==typeof i&&null!=i){if(i.outlets){const a={};return Fr(i.outlets,(l,c)=>{a[c]="string"==typeof l?l.split("/"):l}),[...s,{outlets:a}]}if(i.segmentPath)return[...s,i.segmentPath]}return"string"!=typeof i?[...s,i]:0===o?(i.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?e=!0:".."===a?t++:""!=a&&s.push(a))}),s):[...s,i]},[]);return new mF(e,t,r)}(e);if(i.toRoot())return Rw(t.root,t.root,new Ot([],{}),r,s);const o=function DZ(n,t,e){if(n.isAbsolute)return new Mw(t.root,!0,0);if(-1===e.snapshot._lastPathIndex){const i=e.snapshot._urlSegment;return new Mw(i,i===t.root,0)}const r=Ng(n.commands[0])?0:1;return function SZ(n,t,e){let r=n,s=t,i=e;for(;i>s;){if(i-=s,r=r.parent,!r)throw new Error("Invalid number of '../'");s=r.segments.length}return new Mw(r,!1,s-i)}(e.snapshot._urlSegment,e.snapshot._lastPathIndex+r,n.numberOfDoubleDots)}(i,t,n),a=o.processChildren?Ag(o.segmentGroup,o.index,i.commands):gF(o.segmentGroup,o.index,i.commands);return Rw(t.root,o.segmentGroup,a,r,s)}(c,this.currentUrlTree,e,d,null!=u?u:null)}navigateByUrl(e,r={skipLocationChange:!1}){const s=El(e)?e:this.parseUrl(e),i=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(i,"imperative",null,r)}navigate(e,r={skipLocationChange:!1}){return function NQ(n){for(let t=0;t<n.length;t++){const e=n[t];if(null==e)throw new Error(`The requested path contains ${e} segment at index ${t}`)}}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(s){r=this.malformedUriErrorHandler(s,this.urlSerializer,e)}return r}isActive(e,r){let s;if(s=!0===r?Object.assign({},TQ):!1===r?Object.assign({},kQ):r,El(e))return JO(this.currentUrlTree,e,s);const i=this.parseUrl(e);return JO(this.currentUrlTree,i,s)}removeEmptyProps(e){return Object.keys(e).reduce((r,s)=>{const i=e[s];return null!=i&&(r[s]=i),r},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new dh(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,e.resolve(!0)},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}scheduleNavigation(e,r,s,i,o){var a,l;if(this.disposed)return Promise.resolve(!1);let c,u,d;o?(c=o.resolve,u=o.reject,d=o.promise):d=new Promise((p,m)=>{c=p,u=m});const h=++this.navigationId;let f;return"computed"===this.canceledNavigationResolution?(0===this.currentPageId&&(s=this.location.getState()),f=s&&s.\u0275routerPageId?s.\u0275routerPageId:i.replaceUrl||i.skipLocationChange?null!==(a=this.browserPageId)&&void 0!==a?a:0:(null!==(l=this.browserPageId)&&void 0!==l?l:0)+1):f=0,this.setTransition({id:h,targetPageId:f,source:r,restoredState:s,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:i,resolve:c,reject:u,promise:d,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),d.catch(p=>Promise.reject(p))}setBrowserUrl(e,r){const s=this.urlSerializer.serialize(e),i=Object.assign(Object.assign({},r.extras.state),this.generateNgRouterState(r.id,r.targetPageId));this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl?this.location.replaceState(s,"",i):this.location.go(s,"",i)}restoreHistory(e,r=!1){var s,i;if("computed"===this.canceledNavigationResolution){const o=this.currentPageId-e.targetPageId;"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy&&this.currentUrlTree!==(null===(s=this.currentNavigation)||void 0===s?void 0:s.finalUrl)||0===o?this.currentUrlTree===(null===(i=this.currentNavigation)||void 0===i?void 0:i.finalUrl)&&0===o&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(o)}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,r){const s=new jO(e.id,this.serializeUrl(e.extractedUrl),r);this.triggerEvent(s),e.resolve(!1)}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return n.\u0275fac=function(e){hm()},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();function LF(n){return"imperative"!==n}class VF{}class BF{preload(t,e){return it(null)}}let zF=(()=>{class n{constructor(e,r,s,i){this.router=e,this.injector=s,this.preloadingStrategy=i,this.loader=new PF(s,r,l=>e.triggerEvent(new WO(l)),l=>e.triggerEvent(new GO(l)))}setUpPreloading(){this.subscription=this.router.events.pipe(ur(e=>e instanceof dh),nu(()=>this.preload())).subscribe(()=>{})}preload(){const e=this.injector.get(Fo);return this.processRoutes(e,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const s=[];for(const i of r)if(i.loadChildren&&!i.canLoad&&i._loadedConfig){const o=i._loadedConfig;s.push(this.processRoutes(o.module,o.routes))}else i.loadChildren&&!i.canLoad?s.push(this.preloadConfig(e,i)):i.children&&s.push(this.processRoutes(e,i.children));return Ar(s).pipe(rd(),Et(i=>{}))}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>(r._loadedConfig?it(r._loadedConfig):this.loader.load(e.injector,r)).pipe(ir(i=>(r._loadedConfig=i,this.processRoutes(i.module,i.routes)))))}}return n.\u0275fac=function(e){return new(e||n)(ee($s),ee(hR),ee(Tn),ee(VF))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})(),Uw=(()=>{class n{constructor(e,r,s={}){this.router=e,this.viewportScroller=r,this.options=s,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},s.scrollPositionRestoration=s.scrollPositionRestoration||"disabled",s.anchorScrolling=s.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof Dw?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof dh&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof qO&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.router.triggerEvent(new qO(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return n.\u0275fac=function(e){hm()},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();const Il=new Fe("ROUTER_CONFIGURATION"),UF=new Fe("ROUTER_FORROOT_GUARD"),OQ=[Kd,{provide:rF,useClass:sF},{provide:$s,useFactory:function VQ(n,t,e,r,s,i,o={},a,l){const c=new $s(null,n,t,e,r,s,YO(i));return a&&(c.urlHandlingStrategy=a),l&&(c.routeReuseStrategy=l),function BQ(n,t){n.errorHandler&&(t.errorHandler=n.errorHandler),n.malformedUriErrorHandler&&(t.malformedUriErrorHandler=n.malformedUriErrorHandler),n.onSameUrlNavigation&&(t.onSameUrlNavigation=n.onSameUrlNavigation),n.paramsInheritanceStrategy&&(t.paramsInheritanceStrategy=n.paramsInheritanceStrategy),n.relativeLinkResolution&&(t.relativeLinkResolution=n.relativeLinkResolution),n.urlUpdateStrategy&&(t.urlUpdateStrategy=n.urlUpdateStrategy),n.canceledNavigationResolution&&(t.canceledNavigationResolution=n.canceledNavigationResolution)}(o,c),o.enableTracing&&c.events.subscribe(u=>{var d,h;null===(d=console.group)||void 0===d||d.call(console,`Router Event: ${u.constructor.name}`),console.log(u.toString()),console.log(u),null===(h=console.groupEnd)||void 0===h||h.call(console)}),c},deps:[rF,_h,Kd,Tn,hR,Vw,Il,[class DQ{},new Si],[class xQ{},new Si]]},_h,{provide:ou,useFactory:function zQ(n){return n.routerState.root},deps:[$s]},zF,BF,class MQ{preload(t,e){return e().pipe(zo(()=>it(null)))}},{provide:Il,useValue:{enableTracing:!1}}];function FQ(){return new gR("Router",$s)}let HF=(()=>{class n{constructor(e,r){}static forRoot(e,r){return{ngModule:n,providers:[OQ,jF(e),{provide:UF,useFactory:LQ,deps:[[$s,new Si,new bc]]},{provide:Il,useValue:r||{}},{provide:Yc,useFactory:$Q,deps:[fl,[new Xp(px),new Si],Il]},{provide:Uw,useFactory:PQ,deps:[$s,DK,Il]},{provide:VF,useExisting:r&&r.preloadingStrategy?r.preloadingStrategy:BF},{provide:gR,multi:!0,useFactory:FQ},[Hw,{provide:J0,multi:!0,useFactory:UQ,deps:[Hw]},{provide:WF,useFactory:HQ,deps:[Hw]},{provide:dR,multi:!0,useExisting:WF}]]}}static forChild(e){return{ngModule:n,providers:[jF(e)]}}}return n.\u0275fac=function(e){return new(e||n)(ee(UF,8),ee($s,8))},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({}),n})();function PQ(n,t,e){return e.scrollOffset&&t.setOffset(e.scrollOffset),new Uw(n,t,e)}function $Q(n,t,e={}){return e.useHash?new s5(n,t):new FR(n,t)}function LQ(n){return"guarded"}function jF(n){return[{provide:VH,multi:!0,useValue:n},{provide:Vw,multi:!0,useValue:n}]}let Hw=(()=>{class n{constructor(e){this.injector=e,this.initNavigation=!1,this.destroyed=!1,this.resultOfPreactivationDone=new Ge}appInitializer(){return this.injector.get(t5,Promise.resolve(null)).then(()=>{if(this.destroyed)return Promise.resolve(!0);let r=null;const s=new Promise(a=>r=a),i=this.injector.get($s),o=this.injector.get(Il);return"disabled"===o.initialNavigation?(i.setUpLocationChangeListener(),r(!0)):"enabled"===o.initialNavigation||"enabledBlocking"===o.initialNavigation?(i.hooks.afterPreactivation=()=>this.initNavigation?it(null):(this.initNavigation=!0,r(!0),this.resultOfPreactivationDone),i.initialNavigation()):r(!0),s})}bootstrapListener(e){const r=this.injector.get(Il),s=this.injector.get(zF),i=this.injector.get(Uw),o=this.injector.get($s),a=this.injector.get(Nm);e===a.components[0]&&(("enabledNonBlocking"===r.initialNavigation||void 0===r.initialNavigation)&&o.initialNavigation(),s.setUpPreloading(),i.init(),o.resetRootComponentType(a.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}ngOnDestroy(){this.destroyed=!0}}return n.\u0275fac=function(e){return new(e||n)(ee(Tn))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();function UQ(n){return n.appInitializer.bind(n)}function HQ(n){return n.bootstrapListener.bind(n)}const WF=new Fe("Router Initializer"),WQ=[];let GQ=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({imports:[[HF.forRoot(WQ)],HF]}),n})(),qQ=(()=>{class n{create(e){return"undefined"==typeof MutationObserver?null:new MutationObserver(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),KQ=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({providers:[qQ]}),n})(),jw=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({imports:[[Wm,fr,KQ],fr]}),n})(),GF=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({}),n})(),JQ=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({providers:[WY],imports:[[GF,jw,fr],GF,jw]}),n})(),eJ=(()=>{class n{constructor(){this.OpenEvent=new Bt}ngOnInit(){}openSideBar(){this.OpenEvent.emit(!0)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Wn({type:n,selectors:[["app-header"]],outputs:{OpenEvent:"OpenEvent"},decls:8,vars:0,consts:[[1,"button",3,"click"],[1,"title"],[1,"example-spacer"],[1,"button"],["href","https://www.linkedin.com/in/younes-boutiyarzist-68a124197/","target","_blank"],["src","../../assets/image/linkedin.png",1,"logo"]],template:function(e,r){1&e&&(Re(0,"mat-toolbar")(1,"button",0),Dr("click",function(){return r.openSideBar()}),Re(2,"span",1),nt(3,"Portfolio"),Be()(),hn(4,"span",2),Re(5,"button",3)(6,"a",4),hn(7,"img",5),Be()()())},directives:[r9],styles:[".example-spacer[_ngcontent-%COMP%]{flex:1 1 auto}.button[_ngcontent-%COMP%]{background-color:#212121;border:0;padding:5px 9px;transition-duration:.4s}.title[_ngcontent-%COMP%]{font-size:1.5em;font-weight:500;color:#fff;margin:5px 0;padding:0;font-weight:700}.button[_ngcontent-%COMP%]:hover{background-color:#323232;color:#fff}.button[_ngcontent-%COMP%]:active{background-color:#323232;transform:translateY(4px)}.logo[_ngcontent-%COMP%]{width:30px;height:auto}.example-container[_ngcontent-%COMP%]{width:400px;height:200px;margin:12px;border:1px solid #555}mat-drawer-content[_ngcontent-%COMP%]{padding:12px;display:flex;flex-direction:column;align-items:flex-start}"]}),n})();const tJ=["addListener","removeListener"],nJ=["addEventListener","removeEventListener"],rJ=["on","off"];function wh(n,t,e,r){if(de(e)&&(r=e,e=void 0),r)return wh(n,t,e).pipe(vw(r));const[s,i]=function oJ(n){return de(n.addEventListener)&&de(n.removeEventListener)}(n)?nJ.map(o=>a=>n[o](t,a,e)):function sJ(n){return de(n.addListener)&&de(n.removeListener)}(n)?tJ.map(qF(n,t)):function iJ(n){return de(n.on)&&de(n.off)}(n)?rJ.map(qF(n,t)):[];if(!s&&Ov(n))return ir(o=>wh(o,t,e))(Ds(n));if(!s)throw new TypeError("Invalid event target");return new ct(o=>{const a=(...l)=>o.next(1<l.length?l:l[0]);return s(a),()=>i(a)})}function qF(n,t){return e=>r=>n[e](t,r)}class aJ extends x{constructor(t,e){super()}schedule(t,e=0){return this}}const Lg={setInterval(n,t,...e){const{delegate:r}=Lg;return(null==r?void 0:r.setInterval)?r.setInterval(n,t,...e):setInterval(n,t,...e)},clearInterval(n){const{delegate:t}=Lg;return((null==t?void 0:t.clearInterval)||clearInterval)(n)},delegate:void 0};class Ww extends aJ{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){if(this.closed)return this;this.state=t;const r=this.id,s=this.scheduler;return null!=r&&(this.id=this.recycleAsyncId(s,r,e)),this.pending=!0,this.delay=e,this.id=this.id||this.requestAsyncId(s,this.id,e),this}requestAsyncId(t,e,r=0){return Lg.setInterval(t.flush.bind(t,this),r)}recycleAsyncId(t,e,r=0){if(null!=r&&this.delay===r&&!1===this.pending)return e;Lg.clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const r=this._execute(t,e);if(r)return r;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let s,r=!1;try{this.work(t)}catch(i){r=!0,s=i||new Error("Scheduled action threw falsy error")}if(r)return this.unsubscribe(),s}unsubscribe(){if(!this.closed){const{id:t,scheduler:e}=this,{actions:r}=e;this.work=this.state=this.scheduler=null,this.pending=!1,B(r,this),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null,super.unsubscribe()}}}const Ch={schedule(n){let t=requestAnimationFrame,e=cancelAnimationFrame;const{delegate:r}=Ch;r&&(t=r.requestAnimationFrame,e=r.cancelAnimationFrame);const s=t(i=>{e=void 0,n(i)});return new x(()=>null==e?void 0:e(s))},requestAnimationFrame(...n){const{delegate:t}=Ch;return((null==t?void 0:t.requestAnimationFrame)||requestAnimationFrame)(...n)},cancelAnimationFrame(...n){const{delegate:t}=Ch;return((null==t?void 0:t.cancelAnimationFrame)||cancelAnimationFrame)(...n)},delegate:void 0},KF={now:()=>(KF.delegate||Date).now(),delegate:void 0};class Dh{constructor(t,e=Dh.now){this.schedulerActionCtor=t,this.now=e}schedule(t,e=0,r){return new this.schedulerActionCtor(this,t).schedule(r,e)}}Dh.now=KF.now;class Gw extends Dh{constructor(t,e=Dh.now){super(t,e),this.actions=[],this._active=!1,this._scheduled=void 0}flush(t){const{actions:e}=this;if(this._active)return void e.push(t);let r;this._active=!0;do{if(r=t.execute(t.state,t.delay))break}while(t=e.shift());if(this._active=!1,r){for(;t=e.shift();)t.unsubscribe();throw r}}}const XF=new class cJ extends Gw{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class lJ extends Ww{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=Ch.requestAnimationFrame(()=>t.flush(void 0))))}recycleAsyncId(t,e,r=0){if(null!=r&&r>0||null==r&&this.delay>0)return super.recycleAsyncId(t,e,r);t.actions.some(s=>s.id===e)||(Ch.cancelAnimationFrame(e),t._scheduled=void 0)}});let qw,uJ=1;const Vg={};function YF(n){return n in Vg&&(delete Vg[n],!0)}const dJ={setImmediate(n){const t=uJ++;return Vg[t]=!0,qw||(qw=Promise.resolve()),qw.then(()=>YF(t)&&n()),t},clearImmediate(n){YF(n)}},{setImmediate:hJ,clearImmediate:fJ}=dJ,Bg={setImmediate(...n){const{delegate:t}=Bg;return((null==t?void 0:t.setImmediate)||hJ)(...n)},clearImmediate(n){const{delegate:t}=Bg;return((null==t?void 0:t.clearImmediate)||fJ)(n)},delegate:void 0},gJ=new class mJ extends Gw{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class pJ extends Ww{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=Bg.setImmediate(t.flush.bind(t,void 0))))}recycleAsyncId(t,e,r=0){if(null!=r&&r>0||null==r&&this.delay>0)return super.recycleAsyncId(t,e,r);t.actions.some(s=>s.id===e)||(Bg.clearImmediate(e),t._scheduled=void 0)}}),zg=new Gw(Ww),yJ=zg;function ZF(n=0,t,e=yJ){let r=-1;return null!=t&&(YI(t)?e=t:r=t),new ct(s=>{let i=function vJ(n){return n instanceof Date&&!isNaN(n)}(n)?+n-e.now():n;i<0&&(i=0);let o=0;return e.schedule(function(){s.closed||(s.next(o++),0<=r?this.schedule(void 0,r):s.complete())},i)})}function Kw(n,t=zg){return function _J(n){return jn((t,e)=>{let r=!1,s=null,i=null,o=!1;const a=()=>{if(null==i||i.unsubscribe(),i=null,r){r=!1;const c=s;s=null,e.next(c)}o&&e.complete()},l=()=>{i=null,o&&e.complete()};t.subscribe(In(e,c=>{r=!0,s=c,i||Ds(n(c)).subscribe(i=In(e,a,l))},()=>{o=!0,(!r||!i||i.closed)&&e.complete()}))})}(()=>ZF(n,t))}const bJ=["contentWrapper"],xJ=["*"],QF=new Fe("VIRTUAL_SCROLL_STRATEGY");class wJ{constructor(t,e,r){this._scrolledIndexChange=new Ge,this.scrolledIndexChange=this._scrolledIndexChange.pipe(Bx()),this._viewport=null,this._itemSize=t,this._minBufferPx=e,this._maxBufferPx=r}attach(t){this._viewport=t,this._updateTotalContentSize(),this._updateRenderedRange()}detach(){this._scrolledIndexChange.complete(),this._viewport=null}updateItemAndBufferSize(t,e,r){this._itemSize=t,this._minBufferPx=e,this._maxBufferPx=r,this._updateTotalContentSize(),this._updateRenderedRange()}onContentScrolled(){this._updateRenderedRange()}onDataLengthChanged(){this._updateTotalContentSize(),this._updateRenderedRange()}onContentRendered(){}onRenderedOffsetChanged(){}scrollToIndex(t,e){this._viewport&&this._viewport.scrollToOffset(t*this._itemSize,e)}_updateTotalContentSize(){!this._viewport||this._viewport.setTotalContentSize(this._viewport.getDataLength()*this._itemSize)}_updateRenderedRange(){if(!this._viewport)return;const t=this._viewport.getRenderedRange(),e={start:t.start,end:t.end},r=this._viewport.getViewportSize(),s=this._viewport.getDataLength();let i=this._viewport.measureScrollOffset(),o=this._itemSize>0?i/this._itemSize:0;if(e.end>s){const l=Math.ceil(r/this._itemSize),c=Math.max(0,Math.min(o,s-l));o!=c&&(o=c,i=c*this._itemSize,e.start=Math.floor(o)),e.end=Math.max(0,Math.min(s,e.start+l))}const a=i-e.start*this._itemSize;if(a<this._minBufferPx&&0!=e.start){const l=Math.ceil((this._maxBufferPx-a)/this._itemSize);e.start=Math.max(0,e.start-l),e.end=Math.min(s,Math.ceil(o+(r+this._minBufferPx)/this._itemSize))}else{const l=e.end*this._itemSize-(i+r);if(l<this._minBufferPx&&e.end!=s){const c=Math.ceil((this._maxBufferPx-l)/this._itemSize);c>0&&(e.end=Math.min(s,e.end+c),e.start=Math.max(0,Math.floor(o-this._minBufferPx/this._itemSize)))}}this._viewport.setRenderedRange(e),this._viewport.setRenderedContentOffset(this._itemSize*e.start),this._scrolledIndexChange.next(Math.floor(o))}}function CJ(n){return n._scrollStrategy}let DJ=(()=>{class n{constructor(){this._itemSize=20,this._minBufferPx=100,this._maxBufferPx=200,this._scrollStrategy=new wJ(this.itemSize,this.minBufferPx,this.maxBufferPx)}get itemSize(){return this._itemSize}set itemSize(e){this._itemSize=nh(e)}get minBufferPx(){return this._minBufferPx}set minBufferPx(e){this._minBufferPx=nh(e)}get maxBufferPx(){return this._maxBufferPx}set maxBufferPx(e){this._maxBufferPx=nh(e)}ngOnChanges(){this._scrollStrategy.updateItemAndBufferSize(this.itemSize,this.minBufferPx,this.maxBufferPx)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=un({type:n,selectors:[["cdk-virtual-scroll-viewport","itemSize",""]],inputs:{itemSize:"itemSize",minBufferPx:"minBufferPx",maxBufferPx:"maxBufferPx"},features:[pa([{provide:QF,useFactory:CJ,deps:[od(()=>n)]}]),ko]}),n})(),Sh=(()=>{class n{constructor(e,r,s){this._ngZone=e,this._platform=r,this._scrolled=new Ge,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=s}register(e){this.scrollContainers.has(e)||this.scrollContainers.set(e,e.elementScrolled().subscribe(()=>this._scrolled.next(e)))}deregister(e){const r=this.scrollContainers.get(e);r&&(r.unsubscribe(),this.scrollContainers.delete(e))}scrolled(e=20){return this._platform.isBrowser?new ct(r=>{this._globalSubscription||this._addGlobalListener();const s=e>0?this._scrolled.pipe(Kw(e)).subscribe(r):this._scrolled.subscribe(r);return this._scrolledCount++,()=>{s.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):it()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((e,r)=>this.deregister(r)),this._scrolled.complete()}ancestorScrolled(e,r){const s=this.getAncestorScrollContainers(e);return this.scrolled(r).pipe(ur(i=>!i||s.indexOf(i)>-1))}getAncestorScrollContainers(e){const r=[];return this.scrollContainers.forEach((s,i)=>{this._scrollableContainsElement(i,e)&&r.push(i)}),r}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(e,r){let s=hr(r),i=e.getElementRef().nativeElement;do{if(s==i)return!0}while(s=s.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>wh(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return n.\u0275fac=function(e){return new(e||n)(ee(Ct),ee(ys),ee(_t,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Eh=(()=>{class n{constructor(e,r,s,i){this.elementRef=e,this.scrollDispatcher=r,this.ngZone=s,this.dir=i,this._destroyed=new Ge,this._elementScrolled=new ct(o=>this.ngZone.runOutsideAngular(()=>wh(this.elementRef.nativeElement,"scroll").pipe(dr(this._destroyed)).subscribe(o)))}ngOnInit(){this.scrollDispatcher.register(this)}ngOnDestroy(){this.scrollDispatcher.deregister(this),this._destroyed.next(),this._destroyed.complete()}elementScrolled(){return this._elementScrolled}getElementRef(){return this.elementRef}scrollTo(e){const r=this.elementRef.nativeElement,s=this.dir&&"rtl"==this.dir.value;null==e.left&&(e.left=s?e.end:e.start),null==e.right&&(e.right=s?e.start:e.end),null!=e.bottom&&(e.top=r.scrollHeight-r.clientHeight-e.bottom),s&&0!=th()?(null!=e.left&&(e.right=r.scrollWidth-r.clientWidth-e.left),2==th()?e.left=e.right:1==th()&&(e.left=e.right?-e.right:e.right)):null!=e.right&&(e.left=r.scrollWidth-r.clientWidth-e.right),this._applyScrollToOptions(e)}_applyScrollToOptions(e){const r=this.elementRef.nativeElement;mM()?r.scrollTo(e):(null!=e.top&&(r.scrollTop=e.top),null!=e.left&&(r.scrollLeft=e.left))}measureScrollOffset(e){const r="left",s="right",i=this.elementRef.nativeElement;if("top"==e)return i.scrollTop;if("bottom"==e)return i.scrollHeight-i.clientHeight-i.scrollTop;const o=this.dir&&"rtl"==this.dir.value;return"start"==e?e=o?s:r:"end"==e&&(e=o?r:s),o&&2==th()?e==r?i.scrollWidth-i.clientWidth-i.scrollLeft:i.scrollLeft:o&&1==th()?e==r?i.scrollLeft+i.scrollWidth-i.clientWidth:-i.scrollLeft:e==r?i.scrollLeft:i.scrollWidth-i.clientWidth-i.scrollLeft}}return n.\u0275fac=function(e){return new(e||n)(oe(Cn),oe(Sh),oe(Ct),oe(ya,8))},n.\u0275dir=un({type:n,selectors:[["","cdk-scrollable",""],["","cdkScrollable",""]]}),n})(),Ih=(()=>{class n{constructor(e,r,s){this._platform=e,this._change=new Ge,this._changeListener=i=>{this._change.next(i)},this._document=s,r.runOutsideAngular(()=>{if(e.isBrowser){const i=this._getWindow();i.addEventListener("resize",this._changeListener),i.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._viewportSize=null)})}ngOnDestroy(){if(this._platform.isBrowser){const e=this._getWindow();e.removeEventListener("resize",this._changeListener),e.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const e={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),e}getViewportRect(){const e=this.getViewportScrollPosition(),{width:r,height:s}=this.getViewportSize();return{top:e.top,left:e.left,bottom:e.top+s,right:e.left+r,height:s,width:r}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const e=this._document,r=this._getWindow(),s=e.documentElement,i=s.getBoundingClientRect();return{top:-i.top||e.body.scrollTop||r.scrollY||s.scrollTop||0,left:-i.left||e.body.scrollLeft||r.scrollX||s.scrollLeft||0}}change(e=20){return e>0?this._change.pipe(Kw(e)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const e=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:e.innerWidth,height:e.innerHeight}:{width:0,height:0}}}return n.\u0275fac=function(e){return new(e||n)(ee(ys),ee(Ct),ee(_t,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const TJ="undefined"!=typeof requestAnimationFrame?XF:gJ;let kJ=(()=>{class n extends Eh{constructor(e,r,s,i,o,a,l){super(e,a,s,o),this.elementRef=e,this._changeDetectorRef=r,this._scrollStrategy=i,this._detachedSubject=new Ge,this._renderedRangeSubject=new Ge,this._orientation="vertical",this._appendOnly=!1,this.scrolledIndexChange=new ct(c=>this._scrollStrategy.scrolledIndexChange.subscribe(u=>Promise.resolve().then(()=>this.ngZone.run(()=>c.next(u))))),this.renderedRangeStream=this._renderedRangeSubject,this._totalContentSize=0,this._totalContentWidth="",this._totalContentHeight="",this._renderedRange={start:0,end:0},this._dataLength=0,this._viewportSize=0,this._renderedContentOffset=0,this._renderedContentOffsetNeedsRewrite=!1,this._isChangeDetectionPending=!1,this._runAfterChangeDetection=[],this._viewportChanges=x.EMPTY,this._viewportChanges=l.change().subscribe(()=>{this.checkViewportSize()})}get orientation(){return this._orientation}set orientation(e){this._orientation!==e&&(this._orientation=e,this._calculateSpacerSize())}get appendOnly(){return this._appendOnly}set appendOnly(e){this._appendOnly=Rr(e)}ngOnInit(){super.ngOnInit(),this.ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>{this._measureViewportSize(),this._scrollStrategy.attach(this),this.elementScrolled().pipe(Uo(null),Kw(0,TJ)).subscribe(()=>this._scrollStrategy.onContentScrolled()),this._markChangeDetectionNeeded()}))}ngOnDestroy(){this.detach(),this._scrollStrategy.detach(),this._renderedRangeSubject.complete(),this._detachedSubject.complete(),this._viewportChanges.unsubscribe(),super.ngOnDestroy()}attach(e){this.ngZone.runOutsideAngular(()=>{this._forOf=e,this._forOf.dataStream.pipe(dr(this._detachedSubject)).subscribe(r=>{const s=r.length;s!==this._dataLength&&(this._dataLength=s,this._scrollStrategy.onDataLengthChanged()),this._doChangeDetection()})})}detach(){this._forOf=null,this._detachedSubject.next()}getDataLength(){return this._dataLength}getViewportSize(){return this._viewportSize}getRenderedRange(){return this._renderedRange}setTotalContentSize(e){this._totalContentSize!==e&&(this._totalContentSize=e,this._calculateSpacerSize(),this._markChangeDetectionNeeded())}setRenderedRange(e){(function IJ(n,t){return n.start==t.start&&n.end==t.end})(this._renderedRange,e)||(this.appendOnly&&(e={start:0,end:Math.max(this._renderedRange.end,e.end)}),this._renderedRangeSubject.next(this._renderedRange=e),this._markChangeDetectionNeeded(()=>this._scrollStrategy.onContentRendered()))}getOffsetToRenderedContentStart(){return this._renderedContentOffsetNeedsRewrite?null:this._renderedContentOffset}setRenderedContentOffset(e,r="to-start"){const i="horizontal"==this.orientation,o=i?"X":"Y";let l=`translate${o}(${Number((i&&this.dir&&"rtl"==this.dir.value?-1:1)*e)}px)`;this._renderedContentOffset=e=this.appendOnly&&"to-start"===r?0:e,"to-end"===r&&(l+=` translate${o}(-100%)`,this._renderedContentOffsetNeedsRewrite=!0),this._renderedContentTransform!=l&&(this._renderedContentTransform=l,this._markChangeDetectionNeeded(()=>{this._renderedContentOffsetNeedsRewrite?(this._renderedContentOffset-=this.measureRenderedContentSize(),this._renderedContentOffsetNeedsRewrite=!1,this.setRenderedContentOffset(this._renderedContentOffset)):this._scrollStrategy.onRenderedOffsetChanged()}))}scrollToOffset(e,r="auto"){const s={behavior:r};"horizontal"===this.orientation?s.start=e:s.top=e,this.scrollTo(s)}scrollToIndex(e,r="auto"){this._scrollStrategy.scrollToIndex(e,r)}measureScrollOffset(e){return super.measureScrollOffset(e||("horizontal"===this.orientation?"start":"top"))}measureRenderedContentSize(){const e=this._contentWrapper.nativeElement;return"horizontal"===this.orientation?e.offsetWidth:e.offsetHeight}measureRangeSize(e){return this._forOf?this._forOf.measureRangeSize(e,this.orientation):0}checkViewportSize(){this._measureViewportSize(),this._scrollStrategy.onDataLengthChanged()}_measureViewportSize(){const e=this.elementRef.nativeElement;this._viewportSize="horizontal"===this.orientation?e.clientWidth:e.clientHeight}_markChangeDetectionNeeded(e){e&&this._runAfterChangeDetection.push(e),this._isChangeDetectionPending||(this._isChangeDetectionPending=!0,this.ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>{this._doChangeDetection()})))}_doChangeDetection(){this._isChangeDetectionPending=!1,this._contentWrapper.nativeElement.style.transform=this._renderedContentTransform,this.ngZone.run(()=>this._changeDetectorRef.markForCheck());const e=this._runAfterChangeDetection;this._runAfterChangeDetection=[];for(const r of e)r()}_calculateSpacerSize(){this._totalContentHeight="horizontal"===this.orientation?"":`${this._totalContentSize}px`,this._totalContentWidth="horizontal"===this.orientation?`${this._totalContentSize}px`:""}}return n.\u0275fac=function(e){return new(e||n)(oe(Cn),oe(oo),oe(Ct),oe(QF,8),oe(ya,8),oe(Sh),oe(Ih))},n.\u0275cmp=Wn({type:n,selectors:[["cdk-virtual-scroll-viewport"]],viewQuery:function(e,r){if(1&e&&dl(bJ,7),2&e){let s;rs(s=ss())&&(r._contentWrapper=s.first)}},hostAttrs:[1,"cdk-virtual-scroll-viewport"],hostVars:4,hostBindings:function(e,r){2&e&&ms("cdk-virtual-scroll-orientation-horizontal","horizontal"===r.orientation)("cdk-virtual-scroll-orientation-vertical","horizontal"!==r.orientation)},inputs:{orientation:"orientation",appendOnly:"appendOnly"},outputs:{scrolledIndexChange:"scrolledIndexChange"},features:[pa([{provide:Eh,useExisting:n}]),ki],ngContentSelectors:xJ,decls:4,vars:4,consts:[[1,"cdk-virtual-scroll-content-wrapper"],["contentWrapper",""],[1,"cdk-virtual-scroll-spacer"]],template:function(e,r){1&e&&(fa(),Re(0,"div",0,1),Ni(2),Be(),hn(3,"div",2)),2&e&&(Yn(3),pm("width",r._totalContentWidth)("height",r._totalContentHeight))},styles:["cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\n"],encapsulation:2,changeDetection:0}),n})(),Th=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({}),n})(),Xw=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({imports:[[Jd,Th],Jd,Th]}),n})();function JF(n){return Et(()=>n)}function eP(n,t=zg){return jn((e,r)=>{let s=null,i=null,o=null;const a=()=>{if(s){s.unsubscribe(),s=null;const c=i;i=null,r.next(c)}};function l(){const c=o+n,u=t.now();if(u<c)return s=this.schedule(void 0,c-u),void r.add(s);a()}e.subscribe(In(r,c=>{i=c,o=t.now(),s||(s=t.schedule(l,n),r.add(s))},()=>{a(),r.complete()},void 0,()=>{i=s=null}))})}const tP=["*"],NJ=["content"];function AJ(n,t){if(1&n){const e=Uc();Re(0,"div",2),Dr("click",function(){return No(e),ha()._onBackdropClicked()}),Be()}2&n&&ms("mat-drawer-shown",ha()._isShowingBackdrop())}function RJ(n,t){1&n&&(Re(0,"mat-drawer-content"),Ni(1,2),Be())}const MJ=[[["mat-drawer"]],[["mat-drawer-content"]],"*"],OJ=["mat-drawer","mat-drawer-content","*"],FJ={transformDrawer:Jm("transform",[yl("open, open-instant",Os({transform:"none",visibility:"visible"})),yl("void",Os({"box-shadow":"none",visibility:"hidden"})),_l("void => open-instant",gl("0ms")),_l("void <=> open, open-instant => void",gl("400ms cubic-bezier(0.25, 0.8, 0.25, 1)"))])},PJ=new Fe("MAT_DRAWER_DEFAULT_AUTOSIZE",{providedIn:"root",factory:function $J(){return!1}}),nP=new Fe("MAT_DRAWER_CONTAINER");let Ug=(()=>{class n extends Eh{constructor(e,r,s,i,o){super(s,i,o),this._changeDetectorRef=e,this._container=r}ngAfterContentInit(){this._container._contentMarginChanges.subscribe(()=>{this._changeDetectorRef.markForCheck()})}}return n.\u0275fac=function(e){return new(e||n)(oe(oo),oe(od(()=>sP)),oe(Cn),oe(Sh),oe(Ct))},n.\u0275cmp=Wn({type:n,selectors:[["mat-drawer-content"]],hostAttrs:[1,"mat-drawer-content"],hostVars:4,hostBindings:function(e,r){2&e&&pm("margin-left",r._container._contentMargins.left,"px")("margin-right",r._container._contentMargins.right,"px")},features:[pa([{provide:Eh,useExisting:n}]),ki],ngContentSelectors:tP,decls:1,vars:0,template:function(e,r){1&e&&(fa(),Ni(0))},encapsulation:2,changeDetection:0}),n})(),rP=(()=>{class n{constructor(e,r,s,i,o,a,l,c){this._elementRef=e,this._focusTrapFactory=r,this._focusMonitor=s,this._platform=i,this._ngZone=o,this._interactivityChecker=a,this._doc=l,this._container=c,this._elementFocusedBeforeDrawerWasOpened=null,this._enableAnimations=!1,this._position="start",this._mode="over",this._disableClose=!1,this._opened=!1,this._animationStarted=new Ge,this._animationEnd=new Ge,this._animationState="void",this.openedChange=new Bt(!0),this._openedStream=this.openedChange.pipe(ur(u=>u),Et(()=>{})),this.openedStart=this._animationStarted.pipe(ur(u=>u.fromState!==u.toState&&0===u.toState.indexOf("open")),JF(void 0)),this._closedStream=this.openedChange.pipe(ur(u=>!u),Et(()=>{})),this.closedStart=this._animationStarted.pipe(ur(u=>u.fromState!==u.toState&&"void"===u.toState),JF(void 0)),this._destroyed=new Ge,this.onPositionChanged=new Bt,this._modeChanged=new Ge,this.openedChange.subscribe(u=>{u?(this._doc&&(this._elementFocusedBeforeDrawerWasOpened=this._doc.activeElement),this._takeFocus()):this._isFocusWithinDrawer()&&this._restoreFocus(this._openedVia||"program")}),this._ngZone.runOutsideAngular(()=>{wh(this._elementRef.nativeElement,"keydown").pipe(ur(u=>27===u.keyCode&&!this.disableClose&&!yM(u)),dr(this._destroyed)).subscribe(u=>this._ngZone.run(()=>{this.close(),u.stopPropagation(),u.preventDefault()}))}),this._animationEnd.pipe(Bx((u,d)=>u.fromState===d.fromState&&u.toState===d.toState)).subscribe(u=>{const{fromState:d,toState:h}=u;(0===h.indexOf("open")&&"void"===d||"void"===h&&0===d.indexOf("open"))&&this.openedChange.emit(this._opened)})}get position(){return this._position}set position(e){(e="end"===e?"end":"start")!==this._position&&(this._isAttached&&this._updatePositionInParent(e),this._position=e,this.onPositionChanged.emit())}get mode(){return this._mode}set mode(e){this._mode=e,this._updateFocusTrapState(),this._modeChanged.next()}get disableClose(){return this._disableClose}set disableClose(e){this._disableClose=Rr(e)}get autoFocus(){const e=this._autoFocus;return null==e?"side"===this.mode?"dialog":"first-tabbable":e}set autoFocus(e){("true"===e||"false"===e||null==e)&&(e=Rr(e)),this._autoFocus=e}get opened(){return this._opened}set opened(e){this.toggle(Rr(e))}_forceFocus(e,r){this._interactivityChecker.isFocusable(e)||(e.tabIndex=-1,this._ngZone.runOutsideAngular(()=>{const s=()=>{e.removeEventListener("blur",s),e.removeEventListener("mousedown",s),e.removeAttribute("tabindex")};e.addEventListener("blur",s),e.addEventListener("mousedown",s)})),e.focus(r)}_focusByCssSelector(e,r){let s=this._elementRef.nativeElement.querySelector(e);s&&this._forceFocus(s,r)}_takeFocus(){if(!this._focusTrap)return;const e=this._elementRef.nativeElement;switch(this.autoFocus){case!1:case"dialog":return;case!0:case"first-tabbable":this._focusTrap.focusInitialElementWhenReady().then(r=>{!r&&"function"==typeof this._elementRef.nativeElement.focus&&e.focus()});break;case"first-heading":this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');break;default:this._focusByCssSelector(this.autoFocus)}}_restoreFocus(e){"dialog"!==this.autoFocus&&(this._elementFocusedBeforeDrawerWasOpened?this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened,e):this._elementRef.nativeElement.blur(),this._elementFocusedBeforeDrawerWasOpened=null)}_isFocusWithinDrawer(){const e=this._doc.activeElement;return!!e&&this._elementRef.nativeElement.contains(e)}ngAfterViewInit(){this._isAttached=!0,this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement),this._updateFocusTrapState(),"end"===this._position&&this._updatePositionInParent("end")}ngAfterContentChecked(){this._platform.isBrowser&&(this._enableAnimations=!0)}ngOnDestroy(){var e;this._focusTrap&&this._focusTrap.destroy(),null===(e=this._anchor)||void 0===e||e.remove(),this._anchor=null,this._animationStarted.complete(),this._animationEnd.complete(),this._modeChanged.complete(),this._destroyed.next(),this._destroyed.complete()}open(e){return this.toggle(!0,e)}close(){return this.toggle(!1)}_closeViaBackdropClick(){return this._setOpen(!1,!0,"mouse")}toggle(e=!this.opened,r){e&&r&&(this._openedVia=r);const s=this._setOpen(e,!e&&this._isFocusWithinDrawer(),this._openedVia||"program");return e||(this._openedVia=null),s}_setOpen(e,r,s){return this._opened=e,e?this._animationState=this._enableAnimations?"open":"open-instant":(this._animationState="void",r&&this._restoreFocus(s)),this._updateFocusTrapState(),new Promise(i=>{this.openedChange.pipe(Br(1)).subscribe(o=>i(o?"open":"close"))})}_getWidth(){return this._elementRef.nativeElement&&this._elementRef.nativeElement.offsetWidth||0}_updateFocusTrapState(){this._focusTrap&&(this._focusTrap.enabled=this.opened&&"side"!==this.mode)}_updatePositionInParent(e){const r=this._elementRef.nativeElement,s=r.parentNode;"end"===e?(this._anchor||(this._anchor=this._doc.createComment("mat-drawer-anchor"),s.insertBefore(this._anchor,r)),s.appendChild(r)):this._anchor&&this._anchor.parentNode.insertBefore(r,this._anchor)}}return n.\u0275fac=function(e){return new(e||n)(oe(Cn),oe(CM),oe(jx),oe(ys),oe(Ct),oe(zx),oe(_t,8),oe(nP,8))},n.\u0275cmp=Wn({type:n,selectors:[["mat-drawer"]],viewQuery:function(e,r){if(1&e&&dl(NJ,5),2&e){let s;rs(s=ss())&&(r._content=s.first)}},hostAttrs:["tabIndex","-1",1,"mat-drawer"],hostVars:12,hostBindings:function(e,r){1&e&&Od("@transform.start",function(i){return r._animationStarted.next(i)})("@transform.done",function(i){return r._animationEnd.next(i)}),2&e&&(no("align",null),Pd("@transform",r._animationState),ms("mat-drawer-end","end"===r.position)("mat-drawer-over","over"===r.mode)("mat-drawer-push","push"===r.mode)("mat-drawer-side","side"===r.mode)("mat-drawer-opened",r.opened))},inputs:{position:"position",mode:"mode",disableClose:"disableClose",autoFocus:"autoFocus",opened:"opened"},outputs:{openedChange:"openedChange",_openedStream:"opened",openedStart:"openedStart",_closedStream:"closed",closedStart:"closedStart",onPositionChanged:"positionChanged"},exportAs:["matDrawer"],ngContentSelectors:tP,decls:3,vars:0,consts:[["cdkScrollable","",1,"mat-drawer-inner-container"],["content",""]],template:function(e,r){1&e&&(fa(),Re(0,"div",0,1),Ni(2),Be())},directives:[Eh],encapsulation:2,data:{animation:[FJ.transformDrawer]},changeDetection:0}),n})(),sP=(()=>{class n{constructor(e,r,s,i,o,a=!1,l){this._dir=e,this._element=r,this._ngZone=s,this._changeDetectorRef=i,this._animationMode=l,this._drawers=new Sm,this.backdropClick=new Bt,this._destroyed=new Ge,this._doCheckSubject=new Ge,this._contentMargins={left:null,right:null},this._contentMarginChanges=new Ge,e&&e.change.pipe(dr(this._destroyed)).subscribe(()=>{this._validateDrawers(),this.updateContentMargins()}),o.change().pipe(dr(this._destroyed)).subscribe(()=>this.updateContentMargins()),this._autosize=a}get start(){return this._start}get end(){return this._end}get autosize(){return this._autosize}set autosize(e){this._autosize=Rr(e)}get hasBackdrop(){return null==this._backdropOverride?!this._start||"side"!==this._start.mode||!this._end||"side"!==this._end.mode:this._backdropOverride}set hasBackdrop(e){this._backdropOverride=null==e?null:Rr(e)}get scrollable(){return this._userContent||this._content}ngAfterContentInit(){this._allDrawers.changes.pipe(Uo(this._allDrawers),dr(this._destroyed)).subscribe(e=>{this._drawers.reset(e.filter(r=>!r._container||r._container===this)),this._drawers.notifyOnChanges()}),this._drawers.changes.pipe(Uo(null)).subscribe(()=>{this._validateDrawers(),this._drawers.forEach(e=>{this._watchDrawerToggle(e),this._watchDrawerPosition(e),this._watchDrawerMode(e)}),(!this._drawers.length||this._isDrawerOpen(this._start)||this._isDrawerOpen(this._end))&&this.updateContentMargins(),this._changeDetectorRef.markForCheck()}),this._ngZone.runOutsideAngular(()=>{this._doCheckSubject.pipe(eP(10),dr(this._destroyed)).subscribe(()=>this.updateContentMargins())})}ngOnDestroy(){this._contentMarginChanges.complete(),this._doCheckSubject.complete(),this._drawers.destroy(),this._destroyed.next(),this._destroyed.complete()}open(){this._drawers.forEach(e=>e.open())}close(){this._drawers.forEach(e=>e.close())}updateContentMargins(){let e=0,r=0;if(this._left&&this._left.opened)if("side"==this._left.mode)e+=this._left._getWidth();else if("push"==this._left.mode){const s=this._left._getWidth();e+=s,r-=s}if(this._right&&this._right.opened)if("side"==this._right.mode)r+=this._right._getWidth();else if("push"==this._right.mode){const s=this._right._getWidth();r+=s,e-=s}e=e||null,r=r||null,(e!==this._contentMargins.left||r!==this._contentMargins.right)&&(this._contentMargins={left:e,right:r},this._ngZone.run(()=>this._contentMarginChanges.next(this._contentMargins)))}ngDoCheck(){this._autosize&&this._isPushed()&&this._ngZone.runOutsideAngular(()=>this._doCheckSubject.next())}_watchDrawerToggle(e){e._animationStarted.pipe(ur(r=>r.fromState!==r.toState),dr(this._drawers.changes)).subscribe(r=>{"open-instant"!==r.toState&&"NoopAnimations"!==this._animationMode&&this._element.nativeElement.classList.add("mat-drawer-transition"),this.updateContentMargins(),this._changeDetectorRef.markForCheck()}),"side"!==e.mode&&e.openedChange.pipe(dr(this._drawers.changes)).subscribe(()=>this._setContainerClass(e.opened))}_watchDrawerPosition(e){!e||e.onPositionChanged.pipe(dr(this._drawers.changes)).subscribe(()=>{this._ngZone.onMicrotaskEmpty.pipe(Br(1)).subscribe(()=>{this._validateDrawers()})})}_watchDrawerMode(e){e&&e._modeChanged.pipe(dr(id(this._drawers.changes,this._destroyed))).subscribe(()=>{this.updateContentMargins(),this._changeDetectorRef.markForCheck()})}_setContainerClass(e){const r=this._element.nativeElement.classList,s="mat-drawer-container-has-open";e?r.add(s):r.remove(s)}_validateDrawers(){this._start=this._end=null,this._drawers.forEach(e=>{"end"==e.position?this._end=e:this._start=e}),this._right=this._left=null,this._dir&&"rtl"===this._dir.value?(this._left=this._end,this._right=this._start):(this._left=this._start,this._right=this._end)}_isPushed(){return this._isDrawerOpen(this._start)&&"over"!=this._start.mode||this._isDrawerOpen(this._end)&&"over"!=this._end.mode}_onBackdropClicked(){this.backdropClick.emit(),this._closeModalDrawersViaBackdrop()}_closeModalDrawersViaBackdrop(){[this._start,this._end].filter(e=>e&&!e.disableClose&&this._canHaveBackdrop(e)).forEach(e=>e._closeViaBackdropClick())}_isShowingBackdrop(){return this._isDrawerOpen(this._start)&&this._canHaveBackdrop(this._start)||this._isDrawerOpen(this._end)&&this._canHaveBackdrop(this._end)}_canHaveBackdrop(e){return"side"!==e.mode||!!this._backdropOverride}_isDrawerOpen(e){return null!=e&&e.opened}}return n.\u0275fac=function(e){return new(e||n)(oe(ya,8),oe(Cn),oe(Ct),oe(oo),oe(Ih),oe(PJ),oe(tu,8))},n.\u0275cmp=Wn({type:n,selectors:[["mat-drawer-container"]],contentQueries:function(e,r,s){if(1&e&&(Po(s,Ug,5),Po(s,rP,5)),2&e){let i;rs(i=ss())&&(r._content=i.first),rs(i=ss())&&(r._allDrawers=i)}},viewQuery:function(e,r){if(1&e&&dl(Ug,5),2&e){let s;rs(s=ss())&&(r._userContent=s.first)}},hostAttrs:[1,"mat-drawer-container"],hostVars:2,hostBindings:function(e,r){2&e&&ms("mat-drawer-container-explicit-backdrop",r._backdropOverride)},inputs:{autosize:"autosize",hasBackdrop:"hasBackdrop"},outputs:{backdropClick:"backdropClick"},exportAs:["matDrawerContainer"],features:[pa([{provide:nP,useExisting:n}])],ngContentSelectors:OJ,decls:4,vars:2,consts:[["class","mat-drawer-backdrop",3,"mat-drawer-shown","click",4,"ngIf"],[4,"ngIf"],[1,"mat-drawer-backdrop",3,"click"]],template:function(e,r){1&e&&(fa(MJ),Js(0,AJ,1,2,"div",0),Ni(1),Ni(2,1),Js(3,RJ,2,0,"mat-drawer-content",1)),2&e&&(Cr("ngIf",r.hasBackdrop),Yn(3),Cr("ngIf",!r._content))},directives:[Ug,jm],styles:['.mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer[style*="visibility: hidden"]{display:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\n'],encapsulation:2,changeDetection:0}),n})(),LJ=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({imports:[[Wm,fr,Th],Th,fr]}),n})(),VJ=(()=>{class n{constructor(){this._vertical=!1,this._inset=!1}get vertical(){return this._vertical}set vertical(e){this._vertical=Rr(e)}get inset(){return this._inset}set inset(e){this._inset=Rr(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Wn({type:n,selectors:[["mat-divider"]],hostAttrs:["role","separator",1,"mat-divider"],hostVars:7,hostBindings:function(e,r){2&e&&(no("aria-orientation",r.vertical?"vertical":"horizontal"),ms("mat-divider-vertical",r.vertical)("mat-divider-horizontal",!r.vertical)("mat-divider-inset",r.inset))},inputs:{vertical:"vertical",inset:"inset"},decls:0,vars:0,template:function(e,r){},styles:[".mat-divider{display:block;margin:0;border-top-width:1px;border-top-style:solid}.mat-divider.mat-divider-vertical{border-top:0;border-right-width:1px;border-right-style:solid}.mat-divider.mat-divider-inset{margin-left:80px}[dir=rtl] .mat-divider.mat-divider-inset{margin-left:auto;margin-right:80px}\n"],encapsulation:2,changeDetection:0}),n})(),BJ=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({imports:[[fr],fr]}),n})(),zJ=(()=>{class n{constructor(){this.ClassifEvent=new Bt}ngOnInit(){}openClassif(){this.ClassifEvent.emit(!0)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Wn({type:n,selectors:[["app-home"]],outputs:{ClassifEvent:"ClassifEvent"},decls:83,vars:0,consts:[[1,"container"],[1,"student-info"],[1,"student-name"],["src","../../assets/image/photo.png",1,"circle-image"],[2,"font-weight","bold"],[1,"student-description"],[2,"font-size","1.3em","font-weight","bold"],["href","mailto:younes.boutiyarzist@etu.toulouse-inp.fr","target","_blank"],[1,"projects"],[2,"font-size","1.5em","font-weight","bold"],["href","https://github.com/younesBoutiyarzist/FixMatch","target","_blank"],["href","https://github.com/MystW/Projet_CSI","target","_blank"],["href","https://github.com/amarmeddahi/reflectance-estimation","target","_blank"],[1,"button",3,"click"],[1,"experiences"],[1,"experience"],["src","../../assets/gif/EM.gif",1,"image"],[1,"description"],["src","../../assets/gif/hasting.gif",1,"image"],["src","../../assets/gif/recuit_simule.gif",1,"image"],["src","../../assets/gif/compression.gif",1,"image"],["src","../../assets/gif/restoration.gif",1,"image"],["src","../../assets/gif/RTI.gif",1,"image"],["src","../../assets/image/point_interet.JPG",1,"image"]],template:function(e,r){1&e&&(Re(0,"div",0)(1,"div",1)(2,"div",2),hn(3,"img",3),Re(4,"h2",4),nt(5," Younes Boutiyarzist"),Be()(),Re(6,"div",5)(7,"h3")(8,"div",6),nt(9,"Education:"),Be(),nt(10," \u{1f4bb} MSc computer science at ENSEEIHT, Toulouse, France "),Be(),Re(11,"h3")(12,"div",6),nt(13,"Specialization:"),Be(),nt(14," \u{1f4f7} Image and Multimedia"),Be(),Re(15,"h3")(16,"div",6),nt(17,"Thesis Interests:"),Be(),nt(18," \u{1f52c} Data Processing, Machine Learning, and Deep Learning"),Be(),Re(19,"p"),nt(20,"I am a computer science student with a specialization in Image and Multimedia. I am currently seeking a thesis opportunity in the fields of data processing, machine learning, and deep learning. I have experience in programming languages such as Python and C++ and I am familiar with popular libraries and frameworks such as TensorFlow and OpenCV."),Be(),Re(21,"p"),nt(22,"I am eager to apply my knowledge and skills to real-world problems and I am open to collaboration with researchers and industry professionals. Please feel free to contact me if you have any thesis opportunities or projects that align with my interests."),Be(),Re(23,"p",6),nt(24,"Contact: "),Re(25,"a",7),nt(26,"younes.boutiyarzist@etu.toulouse-inp.fr"),Be()()()(),Re(27,"div",8)(28,"h3",9),nt(29,"Projects"),Be(),Re(30,"ul")(31,"li"),nt(32," Robust Hypersphere Fitting from Noisy Data Using Gibbs Sampling "),Be(),Re(33,"li"),nt(34," Image classification using semi supervised learning : Implementation of FixMatch "),Re(35,"a",10),nt(36,"here"),Be()(),Re(37,"li"),nt(38," Implementation of Progressive Compression for Lossless Transmission of Triangle Meshes "),Re(39,"a",11),nt(40,"here"),Be()(),Re(41,"li"),nt(42," Reflectance estimation with RTI "),Re(43,"a",12),nt(44,"here"),Be()(),Re(45,"li"),nt(46," Web page using Deep neural networks "),Re(47,"button",13),Dr("click",function(){return r.openClassif()}),nt(48," here "),Be()(),Re(49,"li"),nt(50," Other Projects and Results : "),Be()(),Re(51,"div",14)(52,"div",15),hn(53,"img",16),Re(54,"div",17),nt(55," Expectation Maximization on a Gaussian mixture model"),Be()(),Re(56,"div",15),hn(57,"img",18),Re(58,"div",17),nt(59," Metropolis-Hastings Algorithm"),Be()()(),Re(60,"div",14)(61,"div",15),hn(62,"img",19),Re(63,"div",17),nt(64," Segmentation with classification"),Be()(),Re(65,"div",15),hn(66,"img",20),Re(67,"div",17),nt(68," Compression of 3D object"),Be()()(),Re(69,"div",14)(70,"div",15),hn(71,"img",21),Re(72,"div",17),nt(73," restoration with variational methods"),Be()(),Re(74,"div",15),hn(75,"img",22),Re(76,"div",17),nt(77," 3D reconstruction by RTI"),Be()()(),Re(78,"div",14)(79,"div",15),hn(80,"img",23),Re(81,"div",17),nt(82," point of interest with the Harris detector"),Be()()()()())},styles:[".container[_ngcontent-%COMP%]{width:80%;margin:0 auto;padding:20px;border-radius:5px}.student-info[_ngcontent-%COMP%]{display:flex;flex-direction:row;align-items:center;justify-content:space-between}.student-name[_ngcontent-%COMP%]{flex-basis:100%;text-align:center}.student-description[_ngcontent-%COMP%]{flex-basis:100%;text-align:justify}.projects[_ngcontent-%COMP%]{margin-top:10px;padding-bottom:50px}h1[_ngcontent-%COMP%], h2[_ngcontent-%COMP%], h3[_ngcontent-%COMP%]{font-family:Helvetica Neue,sans-serif}.circle-image[_ngcontent-%COMP%]{border-radius:50%;width:300px;height:300px;border:2px solid #333}a[_ngcontent-%COMP%]{color:#fff}li[_ngcontent-%COMP%]{font-size:1.1em;line-height:1.5em}.description[_ngcontent-%COMP%]{padding:4px;font-size:1.3em;line-height:1.5em}.image[_ngcontent-%COMP%]{width:90%;height:90%;object-fit:cover}.experience[_ngcontent-%COMP%]{display:flex;align-items:center;flex-direction:column}.experiences[_ngcontent-%COMP%]{display:flex;align-items:center;flex-direction:row;padding-top:20px;justify-content:space-between}.button[_ngcontent-%COMP%]{border:none;text-align:center;text-decoration:underline;display:inline-block;background-color:transparent;color:#fff;font-size:1em}"]}),n})(),UJ=(()=>{class n{constructor(){}ngOnInit(){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Wn({type:n,selectors:[["app-cv"]],decls:2,vars:0,consts:[["src",m1`../../assets/cv/CV.pdf#toolbar=0&navpanes=0&scrollbar=0`,"type","application/pdf","width","100%","height","100%"],["width","50px","height","50px"]],template:function(e,r){1&e&&hn(0,"embed",0)(1,"div",1)},styles:[""]}),n})();function iP(n,t,e,r,s,i,o){try{var a=n[i](o),l=a.value}catch(c){return void e(c)}a.done?t(l):Promise.resolve(l).then(r,s)}function he(n){return function(){var t=this,e=arguments;return new Promise(function(r,s){var i=n.apply(t,e);function o(l){iP(i,r,s,o,a,"next",l)}function a(l){iP(i,r,s,o,a,"throw",l)}o(void 0)})}}class Yw{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class kh extends Yw{constructor(t,e,r,s){super(),this.component=t,this.viewContainerRef=e,this.injector=r,this.componentFactoryResolver=s}}class Zw extends Yw{constructor(t,e,r){super(),this.templateRef=t,this.viewContainerRef=e,this.context=r}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class HJ extends Yw{constructor(t){super(),this.element=t instanceof Cn?t.nativeElement:t}}class Hg{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof kh?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof Zw?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof HJ?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class jJ extends Hg{constructor(t,e,r,s,i){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=r,this._defaultInjector=s,this.attachDomPortal=o=>{const a=o.element,l=this._document.createComment("dom-portal");a.parentNode.insertBefore(l,a),this.outletElement.appendChild(a),this._attachedPortal=o,super.setDisposeFn(()=>{l.parentNode&&l.parentNode.replaceChild(a,l)})},this._document=i}attachComponentPortal(t){const r=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let s;return t.viewContainerRef?(s=t.viewContainerRef.createComponent(r,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector),this.setDisposeFn(()=>s.destroy())):(s=r.create(t.injector||this._defaultInjector||Tn.NULL),this._appRef.attachView(s.hostView),this.setDisposeFn(()=>{this._appRef.detachView(s.hostView),s.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(s)),this._attachedPortal=t,s}attachTemplatePortal(t){let e=t.viewContainerRef,r=e.createEmbeddedView(t.templateRef,t.context);return r.rootNodes.forEach(s=>this.outletElement.appendChild(s)),r.detectChanges(),this.setDisposeFn(()=>{let s=e.indexOf(r);-1!==s&&e.remove(s)}),this._attachedPortal=t,r}dispose(){super.dispose(),this.outletElement.remove()}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let jg=(()=>{class n extends Hg{constructor(e,r,s){super(),this._componentFactoryResolver=e,this._viewContainerRef=r,this._isInitialized=!1,this.attached=new Bt,this.attachDomPortal=i=>{const o=i.element,a=this._document.createComment("dom-portal");i.setAttachedHost(this),o.parentNode.insertBefore(a,o),this._getRootNode().appendChild(o),this._attachedPortal=i,super.setDisposeFn(()=>{a.parentNode&&a.parentNode.replaceChild(o,a)})},this._document=s}get portal(){return this._attachedPortal}set portal(e){this.hasAttached()&&!e&&!this._isInitialized||(this.hasAttached()&&super.detach(),e&&super.attach(e),this._attachedPortal=e||null)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedPortal=null,this._attachedRef=null}attachComponentPortal(e){e.setAttachedHost(this);const r=null!=e.viewContainerRef?e.viewContainerRef:this._viewContainerRef,i=(e.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(e.component),o=r.createComponent(i,r.length,e.injector||r.injector);return r!==this._viewContainerRef&&this._getRootNode().appendChild(o.hostView.rootNodes[0]),super.setDisposeFn(()=>o.destroy()),this._attachedPortal=e,this._attachedRef=o,this.attached.emit(o),o}attachTemplatePortal(e){e.setAttachedHost(this);const r=this._viewContainerRef.createEmbeddedView(e.templateRef,e.context);return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=e,this._attachedRef=r,this.attached.emit(r),r}_getRootNode(){const e=this._viewContainerRef.element.nativeElement;return e.nodeType===e.ELEMENT_NODE?e:e.parentNode}}return n.\u0275fac=function(e){return new(e||n)(oe(ul),oe(Ms),oe(_t))},n.\u0275dir=un({type:n,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[ki]}),n})(),Qw=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({}),n})();const oP=mM();class WJ{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=Jn(-this._previousScrollPosition.left),t.style.top=Jn(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,r=t.style,s=this._document.body.style,i=r.scrollBehavior||"",o=s.scrollBehavior||"";this._isEnabled=!1,r.left=this._previousHTMLStyles.left,r.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),oP&&(r.scrollBehavior=s.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),oP&&(r.scrollBehavior=i,s.scrollBehavior=o)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const e=this._document.body,r=this._viewportRuler.getViewportSize();return e.scrollHeight>r.height||e.scrollWidth>r.width}}class GJ{constructor(t,e,r,s){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=r,this._config=s,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const e=this._viewportRuler.getViewportScrollPosition().top;Math.abs(e-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class aP{enable(){}disable(){}attach(){}}function Jw(n,t){return t.some(e=>n.bottom<e.top||n.top>e.bottom||n.right<e.left||n.left>e.right)}function lP(n,t){return t.some(e=>n.top<e.top||n.bottom>e.bottom||n.left<e.left||n.right>e.right)}class qJ{constructor(t,e,r,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=r,this._config=s,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const e=this._overlayRef.overlayElement.getBoundingClientRect(),{width:r,height:s}=this._viewportRuler.getViewportSize();Jw(e,[{width:r,height:s,bottom:s,right:r,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let KJ=(()=>{class n{constructor(e,r,s,i){this._scrollDispatcher=e,this._viewportRuler=r,this._ngZone=s,this.noop=()=>new aP,this.close=o=>new GJ(this._scrollDispatcher,this._ngZone,this._viewportRuler,o),this.block=()=>new WJ(this._viewportRuler,this._document),this.reposition=o=>new qJ(this._scrollDispatcher,this._viewportRuler,this._ngZone,o),this._document=i}}return n.\u0275fac=function(e){return new(e||n)(ee(Sh),ee(Ih),ee(Ct),ee(_t))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class eC{constructor(t){if(this.scrollStrategy=new aP,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const r of e)void 0!==t[r]&&(this[r]=t[r])}}}class XJ{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}class YJ{constructor(t,e,r,s,i,o,a,l,c){this._portalOutlet=t,this._host=e,this._pane=r,this._config=s,this._ngZone=i,this._keyboardDispatcher=o,this._document=a,this._location=l,this._outsideClickDispatcher=c,this._backdropElement=null,this._backdropClick=new Ge,this._attachments=new Ge,this._detachments=new Ge,this._locationChanges=x.EMPTY,this._backdropClickHandler=u=>this._backdropClick.next(u),this._backdropTransitionendHandler=u=>{this._disposeBackdrop(u.target)},this._keydownEvents=new Ge,this._outsidePointerEvents=new Ge,s.scrollStrategy&&(this._scrollStrategy=s.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=s.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){let e=this._portalOutlet.attach(t);return!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host),this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(Br(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){var t;const e=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this._disposeBackdrop(this._backdropElement),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),null===(t=this._host)||void 0===t||t.remove(),this._previousHostParent=this._pane=this._host=null,e&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config=Object.assign(Object.assign({},this._config),t),this._updateElementSize()}setDirection(t){this._config=Object.assign(Object.assign({},this._config),{direction:t}),this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=Jn(this._config.width),t.height=Jn(this._config.height),t.minWidth=Jn(this._config.minWidth),t.minHeight=Jn(this._config.minHeight),t.maxWidth=Jn(this._config.maxWidth),t.maxHeight=Jn(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){const t="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),"undefined"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){const t=this._backdropElement;!t||(t.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{t.addEventListener("transitionend",this._backdropTransitionendHandler)}),t.style.pointerEvents="none",this._backdropTimeout=this._ngZone.runOutsideAngular(()=>setTimeout(()=>{this._disposeBackdrop(t)},500)))}_toggleClasses(t,e,r){const s=rh(e||[]).filter(i=>!!i);s.length&&(r?t.classList.add(...s):t.classList.remove(...s))}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(dr(id(this._attachments,this._detachments))).subscribe(()=>{(!this._pane||!this._host||0===this._pane.children.length)&&(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._host.remove()),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}_disposeBackdrop(t){t&&(t.removeEventListener("click",this._backdropClickHandler),t.removeEventListener("transitionend",this._backdropTransitionendHandler),t.remove(),this._backdropElement===t&&(this._backdropElement=null)),this._backdropTimeout&&(clearTimeout(this._backdropTimeout),this._backdropTimeout=void 0)}}let tC=(()=>{class n{constructor(e,r){this._platform=r,this._document=e}ngOnDestroy(){var e;null===(e=this._containerElement)||void 0===e||e.remove()}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const e="cdk-overlay-container";if(this._platform.isBrowser||Vx()){const s=this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`);for(let i=0;i<s.length;i++)s[i].remove()}const r=this._document.createElement("div");r.classList.add(e),Vx()?r.setAttribute("platform","test"):this._platform.isBrowser||r.setAttribute("platform","server"),this._document.body.appendChild(r),this._containerElement=r}}return n.\u0275fac=function(e){return new(e||n)(ee(_t),ee(ys))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const cP="cdk-overlay-connected-position-bounding-box",ZJ=/([A-Za-z%]+)$/;class QJ{constructor(t,e,r,s,i){this._viewportRuler=e,this._document=r,this._platform=s,this._overlayContainer=i,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new Ge,this._resizeSubscription=x.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){this._validatePositions(),t.hostElement.classList.add(cP),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const t=this._originRect,e=this._overlayRect,r=this._viewportRect,s=this._containerRect,i=[];let o;for(let a of this._preferredPositions){let l=this._getOriginPoint(t,s,a),c=this._getOverlayPoint(l,e,a),u=this._getOverlayFit(c,e,r,a);if(u.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(a,l);this._canFitWithFlexibleDimensions(u,c,r)?i.push({position:a,origin:l,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(l,a)}):(!o||o.overlayFit.visibleArea<u.visibleArea)&&(o={overlayFit:u,overlayPoint:c,originPoint:l,position:a,overlayRect:e})}if(i.length){let a=null,l=-1;for(const c of i){const u=c.boundingBoxRect.width*c.boundingBoxRect.height*(c.position.weight||1);u>l&&(l=u,a=c)}return this._isPushed=!1,void this._applyPosition(a.position,a.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(o.position,o.originPoint);this._applyPosition(o.position,o.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&Tl(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(cP),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(this._isDisposed||!this._platform.isBrowser)return;const t=this._lastPosition;if(t){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const e=this._getOriginPoint(this._originRect,this._containerRect,t);this._applyPosition(t,e)}else this.apply()}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e,r){let s,i;if("center"==r.originX)s=t.left+t.width/2;else{const o=this._isRtl()?t.right:t.left,a=this._isRtl()?t.left:t.right;s="start"==r.originX?o:a}return e.left<0&&(s-=e.left),i="center"==r.originY?t.top+t.height/2:"top"==r.originY?t.top:t.bottom,e.top<0&&(i-=e.top),{x:s,y:i}}_getOverlayPoint(t,e,r){let s,i;return s="center"==r.overlayX?-e.width/2:"start"===r.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,i="center"==r.overlayY?-e.height/2:"top"==r.overlayY?0:-e.height,{x:t.x+s,y:t.y+i}}_getOverlayFit(t,e,r,s){const i=dP(e);let{x:o,y:a}=t,l=this._getOffset(s,"x"),c=this._getOffset(s,"y");l&&(o+=l),c&&(a+=c);let h=0-a,f=a+i.height-r.height,p=this._subtractOverflows(i.width,0-o,o+i.width-r.width),m=this._subtractOverflows(i.height,h,f),g=p*m;return{visibleArea:g,isCompletelyWithinViewport:i.width*i.height===g,fitsInViewportVertically:m===i.height,fitsInViewportHorizontally:p==i.width}}_canFitWithFlexibleDimensions(t,e,r){if(this._hasFlexibleDimensions){const s=r.bottom-e.y,i=r.right-e.x,o=uP(this._overlayRef.getConfig().minHeight),a=uP(this._overlayRef.getConfig().minWidth),c=t.fitsInViewportHorizontally||null!=a&&a<=i;return(t.fitsInViewportVertically||null!=o&&o<=s)&&c}return!1}_pushOverlayOnScreen(t,e,r){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const s=dP(e),i=this._viewportRect,o=Math.max(t.x+s.width-i.width,0),a=Math.max(t.y+s.height-i.height,0),l=Math.max(i.top-r.top-t.y,0),c=Math.max(i.left-r.left-t.x,0);let u=0,d=0;return u=s.width<=i.width?c||-o:t.x<this._viewportMargin?i.left-r.left-t.x:0,d=s.height<=i.height?l||-a:t.y<this._viewportMargin?i.top-r.top-t.y:0,this._previousPushAmount={x:u,y:d},{x:t.x+u,y:t.y+d}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const r=this._getScrollVisibility(),s=new XJ(t,r);this._positionChanges.next(s)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let r,s=t.overlayY;r="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let i=0;i<e.length;i++)e[i].style.transformOrigin=`${r} ${s}`}_calculateBoundingBoxRect(t,e){const r=this._viewportRect,s=this._isRtl();let i,o,a,u,d,h;if("top"===e.overlayY)o=t.y,i=r.height-o+this._viewportMargin;else if("bottom"===e.overlayY)a=r.height-t.y+2*this._viewportMargin,i=r.height-a+this._viewportMargin;else{const f=Math.min(r.bottom-t.y+r.top,t.y),p=this._lastBoundingBoxSize.height;i=2*f,o=t.y-f,i>p&&!this._isInitialRender&&!this._growAfterOpen&&(o=t.y-p/2)}if("end"===e.overlayX&&!s||"start"===e.overlayX&&s)h=r.width-t.x+this._viewportMargin,u=t.x-this._viewportMargin;else if("start"===e.overlayX&&!s||"end"===e.overlayX&&s)d=t.x,u=r.right-t.x;else{const f=Math.min(r.right-t.x+r.left,t.x),p=this._lastBoundingBoxSize.width;u=2*f,d=t.x-f,u>p&&!this._isInitialRender&&!this._growAfterOpen&&(d=t.x-p/2)}return{top:o,left:d,bottom:a,right:h,width:u,height:i}}_setBoundingBoxStyles(t,e){const r=this._calculateBoundingBoxRect(t,e);!this._isInitialRender&&!this._growAfterOpen&&(r.height=Math.min(r.height,this._lastBoundingBoxSize.height),r.width=Math.min(r.width,this._lastBoundingBoxSize.width));const s={};if(this._hasExactPosition())s.top=s.left="0",s.bottom=s.right=s.maxHeight=s.maxWidth="",s.width=s.height="100%";else{const i=this._overlayRef.getConfig().maxHeight,o=this._overlayRef.getConfig().maxWidth;s.height=Jn(r.height),s.top=Jn(r.top),s.bottom=Jn(r.bottom),s.width=Jn(r.width),s.left=Jn(r.left),s.right=Jn(r.right),s.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",s.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",i&&(s.maxHeight=Jn(i)),o&&(s.maxWidth=Jn(o))}this._lastBoundingBoxSize=r,Tl(this._boundingBox.style,s)}_resetBoundingBoxStyles(){Tl(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){Tl(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const r={},s=this._hasExactPosition(),i=this._hasFlexibleDimensions,o=this._overlayRef.getConfig();if(s){const u=this._viewportRuler.getViewportScrollPosition();Tl(r,this._getExactOverlayY(e,t,u)),Tl(r,this._getExactOverlayX(e,t,u))}else r.position="static";let a="",l=this._getOffset(e,"x"),c=this._getOffset(e,"y");l&&(a+=`translateX(${l}px) `),c&&(a+=`translateY(${c}px)`),r.transform=a.trim(),o.maxHeight&&(s?r.maxHeight=Jn(o.maxHeight):i&&(r.maxHeight="")),o.maxWidth&&(s?r.maxWidth=Jn(o.maxWidth):i&&(r.maxWidth="")),Tl(this._pane.style,r)}_getExactOverlayY(t,e,r){let s={top:"",bottom:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,r)),"bottom"===t.overlayY?s.bottom=this._document.documentElement.clientHeight-(i.y+this._overlayRect.height)+"px":s.top=Jn(i.y),s}_getExactOverlayX(t,e,r){let o,s={left:"",right:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,r)),o=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===o?s.right=this._document.documentElement.clientWidth-(i.x+this._overlayRect.width)+"px":s.left=Jn(i.x),s}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),r=this._scrollables.map(s=>s.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:lP(t,r),isOriginOutsideView:Jw(t,r),isOverlayClipped:lP(e,r),isOverlayOutsideView:Jw(e,r)}}_subtractOverflows(t,...e){return e.reduce((r,s)=>r-Math.max(s,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,r=this._viewportRuler.getViewportScrollPosition();return{top:r.top+this._viewportMargin,left:r.left+this._viewportMargin,right:r.left+t-this._viewportMargin,bottom:r.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&rh(t).forEach(e=>{""!==e&&-1===this._appliedPanelClasses.indexOf(e)&&(this._appliedPanelClasses.push(e),this._pane.classList.add(e))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof Cn)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,r=t.height||0;return{top:t.y,bottom:t.y+r,left:t.x,right:t.x+e,height:r,width:e}}}function Tl(n,t){for(let e in t)t.hasOwnProperty(e)&&(n[e]=t[e]);return n}function uP(n){if("number"!=typeof n&&null!=n){const[t,e]=n.split(ZJ);return e&&"px"!==e?null:parseFloat(t)}return n||null}function dP(n){return{top:Math.floor(n.top),right:Math.floor(n.right),bottom:Math.floor(n.bottom),left:Math.floor(n.left),width:Math.floor(n.width),height:Math.floor(n.height)}}const hP="cdk-global-overlay-wrapper";class JJ{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._leftOffset="",this._rightOffset="",this._alignItems="",this._justifyContent="",this._width="",this._height=""}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add(hP),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._rightOffset="",this._leftOffset=t,this._justifyContent="flex-start",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._leftOffset="",this._rightOffset=t,this._justifyContent="flex-end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._justifyContent="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,r=this._overlayRef.getConfig(),{width:s,height:i,maxWidth:o,maxHeight:a}=r,l=!("100%"!==s&&"100vw"!==s||o&&"100%"!==o&&"100vw"!==o),c=!("100%"!==i&&"100vh"!==i||a&&"100%"!==a&&"100vh"!==a);t.position=this._cssPosition,t.marginLeft=l?"0":this._leftOffset,t.marginTop=c?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=this._rightOffset,l?e.justifyContent="flex-start":"center"===this._justifyContent?e.justifyContent="center":"rtl"===this._overlayRef.getConfig().direction?"flex-start"===this._justifyContent?e.justifyContent="flex-end":"flex-end"===this._justifyContent&&(e.justifyContent="flex-start"):e.justifyContent=this._justifyContent,e.alignItems=c?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,r=e.style;e.classList.remove(hP),r.justifyContent=r.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let eee=(()=>{class n{constructor(e,r,s,i){this._viewportRuler=e,this._document=r,this._platform=s,this._overlayContainer=i}global(){return new JJ}flexibleConnectedTo(e){return new QJ(e,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return n.\u0275fac=function(e){return new(e||n)(ee(Ih),ee(_t),ee(ys),ee(tC))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),fP=(()=>{class n{constructor(e){this._attachedOverlays=[],this._document=e}ngOnDestroy(){this.detach()}add(e){this.remove(e),this._attachedOverlays.push(e)}remove(e){const r=this._attachedOverlays.indexOf(e);r>-1&&this._attachedOverlays.splice(r,1),0===this._attachedOverlays.length&&this.detach()}}return n.\u0275fac=function(e){return new(e||n)(ee(_t))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),tee=(()=>{class n extends fP{constructor(e,r){super(e),this._ngZone=r,this._keydownListener=s=>{const i=this._attachedOverlays;for(let o=i.length-1;o>-1;o--)if(i[o]._keydownEvents.observers.length>0){const a=i[o]._keydownEvents;this._ngZone?this._ngZone.run(()=>a.next(s)):a.next(s);break}}}add(e){super.add(e),this._isAttached||(this._ngZone?this._ngZone.runOutsideAngular(()=>this._document.body.addEventListener("keydown",this._keydownListener)):this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return n.\u0275fac=function(e){return new(e||n)(ee(_t),ee(Ct,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),nee=(()=>{class n extends fP{constructor(e,r,s){super(e),this._platform=r,this._ngZone=s,this._cursorStyleIsSet=!1,this._pointerDownListener=i=>{this._pointerDownEventTarget=Pi(i)},this._clickListener=i=>{const o=Pi(i),a="click"===i.type&&this._pointerDownEventTarget?this._pointerDownEventTarget:o;this._pointerDownEventTarget=null;const l=this._attachedOverlays.slice();for(let c=l.length-1;c>-1;c--){const u=l[c];if(u._outsidePointerEvents.observers.length<1||!u.hasAttached())continue;if(u.overlayElement.contains(o)||u.overlayElement.contains(a))break;const d=u._outsidePointerEvents;this._ngZone?this._ngZone.run(()=>d.next(i)):d.next(i)}}}add(e){if(super.add(e),!this._isAttached){const r=this._document.body;this._ngZone?this._ngZone.runOutsideAngular(()=>this._addEventListeners(r)):this._addEventListeners(r),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=r.style.cursor,r.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const e=this._document.body;e.removeEventListener("pointerdown",this._pointerDownListener,!0),e.removeEventListener("click",this._clickListener,!0),e.removeEventListener("auxclick",this._clickListener,!0),e.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(e.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}_addEventListeners(e){e.addEventListener("pointerdown",this._pointerDownListener,!0),e.addEventListener("click",this._clickListener,!0),e.addEventListener("auxclick",this._clickListener,!0),e.addEventListener("contextmenu",this._clickListener,!0)}}return n.\u0275fac=function(e){return new(e||n)(ee(_t),ee(ys),ee(Ct,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),ree=0,lu=(()=>{class n{constructor(e,r,s,i,o,a,l,c,u,d,h){this.scrollStrategies=e,this._overlayContainer=r,this._componentFactoryResolver=s,this._positionBuilder=i,this._keyboardDispatcher=o,this._injector=a,this._ngZone=l,this._document=c,this._directionality=u,this._location=d,this._outsideClickDispatcher=h}create(e){const r=this._createHostElement(),s=this._createPaneElement(r),i=this._createPortalOutlet(s),o=new eC(e);return o.direction=o.direction||this._directionality.value,new YJ(i,r,s,o,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher)}position(){return this._positionBuilder}_createPaneElement(e){const r=this._document.createElement("div");return r.id="cdk-overlay-"+ree++,r.classList.add("cdk-overlay-pane"),e.appendChild(r),r}_createHostElement(){const e=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(e),e}_createPortalOutlet(e){return this._appRef||(this._appRef=this._injector.get(Nm)),new jJ(e,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return n.\u0275fac=function(e){return new(e||n)(ee(KJ),ee(tC),ee(ul),ee(eee),ee(tee),ee(Tn),ee(Ct),ee(_t),ee(ya),ee(Kd),ee(nee))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})();const oee={provide:new Fe("cdk-connected-overlay-scroll-strategy"),deps:[lu],useFactory:function iee(n){return()=>n.scrollStrategies.reposition()}};let pP=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({providers:[lu,oee],imports:[[Jd,Qw,Xw],Xw]}),n})();function aee(n,t){}class nC{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.maxWidth="80vw",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.autoFocus="first-tabbable",this.restoreFocus=!0,this.delayFocusTrap=!0,this.closeOnNavigation=!0}}const lee={dialogContainer:Jm("dialogContainer",[yl("void, exit",Os({opacity:0,transform:"scale(0.7)"})),yl("enter",Os({transform:"none"})),_l("* => enter",kM([gl("150ms cubic-bezier(0, 0, 0.2, 1)",Os({transform:"none",opacity:1})),RM("@*",AM(),{optional:!0})])),_l("* => void, * => exit",kM([gl("75ms cubic-bezier(0.4, 0.0, 0.2, 1)",Os({opacity:0})),RM("@*",AM(),{optional:!0})]))])};let cee=(()=>{class n extends Hg{constructor(e,r,s,i,o,a,l,c){super(),this._elementRef=e,this._focusTrapFactory=r,this._changeDetectorRef=s,this._config=o,this._interactivityChecker=a,this._ngZone=l,this._focusMonitor=c,this._animationStateChanged=new Bt,this._elementFocusedBeforeDialogWasOpened=null,this._closeInteractionType=null,this.attachDomPortal=u=>(this._portalOutlet.hasAttached(),this._portalOutlet.attachDomPortal(u)),this._ariaLabelledBy=o.ariaLabelledBy||null,this._document=i}_initializeWithAttachedContent(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement),this._document&&(this._elementFocusedBeforeDialogWasOpened=Lx())}attachComponentPortal(e){return this._portalOutlet.hasAttached(),this._portalOutlet.attachComponentPortal(e)}attachTemplatePortal(e){return this._portalOutlet.hasAttached(),this._portalOutlet.attachTemplatePortal(e)}_recaptureFocus(){this._containsFocus()||this._trapFocus()}_forceFocus(e,r){this._interactivityChecker.isFocusable(e)||(e.tabIndex=-1,this._ngZone.runOutsideAngular(()=>{const s=()=>{e.removeEventListener("blur",s),e.removeEventListener("mousedown",s),e.removeAttribute("tabindex")};e.addEventListener("blur",s),e.addEventListener("mousedown",s)})),e.focus(r)}_focusByCssSelector(e,r){let s=this._elementRef.nativeElement.querySelector(e);s&&this._forceFocus(s,r)}_trapFocus(){const e=this._elementRef.nativeElement;switch(this._config.autoFocus){case!1:case"dialog":this._containsFocus()||e.focus();break;case!0:case"first-tabbable":this._focusTrap.focusInitialElementWhenReady().then(r=>{r||this._focusDialogContainer()});break;case"first-heading":this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');break;default:this._focusByCssSelector(this._config.autoFocus)}}_restoreFocus(){const e=this._elementFocusedBeforeDialogWasOpened;if(this._config.restoreFocus&&e&&"function"==typeof e.focus){const r=Lx(),s=this._elementRef.nativeElement;(!r||r===this._document.body||r===s||s.contains(r))&&(this._focusMonitor?(this._focusMonitor.focusVia(e,this._closeInteractionType),this._closeInteractionType=null):e.focus())}this._focusTrap&&this._focusTrap.destroy()}_focusDialogContainer(){this._elementRef.nativeElement.focus&&this._elementRef.nativeElement.focus()}_containsFocus(){const e=this._elementRef.nativeElement,r=Lx();return e===r||e.contains(r)}}return n.\u0275fac=function(e){return new(e||n)(oe(Cn),oe(CM),oe(oo),oe(_t,8),oe(nC),oe(zx),oe(Ct),oe(jx))},n.\u0275dir=un({type:n,viewQuery:function(e,r){if(1&e&&dl(jg,7),2&e){let s;rs(s=ss())&&(r._portalOutlet=s.first)}},features:[ki]}),n})(),uee=(()=>{class n extends cee{constructor(){super(...arguments),this._state="enter"}_onAnimationDone({toState:e,totalTime:r}){"enter"===e?(this._config.delayFocusTrap&&this._trapFocus(),this._animationStateChanged.next({state:"opened",totalTime:r})):"exit"===e&&(this._restoreFocus(),this._animationStateChanged.next({state:"closed",totalTime:r}))}_onAnimationStart({toState:e,totalTime:r}){"enter"===e?this._animationStateChanged.next({state:"opening",totalTime:r}):("exit"===e||"void"===e)&&this._animationStateChanged.next({state:"closing",totalTime:r})}_startExitAnimation(){this._state="exit",this._changeDetectorRef.markForCheck()}_initializeWithAttachedContent(){super._initializeWithAttachedContent(),this._config.delayFocusTrap||this._trapFocus()}}return n.\u0275fac=function(){let t;return function(r){return(t||(t=function zT(n){return sa(()=>{const t=n.prototype.constructor,e=t[To]||pb(t),r=Object.prototype;let s=Object.getPrototypeOf(n.prototype).constructor;for(;s&&s!==r;){const i=s[To]||pb(s);if(i&&i!==e)return i;s=Object.getPrototypeOf(s)}return i=>new i})}(n)))(r||n)}}(),n.\u0275cmp=Wn({type:n,selectors:[["mat-dialog-container"]],hostAttrs:["tabindex","-1","aria-modal","true",1,"mat-dialog-container"],hostVars:6,hostBindings:function(e,r){1&e&&Od("@dialogContainer.start",function(i){return r._onAnimationStart(i)})("@dialogContainer.done",function(i){return r._onAnimationDone(i)}),2&e&&(N0("id",r._id),no("role",r._config.role)("aria-labelledby",r._config.ariaLabel?null:r._ariaLabelledBy)("aria-label",r._config.ariaLabel)("aria-describedby",r._config.ariaDescribedBy||null),Pd("@dialogContainer",r._state))},features:[ki],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(e,r){1&e&&Js(0,aee,0,0,"ng-template",0)},directives:[jg],styles:[".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"],encapsulation:2,data:{animation:[lee.dialogContainer]}}),n})(),dee=0;class hee{constructor(t,e,r="mat-dialog-"+dee++){this._overlayRef=t,this._containerInstance=e,this.id=r,this.disableClose=this._containerInstance._config.disableClose,this._afterOpened=new Ge,this._afterClosed=new Ge,this._beforeClosed=new Ge,this._state=0,e._id=r,e._animationStateChanged.pipe(ur(s=>"opened"===s.state),Br(1)).subscribe(()=>{this._afterOpened.next(),this._afterOpened.complete()}),e._animationStateChanged.pipe(ur(s=>"closed"===s.state),Br(1)).subscribe(()=>{clearTimeout(this._closeFallbackTimeout),this._finishDialogClose()}),t.detachments().subscribe(()=>{this._beforeClosed.next(this._result),this._beforeClosed.complete(),this._afterClosed.next(this._result),this._afterClosed.complete(),this.componentInstance=null,this._overlayRef.dispose()}),t.keydownEvents().pipe(ur(s=>27===s.keyCode&&!this.disableClose&&!yM(s))).subscribe(s=>{s.preventDefault(),mP(this,"keyboard")}),t.backdropClick().subscribe(()=>{this.disableClose?this._containerInstance._recaptureFocus():mP(this,"mouse")})}close(t){this._result=t,this._containerInstance._animationStateChanged.pipe(ur(e=>"closing"===e.state),Br(1)).subscribe(e=>{this._beforeClosed.next(t),this._beforeClosed.complete(),this._overlayRef.detachBackdrop(),this._closeFallbackTimeout=setTimeout(()=>this._finishDialogClose(),e.totalTime+100)}),this._state=1,this._containerInstance._startExitAnimation()}afterOpened(){return this._afterOpened}afterClosed(){return this._afterClosed}beforeClosed(){return this._beforeClosed}backdropClick(){return this._overlayRef.backdropClick()}keydownEvents(){return this._overlayRef.keydownEvents()}updatePosition(t){let e=this._getPositionStrategy();return t&&(t.left||t.right)?t.left?e.left(t.left):e.right(t.right):e.centerHorizontally(),t&&(t.top||t.bottom)?t.top?e.top(t.top):e.bottom(t.bottom):e.centerVertically(),this._overlayRef.updatePosition(),this}updateSize(t="",e=""){return this._overlayRef.updateSize({width:t,height:e}),this._overlayRef.updatePosition(),this}addPanelClass(t){return this._overlayRef.addPanelClass(t),this}removePanelClass(t){return this._overlayRef.removePanelClass(t),this}getState(){return this._state}_finishDialogClose(){this._state=2,this._overlayRef.dispose()}_getPositionStrategy(){return this._overlayRef.getConfig().positionStrategy}}function mP(n,t,e){return void 0!==n._containerInstance&&(n._containerInstance._closeInteractionType=t),n.close(e)}const gP=new Fe("MatDialogData"),fee=new Fe("mat-dialog-default-options"),yP=new Fe("mat-dialog-scroll-strategy"),mee={provide:yP,deps:[lu],useFactory:function pee(n){return()=>n.scrollStrategies.block()}};let gee=(()=>{class n{constructor(e,r,s,i,o,a,l,c,u,d){this._overlay=e,this._injector=r,this._defaultOptions=s,this._parentDialog=i,this._overlayContainer=o,this._dialogRefConstructor=l,this._dialogContainerType=c,this._dialogDataToken=u,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new Ge,this._afterOpenedAtThisLevel=new Ge,this._ariaHiddenElements=new Map,this.afterAllClosed=ww(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(Uo(void 0))),this._scrollStrategy=a}get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}_getAfterAllClosed(){const e=this._parentDialog;return e?e._getAfterAllClosed():this._afterAllClosedAtThisLevel}open(e,r){r=function yee(n,t){return Object.assign(Object.assign({},t),n)}(r,this._defaultOptions||new nC),r.id&&this.getDialogById(r.id);const s=this._createOverlay(r),i=this._attachDialogContainer(s,r),o=this._attachDialogContent(e,i,s,r);return this.openDialogs.length||this._hideNonDialogContentFromAssistiveTechnology(),this.openDialogs.push(o),o.afterClosed().subscribe(()=>this._removeOpenDialog(o)),this.afterOpened.next(o),i._initializeWithAttachedContent(),o}closeAll(){this._closeDialogs(this.openDialogs)}getDialogById(e){return this.openDialogs.find(r=>r.id===e)}ngOnDestroy(){this._closeDialogs(this._openDialogsAtThisLevel),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete()}_createOverlay(e){const r=this._getOverlayConfig(e);return this._overlay.create(r)}_getOverlayConfig(e){const r=new eC({positionStrategy:this._overlay.position().global(),scrollStrategy:e.scrollStrategy||this._scrollStrategy(),panelClass:e.panelClass,hasBackdrop:e.hasBackdrop,direction:e.direction,minWidth:e.minWidth,minHeight:e.minHeight,maxWidth:e.maxWidth,maxHeight:e.maxHeight,disposeOnNavigation:e.closeOnNavigation});return e.backdropClass&&(r.backdropClass=e.backdropClass),r}_attachDialogContainer(e,r){const i=Tn.create({parent:r&&r.viewContainerRef&&r.viewContainerRef.injector||this._injector,providers:[{provide:nC,useValue:r}]}),o=new kh(this._dialogContainerType,r.viewContainerRef,i,r.componentFactoryResolver);return e.attach(o).instance}_attachDialogContent(e,r,s,i){const o=new this._dialogRefConstructor(s,r,i.id);if(e instanceof ei)r.attachTemplatePortal(new Zw(e,null,{$implicit:i.data,dialogRef:o}));else{const a=this._createInjector(i,o,r),l=r.attachComponentPortal(new kh(e,i.viewContainerRef,a,i.componentFactoryResolver));o.componentInstance=l.instance}return o.updateSize(i.width,i.height).updatePosition(i.position),o}_createInjector(e,r,s){const i=e&&e.viewContainerRef&&e.viewContainerRef.injector,o=[{provide:this._dialogContainerType,useValue:s},{provide:this._dialogDataToken,useValue:e.data},{provide:this._dialogRefConstructor,useValue:r}];return e.direction&&(!i||!i.get(ya,null,ut.Optional))&&o.push({provide:ya,useValue:{value:e.direction,change:it()}}),Tn.create({parent:i||this._injector,providers:o})}_removeOpenDialog(e){const r=this.openDialogs.indexOf(e);r>-1&&(this.openDialogs.splice(r,1),this.openDialogs.length||(this._ariaHiddenElements.forEach((s,i)=>{s?i.setAttribute("aria-hidden",s):i.removeAttribute("aria-hidden")}),this._ariaHiddenElements.clear(),this._getAfterAllClosed().next()))}_hideNonDialogContentFromAssistiveTechnology(){const e=this._overlayContainer.getContainerElement();if(e.parentElement){const r=e.parentElement.children;for(let s=r.length-1;s>-1;s--){let i=r[s];i!==e&&"SCRIPT"!==i.nodeName&&"STYLE"!==i.nodeName&&!i.hasAttribute("aria-live")&&(this._ariaHiddenElements.set(i,i.getAttribute("aria-hidden")),i.setAttribute("aria-hidden","true"))}}}_closeDialogs(e){let r=e.length;for(;r--;)e[r].close()}}return n.\u0275fac=function(e){hm()},n.\u0275dir=un({type:n}),n})(),_P=(()=>{class n extends gee{constructor(e,r,s,i,o,a,l,c){super(e,r,i,a,l,o,hee,uee,gP,c)}}return n.\u0275fac=function(e){return new(e||n)(ee(lu),ee(Tn),ee(Kd,8),ee(fee,8),ee(yP),ee(n,12),ee(tC),ee(tu,8))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})(),_ee=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({providers:[_P,mee],imports:[[pP,Qw,fr],fr]}),n})(),vee=(()=>{class n{constructor(e){this.pred=e}ngOnInit(){this.affichage=this.pred.probability>.5?"Dog":"Cat"}}return n.\u0275fac=function(e){return new(e||n)(oe(gP))},n.\u0275cmp=Wn({type:n,selectors:[["app-predict1"]],decls:3,vars:1,consts:[[1,"section"]],template:function(e,r){1&e&&(Re(0,"div",0)(1,"h3"),nt(2),Be()()),2&e&&(Yn(2),ym(" I have find a ",r.affichage," "))},styles:[".section[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;flex-direction:column;width:300px}"]}),n})();class vP{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class rC{refCount(t){return Ls("refCount")}incRef(t){return Ls("incRef")}timerAvailable(){return!0}time(t){return Ls("time")}read(t){return Ls("read")}readSync(t){return Ls("readSync")}readToGPU(t,e){return Ls("readToGPU")}numDataIds(){return Ls("numDataIds")}disposeData(t,e){return Ls("disposeData")}write(t,e,r){return Ls("write")}move(t,e,r,s,i){return Ls("move")}memory(){return Ls("memory")}floatPrecision(){return Ls("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Ls("dispose")}}function Ls(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function bP(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Da(n,t,e)}function kl(n,t,e){return Math.max(n,Math.min(t,e))}function xP(n){return n%2==0?n:n+1}function Da(n,t,e){const r=n[t];n[t]=n[e],n[e]=r}function S(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function ai(n,t,e=""){S(Ut(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function sC(n){S(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function cu(n,t=[],e=!1){if(null==t&&(t=[]),Array.isArray(n)||uo(n)&&!e)for(let r=0;r<n.length;++r)cu(n[r],t,e);else t.push(n);return t}function ce(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function Ut(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function uu(n){return n%1==0}function iC(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function du(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function wP(n,t=(r=>0),e){return new Promise((r,s)=>{let i=0;const o=()=>{if(n())return void r();i++;const a=t(i);null!=e&&i>=e?s():setTimeout(o,a)};o()})}function CP(n,t){let e=1,r=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)e*=n[i];else if(-1===n[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(-1===r){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const s=n.slice();return s[r]=t/e,s}function It(n,t){const e=t.length;return S((n=null==n?t.map((r,s)=>s):[].concat(n)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),S(n.every(r=>uu(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function Sa(n,t){const e=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||s?null:It(t,n).sort();let o=0;for(let a=0;a<n.length;++a){if(null!=i){if(i[o]===a&&1!==n[a])throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(null==i[o]||i[o]>a)&&1===n[a]&&(e.push(n[a]),r.push(a)),i[o]<=a&&o++}1!==n[a]&&(e.push(n[a]),r.push(a))}return{newShape:e,keptDims:r}}function Sr(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);e=new Uint8Array(t)}return e}function os(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function DP(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function uo(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function oC(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function Nh(n){return"string"==typeof n||n instanceof String}function aC(n){return"number"==typeof n}function Ah(n){return Array.isArray(n)?Ah(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":aC(n)?"float32":Nh(n)?"string":function Eee(n){return"boolean"==typeof n}(n)?"bool":"float32"}function lC(n){return!!(n&&n.constructor&&n.call&&n.apply)}function cC(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Je(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function SP(n,t,e,r=!1){const s=new Array;if(1===t.length){const i=t[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=e[n+o]}else{const i=t[0],o=t.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<i;l++)s[l]=SP(n+l*a,o,e,r)}return s}function $i(n,t,e=!1){if(0===n.length)return t[0];const r=n.reduce((s,i)=>s*i)*(e?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return SP(0,n,t,e)}function uC(n,t){const e=Pr(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function Pr(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function EP(n,t){const e=n.reduce((r,s)=>r*s,1);if(null==t||"float32"===t)return $i(n,new Float32Array(e));if("int32"===t)return $i(n,new Int32Array(e));if("bool"===t)return $i(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function IP(n){n.forEach(t=>{S(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function ho(n,t,e){if(0===t)return 0;if(1===t)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=e[s]*n[s];return r}function Rh(n,t,e){if(0===t)return[];if(1===t)return[n];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/e[s]),n-=r[s]*e[s];return r[r.length-1]=n,r}function TP(n){return n&&n.then&&"function"==typeof n.then}const kP="tfjsflags";class Iee{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Tee,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(ae().getBool("IS_TEST")||ae().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){const s=this.urlFlags[t];ae().getBool("IS_TEST")||ae().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}getAsync(t){var e=this;return he(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(TP(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);kP in t&&t[kP].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=function Nee(n,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${n}.`)}(s,i)})}}function Tee(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function kee(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,r[0],r[1]),r.join("="))),t}function ae(){return NP}let dC,NP=null;function AP(){if(null==dC){let n;if("undefined"!=typeof window)n=window;else if("undefined"!=typeof global)n=global;else if("undefined"!=typeof process)n=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");n=self}dC=n}return dC}function hC(n,t){const e=function Ree(){const n=AP();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const r=t();return e.set(n,r),e.get(n)}}const Wg="Abs",Mh="Acos",Oh="Acosh",hu="Add",fC="AddN",Gg="ArgMax",qg="ArgMin",Fh="Asin",Ph="Asinh",$h="Atan",Lh="Atanh",Vh="Atan2",Kg="AvgPool",gC="AvgPoolGrad",Xg="AvgPool3D",yC="AvgPool3DGrad",Yg="BatchMatMul",Zg="BatchToSpaceND",_C="Bincount",RP="BroadcastArgs",Bh="Cast",zh="Ceil",Uh="ClipByValue",vC="Complex",Qg="ComplexAbs",Jg="Concat",ey="Conv2D",bC="Conv2DBackpropFilter",ty="Conv2DBackpropInput",ny="Conv3D",xC="Conv3DBackpropFilterV2",wC="Conv3DBackpropInputV2",Hh="Cos",jh="Cosh",CC="Cumprod",ry="Cumsum",DC="CropAndResize",MP="DenseBincount",SC="DepthToSpace",sy="DepthwiseConv2dNative",EC="DepthwiseConv2dNativeBackpropFilter",IC="DepthwiseConv2dNativeBackpropInput",iy="Dilation2D",TC="Dilation2DBackpropInput",kC="Dilation2DBackpropFilter",Wh="RealDiv",Gh="Elu",NC="EluGrad",qh="Erf",oy="Equal",Kh="Exp",ay="ExpandDims",Xh="Expm1",RC="Fill",MC="FlipLeftRight",Yh="Floor",Zh="FloorDiv",ly="FusedBatchNorm",cy="GatherV2",PP="GatherNd",uy="Greater",Qh="GreaterEqual",Jh="Identity",OC="IFFT",FC="Imag",ef="IsFinite",nf="IsInf",rf="IsNan",dy="LeakyRelu",hy="Less",fy="LessEqual",$P="LinSpace",sf="Log",af="Log1p",py="LogicalAnd",my="LogicalNot",gy="LogicalOr",yy="LRN",PC="LRNGrad",_y="Max",lf="Maximum",vy="MaxPool",$C="MaxPoolGrad",by="MaxPool3D",LC="MaxPool3DGrad",LP="MaxPoolWithArgmax",xy="Mean",wy="Min",cf="Minimum",Cy="MirrorPad",uf="Mod",VP="Multinomial",df="Multiply",Dy="Neg",Sy="NotEqual",VC="NonMaxSuppressionV3",BC="NonMaxSuppressionV4",zC="NonMaxSuppressionV5",Ey="OnesLike",Iy="OneHot",Ty="Pack",ky="PadV2",hf="Pow",Ny="Prelu",UC="Prod",HC="Range",jC="Real",ff="Reciprocal",pf="Relu",Ay="Reshape",Ry="ResizeNearestNeighbor",WC="ResizeNearestNeighborGrad",My="ResizeBilinear",GC="ResizeBilinearGrad",mf="Relu6",Oy="Reverse",gf="Round",yf="Rsqrt",BP="ScatterNd",Fy="Select",_f="Selu",Py="Slice",vf="Sin",bf="Sinh",xf="Sign",wf="Sigmoid",Cf="Softplus",Df="Sqrt",$y="Sum",Ly="SpaceToBatchND",Vy="SplitV",By="Softmax",qC="SparseFillEmptyRows",KC="SparseReshape",XC="SparseSegmentMean",YC="SparseSegmentSum",zP="SparseToDense",Sf="SquaredDifference",ZC="Square",QC="StridedSlice",JC="StringNGrams",eD="StringSplit",tD="StringToHashBucketFast",Ef="Sub",If="Tan",Tf="Tanh",kf="Tile",nD="TopK",rD="Transform",zy="Transpose",sD="Unique",Uy="Unpack",Hy="UnsortedSegmentSum",jy="ZerosLike",Nf="Step",iD="FromPixels",oD="RotateWithOffset",Wy="_FusedMatMul",Gy="FusedConv2D",qy="FusedDepthwiseConv2D";function Vs(...n){ae().getBool("IS_TEST")||ae().getBool("PROD")||console.warn(...n)}function Fee(...n){ae().getBool("IS_TEST")||ae().getBool("PROD")||console.log(...n)}const fu=hC("kernelRegistry",()=>new Map),Af=hC("gradRegistry",()=>new Map);function aD(n,t){const e=uD(n,t);return fu.get(e)}function UP(n){return Af.get(n)}function lD(n){const t=fu.entries(),e=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&e.push(o)}return e}function cD(n){const{kernelName:t,backendName:e}=n,r=uD(t,e);fu.has(r)&&Vs(`The kernel '${t}' for backend '${e}' is already registered`),fu.set(r,n)}function Pee(n){const{kernelName:t}=n;Af.has(t)&&ae().getBool("DEBUG")&&Vs(`Overriding the gradient for '${t}'`),Af.set(t,n)}function uD(n,t){return`${t}_${n}`}var HP=U(658);const Nl=U.n(HP)()||HP;function Ky(n){return Nl.fromString(n,!0,16)}const jP=Ky("c3a5c85c97cb3127"),Al=Ky("b492b66fbe98f273"),Wr=Ky("9ae16a3b2f90404f");function dD(n){return n.xor(n.shru(47))}function WP(n,t,e){const r=n.slice(t,t+e);return Nl.fromBytes(Array.from(r),!0,!0)}function on(n,t){return WP(n,t,8)}function GP(n,t){return WP(n,t,4)}function pr(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function Ea(n,t,e=Ky("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let s=t.xor(r).mul(e);return s=s.xor(s.shru(47)),s=s.mul(e),s}function Xy(n,t,e,r){return function Lee(n,t,e,r,s,i){s=s.add(n),i=pr(i.add(s).add(r),21);const o=s;return s=(s=s.add(t)).add(e),i=i.add(pr(s,44)),[s.add(r),i.add(o)]}(on(n,t),on(n,t+8),on(n,t+16),on(n,t+24),e,r)}function Uee(n,t=n.length){const e=Nl.fromNumber(81,!0);if(t<=32)return t<=16?function Vee(n,t=n.length){if(t>=8){const e=Wr.add(2*t),r=on(n,0).add(Wr),s=on(n,t-8);return Ea(pr(s,37).mul(e).add(r),pr(r,25).add(s).mul(e),e)}if(t>=4){const e=Wr.add(2*t);return Ea(GP(n,0).shl(3).add(t),GP(n,t-4),e)}if(t>0){const o=t+(n[t-1]<<2);return dD(Wr.mul(n[0]+(n[t>>1]<<8)).xor(jP.mul(o))).mul(Wr)}return Wr}(n,t):function Bee(n,t=n.length){const e=Wr.add(2*t),r=on(n,0).mul(Al),s=on(n,8),i=on(n,t-8).mul(e),o=on(n,t-16).mul(Wr);return Ea(pr(r.add(s),43).add(pr(i,30)).add(o),r.add(pr(s.add(Wr),18)).add(i),e)}(n,t);if(t<=64)return function zee(n,t=n.length){const e=Wr.add(2*t),r=on(n,0).mul(Wr),s=on(n,8),i=on(n,t-8).mul(e),o=on(n,t-16).mul(Wr),a=pr(r.add(s),43).add(pr(i,30)).add(o),l=Ea(a,r.add(pr(s.add(Wr),18)).add(i),e),c=on(n,16).mul(e),u=on(n,24),d=a.add(on(n,t-32)).mul(e),h=l.add(on(n,t-24)).mul(e);return Ea(pr(c.add(u),43).add(pr(d,30)).add(h),c.add(pr(u.add(r),18)).add(d),e)}(n,t);let r=e,s=e.mul(Al).add(113),i=dD(s.mul(Wr).add(113)).mul(Wr),o=[Nl.UZERO,Nl.UZERO],a=[Nl.UZERO,Nl.UZERO];r=r.mul(Wr).add(on(n,0));let l=0;const c=64*(t-1>>6),u=c+(t-1&63)-63;do{r=pr(r.add(s).add(o[0]).add(on(n,l+8)),37).mul(Al),s=pr(s.add(o[1]).add(on(n,l+48)),42).mul(Al),r=r.xor(a[1]),s=s.add(o[0]).add(on(n,l+40)),i=pr(i.add(a[0]),33).mul(Al),o=Xy(n,l,o[1].mul(Al),r.add(a[0])),a=Xy(n,l+32,i.add(a[1]),s.add(on(n,l+16))),[i,r]=[r,i],l+=64}while(l!==c);const d=Al.add(i.and(255).shl(1));return l=u,a[0]=a[0].add(t-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),r=pr(r.add(s).add(o[0]).add(on(n,l+8)),37).mul(d),s=pr(s.add(o[1]).add(on(n,l+48)),42).mul(d),r=r.xor(a[1].mul(9)),s=s.add(o[0].mul(9).add(on(n,l+40))),i=pr(i.add(a[0]),33).mul(d),o=Xy(n,l,o[1].mul(d),r.add(a[0])),a=Xy(n,l+32,i.add(a[1]),s.add(on(n,l+16))),[i,r]=[r,i],Ea(Ea(o[0],a[0],d).add(dD(s).mul(jP)).add(i),Ea(o[1],a[1],d).add(r),d)}function Ia(n,t){return"string"===t?Ta(n):Rl([n],t)}function Rl(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=cu(n)),ae().getBool("DEBUG")&&function Cee(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(n,t),function Hee(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)0!==Math.round(n[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${t}`)}function as(){return ae().platform.now()}function Ta(n,t="utf-8"){return t=t||"utf-8",ae().platform.encode(n,t)}function pu(n,t="utf-8"){return t=t||"utf-8",ae().platform.decode(n,t)}class jee{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Gee)}profileKernel(t,e,r){let s;const i=()=>{s=r()};let o;const a=as();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of s)c.dataSync();o=Promise.resolve({kernelMs:as()-a})}if(ae().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const u=s[c];u.data().then(d=>{Wee(d,u.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>null!=c.getExtraProfileInfo?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:r,timeMs:s,inputs:i,extraInfo:o}=t;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],i,l[2])})})}}function Wee(n,t,e){if("float32"!==t)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class Gee{logKernelProfile(t,e,r,s,i,o){const a="number"==typeof s?du(`${s}ms`,9):s.error,l=du(t,25),c=e.rank,u=e.size,d=du(e.shape.toString(),14);let h="";for(const f in i){const p=i[f];if(null!=p){const m=p.shape||e.shape,g=m.length;h+=`${f}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}\t%c${a}\t%c${c}D ${d}\t%c${u}\t%c${h}\t%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Xee(n,t,e,r){const s=Je(t),i=function Yee(n,t,e,r){const s=ce(t),i=r[r.length-1],o=new Array(i).fill(0),a=t.length,l="complex64"===e?Of(n):n;if(a>1)for(let c=0;c<s/i;c++){const u=c*i;for(let d=0;d<i;d++)o[d]=Math.max(o[d],Mf(l[u+d],0,e).length)}return o}(n,t,e,s),o=t.length,a=Yy(n,t,e,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join("\n")),l.join("\n")}function Mf(n,t,e){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(7))} + ${parseFloat(n[1].toFixed(7))}j`:Nh(n)?`'${n}'`:"bool"===e?KP(n):parseFloat(n.toFixed(7)).toString(),du(r,t)}function KP(n){return 0===n?"false":"true"}function Yy(n,t,e,r,s,i=!0){const o="complex64"===e?2:1,a=t[0],l=t.length;if(0===l)return"complex64"===e?[Mf(Of(n)[0],0,e)]:"bool"===e?[KP(n[0])]:[n[0].toString()];if(1===l){if(a>20){let _=Array.from(n.slice(0,3*o)),y=Array.from(n.slice((a-3)*o,a*o));return"complex64"===e&&(_=Of(_),y=Of(y)),["["+_.map((v,b)=>Mf(v,s[b],e)).join(", ")+", ..., "+y.map((v,b)=>Mf(v,s[a-3+b],e)).join(", ")+"]"]}return["["+("complex64"===e?Of(n):Array.from(n)).map((g,_)=>Mf(g,s[_],e)).join(", ")+"]"]}const c=t.slice(1),u=r.slice(1),d=r[0]*o,h=[];if(a>20){for(let m=0;m<3;m++){const g=m*d;h.push(...Yy(n.slice(g,g+d),c,e,u,s,!1))}h.push("...");for(let m=a-3;m<a;m++){const g=m*d;h.push(...Yy(n.slice(g,g+d),c,e,u,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*d;h.push(...Yy(n.slice(g,g+d),c,e,u,s,m===a-1))}const f=2===l?",":"";h[0]="["+h[0]+f;for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+f;let p=",\n";for(let m=2;m<l;m++)p+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(i?"":p),h}function Of(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class $r{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=ce(t),null!=r){const s=r.length;S(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||os(e,this.size),this.strides=Je(t)}set(t,...e){0===e.length&&(e=[0]),S(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Li().makeTensor(this.values,this.shape,this.dtype)}}let Li=null,mu=null,XP=null;class Ln{constructor(t,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=ce(t),this.strides=Je(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return he(function*(){const e=yield t.data();return mu.buffer(t.shape,t.dtype,e)})()}bufferSync(){return mu.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return he(function*(){const e=yield t.data();return $i(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return $i(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return he(function*(){t.throwIfDisposed();const e=Li().read(t.dataId);if("string"===t.dtype){const r=yield e;try{return r.map(s=>pu(s))}catch(s){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),Li().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Li().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>pu(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return he(function*(){t.throwIfDisposed();const e=yield Li().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(Li().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return mu.print(this,t)}clone(){return this.throwIfDisposed(),mu.clone(this)}toString(t=!1){return Xee(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),mu.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),Li().makeVariable(this,t,e,r)}}function le(){return hC("Tensor",()=>Ln)}Object.defineProperty(Ln,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),le();class Zy extends Ln{constructor(t,e,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Ut(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Li().disposeTensor(this),this.dataId=t.dataId,Li().incRef(this,null)}dispose(){Li().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Zy,Symbol.hasInstance,{value:n=>n instanceof Ln&&null!=n.assign&&n.assign instanceof Function});var Qy=(()=>{return(n=Qy||(Qy={})).float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",Qy;var n})(),Jy=(()=>{return(n=Jy||(Jy={})).float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",Jy;var n})(),e_=(()=>{return(n=e_||(e_={})).float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",e_;var n})(),t_=(()=>{return(n=t_||(t_={})).float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",t_;var n})();const ete={float32:e_,int32:Qy,bool:Jy,complex64:t_};function _s(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return ete[n][t]}function fD(n){return _s(n,"int32")}function Nn(n,t){if(n.dtype===t.dtype)return[n,t];const e=_s(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function YP(n){const t=[];return ZP(n,t,new Set),t}function ZP(n,t,e){if(null==n)return;if(n instanceof Ln)return void t.push(n);if(!function tte(n){return Array.isArray(n)||"object"==typeof n}(n))return;const r=n;for(const s in r){const i=r[s];e.has(i)||(e.add(i),ZP(i,t,e))}}function pD(n){return null!=n.kernelName}class QP{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let nte=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new QP}ready(){var e=this;return he(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const i=r[s];if(yield e.initializeBackend(i).success)return void(yield e.setBackend(i))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(Vs(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return he(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:i}=r.initializeBackend(e);if(!(i?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new jee(r.backendInstance),!0})()}setupRegisteredKernels(){lD(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){lD(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof rC||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const i=++this.pendingBackendInitId,o=s.then(a=>!(i<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,Vs(`Initialization of backend ${e} failed`),Vs(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}}catch(s){return Vs(`Initialization of backend ${e} failed`),Vs(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:i,asyncInit:o}=this.initializeBackend(s);if(o||i)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),i=s.backend,o=this.readSync(r),a=i.refCount(r);i.disposeData(r,!0),s.backend=e,e.move(r,o,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let i,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=r(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,r,s){e();try{const i=s();return r(),i}catch(i){throw r(),i}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const r=$.runKernel(Jh,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>$.runKernel(Bh,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==aD(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const i=this.backend.numDataIds();let o=0;s.forEach(c=>{o+="complex64"===c.dtype?3:1});const l=i-r-o-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const i=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;let l,c;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const u=pD(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(pD(e)){const{kernelName:m,inputs:g,attrs:_}=e,y=aD(m,this.backendName);S(null!=y,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),l=()=>{const v=this.backend.numDataIds();c=y.kernelFunc({inputs:g,attrs:_,backend:this.backend});const b=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,v,b);const w=b.map(C=>{if(null!=C.rank)return C;const{dataId:E,shape:k,dtype:M}=C;return this.makeTensorFromDataId(E,k,M)});if(i){const C=this.getTensorsForGradient(m,g,w);s=this.saveTensorsForBackwardMode(C)}return w}}else{const{forwardFunc:m}=e,g=_=>{!i||(s=_.map(y=>this.keep(this.clone(y))))};l=()=>{const _=this.backend.numDataIds();c=this.tidy(()=>m(this.backend,g));const y=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,_,y),y}}const{inputs:d,attrs:h}=e,f=pD(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(u,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),r=p.outputs):r=l()}),i&&this.addTapeNode(u,d,r,f,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(m=>null!=d[m]?d[m].shape:null),outputShapes:r.map(m=>m.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(c)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const i=UP(e);if(null!=i){const o=i.inputsToSave||[],a=i.outputsToSave||[];let l;i.saveAllInputs?(S(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(u=>r[u])):l=o.map(u=>r[u]);const c=s.filter((u,d)=>a[d]);return l.concat(c)}return[]}makeTensor(e,r,s,i){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");i=i||this.backend;let o=e;"string"===(s=s||"float32")&&Nh(e[0])&&(o=e.map(c=>Ta(c)));const a=i.write(o,r,s),l=new Ln(r,s,a,this.nextTensorId());if(this.trackTensor(l,i),"string"===s){const c=this.state.tensorInfo.get(a),u=function See(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}(o);this.state.numBytes+=u-c.bytes,c.bytes=u}return l}makeTensorFromDataId(e,r,s,i){const o=new Ln(r,s=s||"float32",e,this.nextTensorId());return this.trackTensor(o,i),o}makeVariable(e,r=!0,s,i){s=s||this.nextVariableId().toString(),null!=i&&i!==e.dtype&&(e=e.cast(i));const o=new Zy(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*oC(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Zy||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*oC(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return he(function*(){r.state.profiling=!0;const s=r.state.numBytes,i=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-i;for(const o of r.state.activeProfile.kernels)o.kernelTimeMs=yield o.kernelTimeMs,o.extraInfo=yield o.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,i,o,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:o},c=UP(e);null!=c&&(i=c.gradFunc),null!=i&&(l.gradient=u=>(u=u.map((d,h)=>{if(null==d){const f=s[h],p=Pr(f.size,f.dtype);return this.makeTensor(p,f.shape,f.dtype)}return d}),i(u.length>1?u:u[0],o,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=YP(e),s=new Set(r.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!s.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(o=>{!o.kept&&o.scopeId===i.id&&this.track(o)})}gradients(e,r,s,i=!1){if(S(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));S(o instanceof Ln,()=>"The result y returned by f() must be a tensor.");const a=function qee(n,t,e){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const d in u){const h=u[d];let f=!1;for(let p=0;p<t.length;p++)if(r[h.id]){c.outputs.forEach(m=>r[m.id]=!0),f=!0,s[c.id]=!0;break}if(f)break}}const i={};i[e.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let d=0;d<c.outputs.length;d++)if(i[c.outputs[d].id]){for(const h in u)i[u[h].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(s[c.id]&&o[c.id]){const u={};for(const h in c.inputs){const f=c.inputs[h];r[f.id]&&(u[h]=f)}const d=Object.assign({},c);d.inputs=u,d.outputs=c.outputs,a.push(d)}}return a}(this.state.activeTape,r,o);if(!i&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[o.id]=null==s?function rte(n){const t=uC(ce(n),"float32");return $.makeTensor(t,n,"float32")}(o.shape):s,function Kee(n,t,e,r){for(let s=t.length-1;s>=0;s--){const i=t[s],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];o.push(null!=c?c:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=e(()=>a[l]());if("float32"!==c.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=i.inputs[l];if(!Ut(c.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(null==n[u.id])n[u.id]=c;else{const d=n[u.id];n[u.id]=r(d,c),d.dispose()}}}}(l,a,u=>this.tidy(u),ste);const c=r.map(u=>l[u.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(u=>{for(const d of u.saved)d.dispose()}),this.state.activeTape=null),{value:o,grads:c}})}customGrad(e){return S(lC(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;S(r.every(l=>l instanceof Ln),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const i={};return r.forEach((l,c)=>{i[c]=l}),this.runKernelFunc({forwardFunc:(l,c)=>(s=e(...r,c),S(s.value instanceof Ln,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),S(lC(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(l,c)=>{const u=s.gradFunc(l,c),d=Array.isArray(u)?u:[u];S(d.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),S(d.every(f=>f instanceof Ln),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((f,p)=>{h[p]=()=>f}),h},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return he(function*(){const s=as(),i=yield r.backend.time(e);return i.wallMs=as()-s,i})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new QP;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function JP(){const n=AP();if(null==n._tfengine){const t=new Iee(n);n._tfengine=new nte(t)}return function Aee(n){NP=n}(n._tfengine.ENV),function Zee(n){Li=n}(()=>n._tfengine),n._tfengine}const $=JP();function ste(n,t){return $.runKernel(hu,{a:n,b:t})}function e2(n){if(n||function ite(){return"undefined"!=typeof navigator&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function t2(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const li=ae();function Ff(n,t){let e=n;if(uo(n))return"string"===t?[]:[n.length];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(e)||uo(e)&&"string"!==t;)r.push(e.length),e=e[0];return Array.isArray(n)&&ae().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&n2(n,r,[]),r}function n2(n,t,e){if(e=e||[],!Array.isArray(n)&&!uo(n))return void S(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);S(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),S(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const r=t.slice(1);for(let s=0;s<n.length;++s)n2(n[s],r,e.concat(s))}function r2(n,t,e,r){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function T(n,t,e,r="numeric"){if(n instanceof Ln)return r2(r,n.dtype,t,e),n;let s=Ah(n);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),r2(r,s,t,e),null==n||!uo(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const i=Ff(n,s);!uo(n)&&!Array.isArray(n)&&(n=[n]);const a="string"!==s?Rl(n,s):cu(n,[],!0);return $.makeTensor(a,i,s)}function s2(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>T(i,`${t}[${o}]`,e,r))}function z(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+="__op";const s=(...i)=>{$.startScope(e);try{const o=r(...i);return TP(o)&&console.error("Cannot return a Promise inside of tidy."),$.endScope(o),o}catch(o){throw $.endScope(null),o}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}li.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),li.registerFlag("IS_BROWSER",()=>t2()),li.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),li.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),li.registerFlag("PROD",()=>!1),li.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>li.getBool("DEBUG")),li.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),li.registerFlag("IS_TEST",()=>!1),li.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),li.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),li.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const gu=z({complex_:function ate(n,t){const e=T(n,"real","complex"),r=T(t,"imag","complex");return ai(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),$.runKernel(vC,{real:e,imag:r})}});function Pf(n,t,e,r){if(null==r&&(r=Ah(n)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!uo(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){IP(t);const s=ce(t),i=ce(e);S(s===i,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<e.length;++o){const a=e[o],l=o!==e.length-1||a!==ce(t.slice(o));S(e[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!uo(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==r?Rl(n,r):cu(n,[],!0),$.makeTensor(n,t,r)}function n_(n,t,e){return Pf(n,t,Ff(n,e),e)}const gD={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function o2(n,t){return yD.apply(this,arguments)}function yD(){return yD=he(function*(n,t){const e=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const a=s[o],l=Array.isArray(n)?n[o].tensor:n[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const u=new Promise(function(){var d=he(function*(h){const f=yield l.bytes(),p=f.reduce((_,y)=>_+y.length,0)+4*f.length,m=new Uint8Array(p);let g=0;for(let _=0;_<f.length;_++){const y=f[_],v=new Uint8Array(new Uint32Array([y.length]).buffer);m.set(v,g),g+=4,m.set(y,g),g+=y.length}h(m)});return function(h){return d.apply(this,arguments)}}());r.push(u)}else r.push(l.data());null!=t&&(c.group=t),e.push(c)}return{data:lte(yield Promise.all(r)),specs:e}}),yD.apply(this,arguments)}function lte(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const r=new Uint8Array(t);let s=0;return e.forEach(i=>{r.set(new Uint8Array(i.buffer),s),s+=i.byteLength}),r.buffer}const _D="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function l2(n){return _D?Buffer.byteLength(n):new Blob([n]).size}function vD(n){if(1===n.length)return n[0];let t=0;n.forEach(s=>{t+=s.byteLength});const e=new Uint8Array(t);let r=0;return n.forEach(s=>{e.set(new Uint8Array(s),r),r+=s.byteLength}),e.buffer}function u2(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function bD(){return(bD=he(function*(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),null!=n.weightsManifest){const[r,s]=yield t(n.weightsManifest);e.weightSpecs=r,e.weightData=s}return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),e})).apply(this,arguments)}function s_(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:l2(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:l2(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:n.weightData.byteLength}}function pte(){const n=function dte(){const n=e=>{let r=e<<13,s=0;for(;0==(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function hte(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}(),e=function fte(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let o=0;o<r.length;o++){const a=r[o];i[o]=n[e[a>>10]+(1023&a)]+t[a>>10]}return new Float32Array(s)}}class Dn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Dn.instance&&(Dn.instance=new Dn),Dn.instance}static registerSaveRouter(t){Dn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Dn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Dn.getHandlers(t,"save")}static getLoadHandlers(t,e){return Dn.getHandlers(t,"load",e)}static getHandlers(t,e,r){const s=[];return("load"===e?Dn.getInstance().loadRouters:Dn.getInstance().saveRouters).forEach(o=>{const a=o(t,r);null!==a&&s.push(a)}),s}}const gte=(n,t)=>Dn.getLoadHandlers(n,t),i_="tensorflowjs",Ml="models_store",ka="model_info_store";function CD(){if(!ae().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n="undefined"==typeof window?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function DD(n){const t=n.result;t.createObjectStore(Ml,{keyPath:"modelPath"}),t.createObjectStore(ka,{keyPath:"modelPath"})}let yu=(()=>{class n{constructor(e){if(this.indexedDB=CD(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return he(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return he(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,i)=>{const o=this.indexedDB.open(i_,1);o.onupgradeneeded=()=>DD(o),o.onsuccess=()=>{const a=o.result;if(null==r){const l=a.transaction(Ml,"readonly"),u=l.objectStore(Ml).get(this.modelPath);u.onsuccess=()=>{if(null==u.result)return a.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(u.result.modelArtifacts)},u.onerror=d=>(a.close(),i(u.error)),l.oncomplete=()=>a.close()}else{const l=s_(r),c=a.transaction(ka,"readwrite");let u=c.objectStore(ka);const d=u.put({modelPath:this.modelPath,modelArtifactsInfo:l});let h;d.onsuccess=()=>{h=a.transaction(Ml,"readwrite");const p=h.objectStore(Ml).put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l});p.onsuccess=()=>s({modelArtifactsInfo:l}),p.onerror=m=>{u=c.objectStore(ka);const g=u.delete(this.modelPath);g.onsuccess=()=>(a.close(),i(p.error)),g.onerror=_=>(a.close(),i(p.error))}},d.onerror=f=>(a.close(),i(d.error)),c.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},o.onerror=a=>i(o.error)})}}return n.URL_SCHEME="indexeddb://",n})();const h2=n=>ae().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(yu.URL_SCHEME)?function yte(n){return new yu(n)}(n.slice(yu.URL_SCHEME.length)):null;Dn.registerSaveRouter(h2),Dn.registerLoadRouter(h2);class vte{constructor(){this.indexedDB=CD()}listModels(){var t=this;return he(function*(){return new Promise((e,r)=>{const s=t.indexedDB.open(i_,1);s.onupgradeneeded=()=>DD(s),s.onsuccess=()=>{const i=s.result,o=i.transaction(ka,"readonly"),l=o.objectStore(ka).getAll();l.onsuccess=()=>{const c={};for(const u of l.result)c[u.modelPath]=u.modelArtifactsInfo;e(c)},l.onerror=c=>(i.close(),r(l.error)),o.oncomplete=()=>i.close()},s.onerror=i=>r(s.error)})})()}removeModel(t){var e=this;return he(function*(){return t=function _te(n){return n.startsWith(yu.URL_SCHEME)?n.slice(yu.URL_SCHEME.length):n}(t),new Promise((r,s)=>{const i=e.indexedDB.open(i_,1);i.onupgradeneeded=()=>DD(i),i.onsuccess=()=>{const o=i.result,a=o.transaction(ka,"readwrite"),l=a.objectStore(ka),c=l.get(t);let u;c.onsuccess=()=>{if(null==c.result)return o.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=l.delete(t),h=()=>{u=o.transaction(Ml,"readwrite");const p=u.objectStore(Ml).delete(t);p.onsuccess=()=>r(c.result.modelArtifactsInfo),p.onerror=m=>s(c.error)};d.onsuccess=h,d.onerror=f=>(h(),o.close(),s(c.error))}},c.onerror=d=>(o.close(),s(c.error)),a.oncomplete=()=>{null==u?o.close():u.oncomplete=()=>o.close()}},i.onerror=o=>s(i.error)})})()}}const fo="/",Ol="tensorflowjs_models",f2="info",bte="model_topology",xte="weight_specs",wte="weight_data",Cte="model_metadata";function p2(n){return{info:[Ol,n,f2].join(fo),topology:[Ol,n,bte].join(fo),weightSpecs:[Ol,n,xte].join(fo),weightData:[Ol,n,wte].join(fo),modelMetadata:[Ol,n,Cte].join(fo)}}function m2(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function g2(n){const t=n.split(fo);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(fo)}let _u=(()=>{class n{constructor(e){if(!ae().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=p2(this.modelPath)}save(e){var r=this;return he(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),i=JSON.stringify(e.weightSpecs),o=s_(e);try{return r.LS.setItem(r.keys.info,JSON.stringify(o)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,i),r.LS.setItem(r.keys.weightData,function cte(n){if(_D)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let r=0,s=t.length;r<s;r++)e+=String.fromCharCode(t[r]);return btoa(e)}(e.weightData)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:o}}catch(a){throw m2(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}})()}load(){var e=this;return he(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},i=JSON.parse(e.LS.getItem(e.keys.topology));if(null==i)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=i;const o=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==o)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=o;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const c=JSON.parse(a);s.format=c.format,s.generatedBy=c.generatedBy,s.convertedBy=c.convertedBy,null!=c.signature&&(s.signature=c.signature),null!=c.userDefinedMetadata&&(s.userDefinedMetadata=c.userDefinedMetadata),null!=c.modelInitializer&&(s.modelInitializer=c.modelInitializer),null!=c.trainingConfig&&(s.trainingConfig=c.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function ute(n){if(_D){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}(l),s})()}}return n.URL_SCHEME="localstorage://",n})();const y2=n=>ae().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(_u.URL_SCHEME)?function Ste(n){return new _u(n)}(n.slice(_u.URL_SCHEME.length)):null;Dn.registerSaveRouter(y2),Dn.registerLoadRouter(y2);class Ete{constructor(){S(ae().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),S("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return he(function*(){const e={},r=Ol+fo,s=fo+f2;for(let i=0;i<t.LS.length;++i){const o=t.LS.key(i);o.startsWith(r)&&o.endsWith(s)&&(e[g2(o)]=JSON.parse(t.LS.getItem(o)))}return e})()}removeModel(t){var e=this;return he(function*(){const r=p2(t=function Dte(n){return n.startsWith(_u.URL_SCHEME)?n.slice(_u.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(e.LS.getItem(r.info));return m2(r),s})()}}class vs{constructor(){this.managers={}}static getInstance(){return null==vs.instance&&(vs.instance=new vs),vs.instance}static registerManager(t,e){S(null!=t,()=>"scheme must not be undefined or null."),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),S(t.length>0,()=>"scheme must not be an empty string.");const r=vs.getInstance();S(null==r.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}class Ite{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(ae().get("IS_BROWSER")){ae().setPlatform("browser",new Ite);try{vs.registerManager(_u.URL_SCHEME,new Ete)}catch(n){}try{vs.registerManager(yu.URL_SCHEME,new vte)}catch(n){}}let bu;function Nt(n,t="float32",e){return t=t||"float32",IP(n),new $r(n,t,e)}ae().get("IS_NODE")&&!ae().get("IS_BROWSER")&&ae().setPlatform("node",new class kte{constructor(){this.util=U(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=ae().global.fetch?ae().global.fetch(t,e):(null==bu&&(bu=U(410)),bu(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const Ne=z({cast_:function Nte(n,t){const e=T(n,"x","cast");if(!function Dee(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return $.runKernel(Bh,{x:e},{dtype:t})}}),Fl=z({clone_:function Ate(n){const e={x:T(n,"x","clone","string_or_numeric")};return $.runKernel(Jh,e)}});function v2(n){return new Promise(t=>setTimeout(t)).then(n)}JP(),function Qee(n){mu=n}({buffer:Nt,cast:Ne,clone:Fl,print:function Rte(n,t=!1){console.log(n.toString(t))}});let ND=(()=>{class n{constructor(e){if(!ae().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return he(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const o=u2(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),l=null==r.modelJsonAnchor?document.createElement("a"):r.modelJsonAnchor;if(l.download=r.modelJsonFileName,l.href=a,yield v2(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const c=null==r.weightDataAnchor?document.createElement("a"):r.weightDataAnchor;c.download=r.weightDataFileName,c.href=s,yield v2(()=>c.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:s_(e)}}})()}}return n.URL_SCHEME="downloads://",n})();function b2(n,t,e,r){(function o(l){S(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(n),function a(l,c){S(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),S(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),S(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}(e=null==e?0:e,r=null==r?1:r);let s=0;return Promise.all(n.map(l=>(l.then(c=>{const u=e+ ++s/n.length*(r-e);return t(u),c}),l)))}function x2(n,t){return AD.apply(this,arguments)}function AD(){return(AD=he(function*(n,t){null==t&&(t={});const e=null==t.fetchFunc?ae().platform.fetch:t.fetchFunc,r=n.map(d=>e(d,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?yield Promise.all(r):yield b2(r,t.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==t.onProgress?yield Promise.all(a):yield b2(a,t.onProgress,.5,1)})).apply(this,arguments)}Dn.registerSaveRouter(n=>ae().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ND.URL_SCHEME)?function Lte(n="model"){return new ND(n)}(n.slice(ND.URL_SCHEME.length)):null);let w2=(()=>{class n{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(S("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=ae().platform.fetch,S(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&S(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return he(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const o=u2(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);s.body.append("model.json",new Blob([JSON.stringify(o)],{type:"application/json"}),"model.json"),null!=e.weightData&&s.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:s_(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return he(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch(a){let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==s.modelTopology&&null==s.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return function d2(n,t){return bD.apply(this,arguments)}(s,a=>e.loadWeights(a))})()}loadWeights(e){var r=this;return he(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[i,o]=function Ute(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(s),a=r.weightPathPrefix||i,l=[];for(const h of e)l.push(...h.weights);const c=[],u=[];for(const h of e)for(const f of h.paths)null!=r.weightUrlConverter?u.push(r.weightUrlConverter(f)):c.push(a+f+o);return r.weightUrlConverter&&c.push(...yield Promise.all(u)),[l,vD(yield x2(c,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function C2(n){return null!=n.match(w2.URL_SCHEME_REGEX)}const D2=(n,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(r=>C2(r)):C2(n),e)return S2(n,t)}return null};function S2(n,t){return new w2(n,t)}function Hte(n,t){return S2(n,t)}function xu(n,t){const e=n.length,r=[];for(let s=0;s<e;s++){const i=e-1-s,o=n[i]||1;(t[t.length-1-s]||1)>1&&1===o&&r.unshift(i)}return r}function er(n,t){const e=[];for(let r=0;r<t.length;r++){const s=n[n.length-r-1],i=t.length-r-1,o=t[i];(null==s||1===s&&o>1)&&e.unshift(i)}return e}function gt(n,t){const e=[],r=Math.max(n.length,t.length);for(let s=0;s<r;s++){let i=n[n.length-s-1];null==i&&(i=1);let o=t[t.length-s-1];if(null==o&&(o=1),1===i)e.unshift(o);else if(1===o)e.unshift(i);else{if(i!==o)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);e.unshift(i)}}return e}let Pl;Dn.registerSaveRouter(D2),Dn.registerLoadRouter(D2);const Yte=z({fromPixels_:function E2(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==n)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,s=!1,i=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)e=!0;else if("undefined"!=typeof ImageData&&n instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&n instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement)i=!0;else if(null!=n.getContext)o=!0;else{if(!("undefined"!=typeof ImageBitmap&&n instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);a=!0}if(s&&s&&n.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(null!=aD(iD,$.backendName))return $.runKernel(iD,{pixels:n},{numChannels:t});const[c,u]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let d,h;if(o)d=n.getContext("2d").getImageData(0,0,c,u).data;else if(r||e)d=n.data;else if(i||s||a){if(null==Pl)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Pl=new OffscreenCanvas(1,1).getContext("2d")}else Pl=document.createElement("canvas").getContext("2d");Pl.canvas.width=c,Pl.canvas.height=u,Pl.drawImage(n,0,0,c,u),d=Pl.getImageData(0,0,c,u).data}if(4===t)h=new Int32Array(d);else{const p=c*u;h=new Int32Array(p*t);for(let m=0;m<p;m++)for(let g=0;g<t;++g)h[m*t+g]=d[4*m+g]}return function Wte(n,t,e){if(sC(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Ff(n,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Pf(n,t,r,e)}(h,[u,c,t],"int32")}});function $D(n,t,e){const r=n.shape.length;S(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),S(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)S(t[s]+e[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+e[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function Qte(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function LD(n,t,e){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((t[s]-n[s])/e[s]);return r}function I2(n,t,e,r){const s=[...n];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<e;i++)0===i?s[t]=1:(s.splice(t,0,1),s.pop());return s}function T2(n,t,e){return e<=n?e:e-(t-1)}function k2(n,t){const e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function Jte(n,t,e,r,s,i,o,a,l){const c=n.length;let u=new Array(c),d=new Array(c),h=new Array(c);if(t.length&&e>0){const f=t[0],p=e+1;u=N2(o,f,p,r,n),d=A2(a,f,p,s,n),h=I2(i,f,p,n)}else for(let f=0;f<c;f++)u[f]=M2(o,r,i,n,f,l),d[f]=O2(a,s,i,n,f,l),h[f]=R2(i,f,l);return{begin:u,end:d,strides:h}}function N2(n,t,e,r,s){const i=[...s],o=k2(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=T2(t,e,a);let c=r[l];n&1<<l&&(c=0),i[a]=c}return i}function A2(n,t,e,r,s){const i=[...s],o=k2(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=T2(t,e,a);let c=r[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++){const l=s[a];i[a]<0&&(i[a]+=l),i[a]=kl(0,i[a],s[a])}return i}function R2(n,t,e){let r=n[t];return(e&1<<t||null==r)&&(r=1),r}function M2(n,t,e,r,s,i){let o=t[s];(n&1<<s||i&1<<s||null==o)&&(o=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=kl(0,o,l-1),o}function O2(n,t,e,r,s,i){let o=t[s];const a=e[s]||1;(n&1<<s||i&1<<s||null==o)&&(o=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=a>0?kl(0,o,l):kl(-1,o,l-1),o}function VD(n,t,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(t[s]>0||e[s]!==n[s])return!1;return!0}function BD(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function a_(n,t,e){let r;const s=n.shape.length;let i;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(o=>{S(-1!==o,()=>"slice() does not support negative begin indexing.")}),i=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,i=i.map((o,a)=>o>=0?o:(S(-1===o,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,i]}function zD(n,t,e,r,s,i,o,a,l){let c;if(null==r?(c=new Array(t.length),c.fill(1)):c=r,null!=o&&0!=(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:c.slice(),beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let v=0;v<d.dims;v++)u&&0!=(1<<v&a)&&d.numAddAxisAfterEllipsis++,1<<v&o&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function ene(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<s;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[r]),null!=n.end&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}(d,h);let f=!0,p=!0,m=!0;const g=[],_=[];for(let v=0;v<n.length;++v){if(0===h.strides[v])throw Error(`strides[${v}] must be non-zero`);const b=!!(h.shrinkAxisMask&1<<v),w=n[v];if(-1===w){g.push(b?1:-1);continue}const C=[h.beginMask&1<<v,h.endMask&1<<v],E=[h.strides[v]>0?0:-1,h.strides[v]>0?w:w-1];if(b&&h.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[v];const k=!!(h.beginMask&1<<v&&h.endMask&1<<v);if(h.beginValid&&h.endValid){if(b){const X=h.begin[v]<0?w+h.begin[v]:h.begin[v];if(h.begin[v]=X,h.end[v]=h.begin[v]+1,X<0||X>=w)throw Error(`slice index ${h.begin[v]} of dimension ${v} out of bounds.`)}else h.begin[v]=F2(h.begin[v],0,h.strides[v],w,C,E),h.end[v]=F2(h.end[v],1,h.strides[v],w,C,E);const K=1===h.strides[v]&&0===h.begin[v]&&h.end[v]===w;f=f&&K,p=p&&(0===v&&1===h.strides[v]||K)}else f=f&&1===h.strides[v]&&k,p=p&&(0===v&&1===h.strides[v]||k);let M,O=!1;if(h.beginValid&&h.endValid?(M=h.end[v]-h.begin[v],O=!0):b?(M=1,O=!0):k&&w>=0&&(M=h.strides[v]<0?-w:w,O=!0),O){let K;K=0===M||M<0!=h.strides[v]<0?0:Math.trunc(M/h.strides[v])+(M%h.strides[v]!=0?1:0),g.push(K)}else g.push(-1)}for(let v=0;v<h.finalShapeGatherIndices.length;++v){const b=h.finalShapeGatherIndices[v];b>=0?_.push(g[b]):-2===b&&_.push(1)}return{finalShapeSparse:_.filter((v,b)=>-2!==h.finalShapeGatherIndices[b]),finalShape:_,isIdentity:f,sliceDim0:p,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function F2(n,t,e,r,s,i){if(s[t])return e>0?i[t]:i[t+1&1];{const o=n<0?r+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}class wu{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class ci{constructor(){this.classNameMap={}}static getMap(){return null==ci.instance&&(ci.instance=new ci),ci.instance}static register(t){ci.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function ge(n){S(null!=n.className,()=>"Class being registered does not have the static className property defined."),S("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),S(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),ci.register(n)}function Na(){return $}function UD(){return $.memory()}function te(n,t){return $.tidy(n,t)}function St(n){YP(n).forEach(e=>e.dispose())}function po(n){return $.keep(n)}function P2(n,t,e=1){return $.registerBackend(n,t,e)}function Wo(n){return $.customGrad(n)}function lt(n,t){if((uo(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&uo(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Pf(n,[],[],t)}!function Jee(n){XP=n}(function nne(n){ae().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});class Aa extends wu{minimize(t,e=!1,r){const{value:s,grads:i}=this.computeGradients(t,r);if(null!=r){const o=r.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return St(i),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function sne(n,t){S(lC(n),()=>"The f passed in variableGrads(f) must be a function"),S(null==t||Array.isArray(t)&&t.every(c=>c instanceof Zy),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const c in $.registeredVariables)t.push($.registeredVariables[c])}const r=e?t.filter(c=>!c.trainable):null,s=t.length;S((t=t.filter(c=>c.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:o,grads:a}=$.gradients(n,t,null,!0);S(a.some(c=>null!=c),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),S(0===o.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return t.forEach((c,u)=>{null!=a[u]&&(l[c.name]=a[u])}),null!=r&&r.forEach(c=>l[c.name]=null),{value:o,grads:l}}(t,e)}dispose(){null!=this.iterations_&&St(this.iterations_)}saveIterations(){var t=this;return he(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:lt(t.iterations_,"int32")}})()}getWeights(){return he(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return he(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return he(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(Aa,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});const mr=z({abs_:function ine(n){const t=T(n,"x","abs");return $.runKernel("complex64"===t.dtype?Qg:Wg,{x:t})}}),we=z({add_:function one(n,t){let e=T(n,"a","add"),r=T(t,"b","add");return[e,r]=Nn(e,r),$.runKernel(hu,{a:e,b:r})}}),$2=z({all_:function ane(n,t=null,e=!1){const s={x:T(n,"x","all","bool")};return $.runKernel("All",s,{axis:t,keepDims:e})}}),HD=z({any_:function lne(n,t=null,e=!1){const s={x:T(n,"x","any","bool")};return $.runKernel("Any",s,{axis:t,keepDims:e})}}),$f=z({argMax_:function cne(n,t=0){const r={x:T(n,"x","argMax")};return $.runKernel(Gg,r,{axis:t})}});function Lf(n,t,e,r,s="NHWC",i){return gr(n,[...t,n[3]],e,i,r,null,null,qo(s))}function ui(n,t,e,r,s,i,o="channelsLast"){const[a,l]=c_(t);let c;if("channelsLast"===o)c=[a,l,n[3],n[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);c=[a,l,n[1],n[1]]}return gr(n,c,e,r,s,i,!1,o)}function Go(n,t,e,r,s,i,o="NDHWC"){const[a,l,c]=WD(t);let u,d;if("NDHWC"===o)d="channelsLast",u=[a,l,c,n[4],n[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",u=[a,l,c,n[1],n[1]]}return Ra(n,u,e,r,s,!1,d,i)}function gr(n,t,e,r,s,i,o=!1,a="channelsLast"){let[l,c,u,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,c,u,d]=n;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,c,u]=n}const[h,f,,p]=t,[m,g]=c_(e),[_,y]=c_(r),v=Cu(h,_),b=Cu(f,y),{padInfo:w,outHeight:C,outWidth:E}=function hne(n,t,e,r,s,i,o,a,l){let c,u,d;if("number"==typeof n){c={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const f=function une(n,t,e,r,s){null==r&&(r=jD(n,t,e));const o=n[1];return[$l((n[0]-t+2*r)/e+1,s),$l((o-t+2*r)/e+1,s)]}([t,e],i,r,n,a);u=f[0],d=f[1]}else if("same"===n){u=Math.ceil(t/r),d=Math.ceil(e/s);const h=Math.max(0,(u-1)*r+i-t),f=Math.max(0,(d-1)*s+o-e),p=Math.floor(h/2),m=h-p,g=Math.floor(f/2);c={top:p,bottom:m,left:g,right:f-g,type:"SAME"}}else if("valid"===n)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-i+1)/r),d=Math.ceil((e-o+1)/s);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const h="channelsLast"===l?n[1][0]:n[2][0],f="channelsLast"===l?n[1][1]:n[2][1],p="channelsLast"===l?n[2][0]:n[3][0],m="channelsLast"===l?n[2][1]:n[3][1];c={top:h,bottom:f,left:p,right:m,type:0===h&&0===f&&0===p&&0===m?"VALID":"EXPLICIT"},u=$l((t-i+h+f)/r+1,a),d=$l((e-o+p+m)/s+1,a)}}return{padInfo:c,outHeight:u,outWidth:d}}(s,c,u,m,g,v,b,i,a),k=o?p*d:p;let M;return"channelsFirst"===a?M=[l,k,C,E]:"channelsLast"===a&&(M=[l,C,E,k]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:d,outHeight:C,outWidth:E,outChannels:k,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:f,effectiveFilterHeight:v,effectiveFilterWidth:b,dilationHeight:_,dilationWidth:y,inShape:n,outShape:M,filterShape:t}}function Ra(n,t,e,r,s,i=!1,o="channelsLast",a){let[l,c,u,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,c,u,d,h]=n;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,c,u,d]=n}const[f,p,m,,g]=t,[_,y,v]=WD(e),[b,w,C]=WD(r),E=Cu(f,b),k=Cu(p,w),M=Cu(m,C),{padInfo:O,outDepth:K,outHeight:X,outWidth:Q}=function fne(n,t,e,r,s,i,o,a,l,c,u){let d,h,f,p;if("number"==typeof n){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const g=function dne(n,t,e,r,s,i){null==s&&(s=jD(n,t,r));const a=n[1],l=n[2];return[$l((n[0]-t+2*s)/r+1,i),$l((a-t+2*s)/r+1,i),$l((l-t+2*s)/r+1,i),e]}([t,e,r,1],a,1,s,n,u);h=g[0],f=g[1],p=g[2]}else if("same"===n){h=Math.ceil(t/s),f=Math.ceil(e/i),p=Math.ceil(r/o);const m=(h-1)*s+a-t,g=(f-1)*i+l-e,_=(p-1)*o+c-r,y=Math.floor(m/2),v=m-y,b=Math.floor(g/2),w=g-b,C=Math.floor(_/2);d={top:b,bottom:w,left:C,right:_-C,front:y,back:v,type:"SAME"}}else{if("valid"!==n)throw Error(`Unknown padding parameter: ${n}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((t-a+1)/s),f=Math.ceil((e-l+1)/i),p=Math.ceil((r-c+1)/o)}return{padInfo:d,outDepth:h,outHeight:f,outWidth:p}}(s,c,u,d,_,y,v,E,k,M,a),re=i?g*h:g;let ne;return"channelsFirst"===o?ne=[l,re,K,X,Q]:"channelsLast"===o&&(ne=[l,K,X,Q,re]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:d,inChannels:h,outDepth:K,outHeight:X,outWidth:Q,outChannels:re,padInfo:O,strideDepth:_,strideHeight:y,strideWidth:v,filterDepth:f,filterHeight:p,filterWidth:m,effectiveFilterDepth:E,effectiveFilterHeight:k,effectiveFilterWidth:M,dilationDepth:b,dilationHeight:w,dilationWidth:C,inShape:n,outShape:ne,filterShape:t}}function jD(n,t,e,r=1){const s=Cu(t,r);return Math.floor((n[0]*(e-1)-e+s)/2)}function c_(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function WD(n){return"number"==typeof n?[n,n,n]:n}function Cu(n,t){return t<=1?n:n+(n-1)*(t-1)}function $l(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function Ma(n){const[t,e,r]=c_(n);return 1===t&&1===e&&1===r}function Er(n,t){return Ma(n)||Ma(t)}function qo(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Gr(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)S(uu(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(r=>{r.forEach(s=>{S(uu(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${s}.`)})})}}}const j=z({reshape_:function pne(n,t){const r={x:T(n,"x","reshape","string_or_numeric")};return $.runKernel(Ay,r,{shape:t})}}),GD=z({avgPool_:function mne(n,t,e,r,s){const i=T(n,"x","avgPool","float32");S(Er(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=i,l=!1;3===i.rank&&(l=!0,a=j(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Gr("avgPool",r,s);let d=$.runKernel(Kg,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return d=Ne(d,i.dtype),l?j(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),yne=z({avgPool3d_:function gne(n,t,e,r,s,i="NDHWC"){const o=T(n,"x","avgPool3d","float32");let a=o,l=!1;4===o.rank&&(l=!0,a=j(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===i,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Gr("avgPool3d",r,s);let d=$.runKernel(Xg,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:i});return d=Ne(d,a.dtype),l?j(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});function _ne(n){let t;return t=0===n.rank||1===n.rank?j(n,[1,1,1,n.size]):2===n.rank?j(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?j(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const u_=z({batchNorm_:function vne(n,t,e,r,s,i){null==i&&(i=.001);const o=T(n,"x","batchNorm"),a=T(t,"mean","batchNorm"),l=T(e,"variance","batchNorm");let c,u;null!=s&&(c=T(s,"scale","batchNorm")),null!=r&&(u=T(r,"offset","batchNorm")),S(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:_ne(o),scale:c,offset:u,mean:a,variance:l},p=$.runKernel(ly,h,{varianceEpsilon:i});return j(p,o.shape)}}),xne=z({batchNorm2d_:function bne(n,t,e,r,s,i){const o=T(n,"x","batchNorm"),a=T(t,"mean","batchNorm"),l=T(e,"variance","batchNorm");let c,u;return null!=s&&(c=T(s,"scale","batchNorm")),null!=r&&(u=T(r,"offset","batchNorm")),S(2===o.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),S(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),S(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=c&&S(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),null!=u&&S(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),u_(o,a,l,u,c,i)}}),Cne=z({batchNorm3d_:function wne(n,t,e,r,s,i){const o=T(n,"x","batchNorm"),a=T(t,"mean","batchNorm"),l=T(e,"variance","batchNorm");let c,u;return null!=s&&(c=T(s,"scale","batchNorm")),null!=r&&(u=T(r,"offset","batchNorm")),S(3===o.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),S(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),S(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=c&&S(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),null!=u&&S(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),u_(o,a,l,u,c,i)}}),Sne=z({batchNorm4d_:function Dne(n,t,e,r,s,i){const o=T(n,"x","batchNorm"),a=T(t,"mean","batchNorm"),l=T(e,"variance","batchNorm");let c,u;return null!=s&&(c=T(s,"scale","batchNorm")),null!=r&&(u=T(r,"offset","batchNorm")),S(4===o.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),S(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),S(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=c&&S(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),null!=u&&S(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),u_(o,a,l,u,c,i)}}),Bs=z({clipByValue_:function Ene(n,t,e){const r=T(n,"x","clipByValue");return S(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),$.runKernel(Uh,{x:r},{clipValueMin:t,clipValueMax:e})}}),Lr=z({concat_:function Ine(n,t=0){S(n.length>=1,()=>"Pass at least one tensor to concat");const e=s2(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(i=>{if("complex64"!==i.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${i.dtype}. `)}),1===e.length?Fl(e[0]):$.runKernel(Jg,e,{axis:t})}}),kne=z({concat1d_:function Tne(n){return Lr(n,0)}}),Ane=z({concat2d_:function Nne(n,t){return Lr(n,t)}}),Mne=z({concat3d_:function Rne(n,t){return Lr(n,t)}}),Fne=z({concat4d_:function One(n,t){return Lr(n,t)}}),Ll=z({conv2d_:function Pne(n,t,e,r,s="NHWC",i=[1,1],o){const a=T(n,"x","conv2d","float32"),l=T(t,"filter","conv2d","float32");let c=a,u=!1;3===a.rank&&(u=!0,c=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===c.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Gr("conv2d",r,o);const d="NHWC"===s?c.shape[3]:c.shape[1];S(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),S(Er(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const p=$.runKernel(ey,{x:c,filter:l},{strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return u?j(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),L2=z({conv1d_:function $ne(n,t,e,r,s="NWC",i=1,o){const a=T(n,"x","conv1d"),l=T(t,"filter","conv1d");let c=a,u=!1;2===a.rank&&(u=!0,c=j(a,[1,a.shape[0],a.shape[1]])),S(3===c.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),S(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Gr("conv1d",r,o),S(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),S(Er(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),S("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=j(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=j(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=Ll(h,d,[1,e],r,"NHWC",[1,i],o);return j(g,u?[g.shape[2],g.shape[3]]:[g.shape[0],g.shape[2],g.shape[3]])}}),qD=z({conv2DBackpropInput_:function Lne(n,t,e,r,s,i="NHWC",o){S(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,l=t,c=!1;3===t.rank&&(c=!0,l=j(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),S(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),S(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),S(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const u="NHWC"===i?a[3]:a[1],d="NHWC"===i?l.shape[3]:l.shape[1];S(u===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[2]}.`),S(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),Gr("conv2dDerInput",s,o);const p=$.runKernel(ty,{dy:l,filter:e},{strides:r,pad:s,dataFormat:i,dimRoundingMode:o,inputShape:a});return c?j(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),V2=z({conv2dTranspose_:function Vne(n,t,e,r,s,i){const o=T(n,"x","conv2dTranspose"),a=T(t,"filter","conv2dTranspose");return qD(e,o,a,r,s,"NHWC",i)}}),zne=z({conv3d_:function Bne(n,t,e,r,s="NDHWC",i=[1,1,1]){const o=T(n,"x","conv3d"),a=T(t,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=j(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),S(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),S(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),S(Er(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),S("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const h=$.runKernel(ny,{x:l,filter:a},{strides:e,pad:r,dataFormat:s,dilations:i});return c?j(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),B2=z({conv3DBackpropInput_:function Une(n,t,e,r,s){S(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,o=t,a=!1;4===t.rank&&(a=!0,o=j(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],c=o.shape[4];S(5===i.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),S(5===o.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),S(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),S(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),S(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);const h=$.runKernel(wC,{dy:o,filter:e},{pad:s,strides:r,inputShape:i});return a?j(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),jne=z({conv3dTranspose_:function Hne(n,t,e,r,s){const i=T(n,"x","conv3dTranspose"),o=T(t,"filter","conv3dTranspose");return B2(e,i,o,r,s)}}),d_=z({depthwiseConv2d_:function Wne(n,t,e,r,s="NHWC",i=[1,1],o){const a=T(n,"x","depthwiseConv2d","float32"),l=T(t,"filter","depthwiseConv2d","float32");let c=a,u=!1;3===a.rank&&(u=!0,c=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===c.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),S(c.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),Gr("depthwiseConv2d",r,o);const f=$.runKernel(sy,{x:c,filter:l},{strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return u?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),z2=z({floorDiv_:function Gne(n,t){let e=T(n,"a","floorDiv"),r=T(t,"b","floorDiv");return[e,r]=Nn(e,r),$.runKernel(Zh,{a:e,b:r})}}),Ze=z({div_:function qne(n,t){let e=T(n,"a","div"),r=T(t,"b","div");return[e,r]=Nn(e,r),"int32"===e.dtype&&"int32"===r.dtype?z2(e,r):$.runKernel(Wh,{a:e,b:r},{})}}),h_=z({elu_:function Kne(n){const e={x:T(n,"x","elu","float32")};return $.runKernel(Gh,e)}}),mo=z({equal_:function Xne(n,t){let e=T(n,"a","equal","string_or_numeric"),r=T(t,"b","equal","string_or_numeric");return[e,r]=Nn(e,r),gt(e.shape,r.shape),$.runKernel(oy,{a:e,b:r})}}),di=z({exp_:function Yne(n){const e={x:T(n,"x","exp")};return $.runKernel(Kh,e)}}),hi=z({expandDims_:function Zne(n,t=0){const e=T(n,"x","expandDims","string_or_numeric");return S(t<=e.rank,()=>"Axis must be <= rank of the tensor"),$.runKernel(ay,{input:e},{dim:t})}}),Vi=z({tile_:function Qne(n,t){const e=T(n,"x","tile","string_or_numeric");return S(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),$.runKernel(kf,{x:e},{reps:t})}}),U2=z({eye_:function Jne(n,t,e,r="float32"){null==t&&(t=n);const s=Nt([n,t],r),i=n<=t?n:t;for(let a=0;a<i;++a)s.set(1,a,a);const o=j(s.toTensor(),[n,t]);if(null==e)return o;if(1===e.length)return Vi(hi(o,0),[e[0],1,1]);if(2===e.length)return Vi(hi(hi(o,0),0),[e[0],e[1],1,1]);if(3===e.length)return Vi(hi(hi(hi(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}});function f_(n,t,e){return $.runKernel(RC,{},{shape:n,value:t,dtype:e})}const p_=z({floor_:function ere(n){const e={x:T(n,"x","floor","float32")};return $.runKernel(Yh,e)}}),KD=z({gather_:function tre(n,t,e=0,r=0){const s=T(n,"x","gather"),i=T(t,"indices","gather","int32");return $.runKernel(cy,{x:s,indices:i},{axis:e,batchDims:r})}}),fi=z({greater_:function nre(n,t){let e=T(n,"a","greater","string_or_numeric"),r=T(t,"b","greater","string_or_numeric");return[e,r]=Nn(e,r),gt(e.shape,r.shape),$.runKernel(uy,{a:e,b:r})}}),Du=z({greaterEqual_:function rre(n,t){let e=T(n,"a","greaterEqual","string_or_numeric"),r=T(t,"b","greaterEqual","string_or_numeric");return[e,r]=Nn(e,r),gt(e.shape,r.shape),$.runKernel(Qh,{a:e,b:r})}}),XD=z({leakyRelu_:function sre(n,t=.2){const r={x:T(n,"x","leakyRelu")};return $.runKernel(dy,r,{alpha:t})}}),pi=z({log_:function ire(n){const e={x:T(n,"x","log","float32")};return $.runKernel(sf,e)}}),YD=z({log1p_:function ore(n){const e={x:T(n,"x","log1p")};return $.runKernel(af,e)}}),go=z({max_:function are(n,t=null,e=!1){const s={x:T(n,"x","max")};return $.runKernel(_y,s,{reductionIndices:t,keepDims:e})}}),P=z({mul_:function lre(n,t){let e=T(n,"a","mul"),r=T(t,"b","mul");return[e,r]=Nn(e,r),$.runKernel(df,{a:e,b:r})}}),Ue=z({sub_:function cre(n,t){let e=T(n,"a","sub"),r=T(t,"b","sub");return[e,r]=Nn(e,r),$.runKernel(Ef,{a:e,b:r})}}),He=z({sum_:function ure(n,t=null,e=!1){let r=T(n,"x","sum");return"bool"===r.dtype&&(r=Ne(r,"int32")),$.runKernel($y,{x:r},{axis:t,keepDims:e})}}),H2=z({logSoftmax_:function dre(n,t=-1){const e=T(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Wo((s,i)=>{const a=go(s,t,!0),l=Ue(s,a),c=Ue(Ne(l,"float32"),pi(He(di(l),t,!0)));return i([c]),{value:c,gradFunc:(d,h)=>{const[f]=h,m=di(f);return Ue(d,P(He(d,t,!0),m))}}})(e)}}),Ko=z({logicalAnd_:function hre(n,t){const e=T(n,"a","logicalAnd","bool"),r=T(t,"b","logicalAnd","bool");return gt(e.shape,r.shape),$.runKernel(py,{a:e,b:r})}}),Ht=z({matMul_:function fre(n,t,e=!1,r=!1){let s=T(n,"a","matMul"),i=T(t,"b","matMul");return[s,i]=Nn(s,i),$.runKernel(Yg,{a:s,b:i},{transposeA:e,transposeB:r})}}),ZD=z({maxPool_:function pre(n,t,e,r,s){const i=T(n,"x","maxPool");let a=i,l=!1;3===i.rank&&(l=!0,a=j(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),S(Er(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),Gr("maxPool",r,s);const d=$.runKernel(vy,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return l?j(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),gre=z({maxPool3d_:function mre(n,t=[1,1,1],e,r,s,i="NDHWC"){const o=T(n,"x","maxPool3d");let a=o,l=!1;4===o.rank&&(l=!0,a=j(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===i,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Gr("maxPool3d",r,s);const d=$.runKernel(by,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:i});return l?j(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Oa=z({maximum_:function yre(n,t){let e=T(n,"a","maximum"),r=T(t,"b","maximum");return[e,r]=Nn(e,r),"bool"===e.dtype&&(e=Ne(e,"int32"),r=Ne(r,"int32")),gt(e.shape,r.shape),$.runKernel(lf,{a:e,b:r})}}),Vn=z({mean_:function _re(n,t=null,e=!1){const s={x:T(n,"x","mean")};return $.runKernel(xy,s,{axis:t,keepDims:e})}}),m_=z({minimum_:function vre(n,t){let e=T(n,"a","minimum"),r=T(t,"b","minimum");return[e,r]=Nn(e,r),"bool"===e.dtype&&(e=Ne(e,"int32"),r=Ne(r,"int32")),gt(e.shape,r.shape),$.runKernel(cf,{a:e,b:r})}});function QD(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function j2(n,t,e){const r=n.length+t.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?s.push(n[i++]):s.push(t[o++]);return s}function yr(n,t){const e=[],r=n.length;for(let i=0;i<r;i++)-1===t.indexOf(i)&&e.push(n[i]);return[e,t.map(i=>n[i])]}function Bn(n,t){return j2(n,t.map(r=>1),t)}function Ir(n,t,e){S(QD(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function Sn(n,t){if(QD(n,t))return null;const e=[];for(let r=0;r<t;++r)-1===n.indexOf(r)&&e.push(r);return n.forEach(r=>e.push(r)),e}function Fa(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function An(n,t){const e=[];for(let r=t-n;r<t;++r)e.push(r);return e}const an=z({square_:function bre(n){const t=T(n,"x","square");return $.runKernel("Square",{x:t},{})}}),JD=z({moments_:function xre(n,t=null,e=!1){const r=It(t,(n=T(n,"x","moments")).shape),s=Vn(n,r,e);let i=s.shape;e||(i=Bn(s.shape,r));const o=an(Ue(Ne(n,"float32"),j(s,i)));return{mean:s,variance:Vn(o,r,e)}}}),Rn=z({neg_:function wre(n){const e={x:T(n,"x","neg")};return $.runKernel(Dy,e)}}),Vf=z({notEqual_:function Cre(n,t){let e=T(n,"a","notEqual","string_or_numeric"),r=T(t,"b","notEqual","string_or_numeric");return[e,r]=Nn(e,r),gt(e.shape,r.shape),$.runKernel(Sy,{a:e,b:r})}}),W2=z({oneHot_:function Dre(n,t,e=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const i={indices:T(n,"indices","oneHot","int32")};return $.runKernel(Iy,i,{depth:t,onValue:e,offValue:r})}});function _r(n,t="float32"){if("complex64"===t){const r=_r(n,"float32"),s=_r(n,"float32");return gu(r,s)}const e=Pr(ce(n),t);return $.makeTensor(e,n,t)}function Pa(n,t="float32"){if("complex64"===t){const r=Pa(n,"float32"),s=_r(n,"float32");return gu(r,s)}const e=uC(ce(n),t);return $.makeTensor(e,n,t)}const mi=z({onesLike_:function Sre(n){const e={x:T(n,"x","onesLike")};return $.runKernel(Ey,e)}}),eS=z({pad_:function Ere(n,t,e=0){const r=T(n,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return $.runKernel(ky,{x:r},{paddings:t,constantValue:e})}}),tS=z({prelu_:function Ire(n,t){const e=T(n,"x","prelu"),r=T(t,"alpha","prelu");return $.runKernel(Ny,{x:e,alpha:r})}});var G2=U(349);class nS{constructor(t,e,r,s,i){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=i||Math.random();this.random=G2.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,e,r=!1;for(;!r;){let s,i,o;do{s=2*this.random()-1,i=2*this.random()-1,o=s*s+i*i}while(o>=1||0===o);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class Tre{constructor(t=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=G2.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Mre=z({randomNormal_:function Rre(n,t=0,e=1,r,s){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const i=new nS(t,e,r,!1,s),o=Nt(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),g_=z({randomUniform_:function Ore(n,t=0,e=1,r="float32",s){const i=Nt(n,r),o=new Tre(t,e,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),Xo=z({relu_:function Fre(n){const e={x:T(n,"x","relu")};return $.runKernel(pf,e)}}),Vl=z({reverse_:function Pre(n,t){const r={x:T(n,"x","reverse")};return $.runKernel(Oy,r,{dims:t})}}),q2=z({selu_:function $re(n){const e={x:T(n,"x","selu")};return $.runKernel(_f,e)}}),K2=z({separableConv2d_:function Lre(n,t,e,r,s,i=[1,1],o="NHWC"){const a=T(n,"x","separableConv2d"),l=T(t,"depthwiseFilter","separableConv2d"),c=T(e,"pointwiseFilter","separableConv2d");let u=a,d=!1;if(3===a.rank&&(d=!0,u=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");S(4===u.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),S(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),S(4===c.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),S(1===c.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),S(1===c.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const h=l.shape[2],f=l.shape[3];S(c.shape[2]===h*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*f}, but got ${c.shape[2]}.`);const p=d_(u,l,r,s,o,i),g=Ll(p,c,1,"valid",o);return d?j(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),Su=z({sigmoid_:function Vre(n){const e={x:T(n,"x","sigmoid","float32")};return $.runKernel(wf,e)}}),Yt=z({slice_:function Bre(n,t,e){const r=T(n,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return $.runKernel(Py,{x:r},{begin:t,size:e})}}),sS=z({slice1d_:function zre(n,t,e){const r=T(n,"x","slice1d");return S(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Yt(r,[t],[e])}}),X2=z({slice2d_:function Ure(n,t,e){const r=T(n,"x","slice2d");return S(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Yt(r,t,e)}}),iS=z({slice3d_:function Hre(n,t,e){const r=T(n,"x","slice3d");return S(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Yt(r,t,e)}}),y_=z({slice4d_:function jre(n,t,e){const r=T(n,"x","slice4d");return S(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Yt(r,t,e)}}),oS=z({softmax_:function Wre(n,t=-1){const e=T(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return $.runKernel(By,{logits:e},{dim:t})}}),Bf=z({softplus_:function Gre(n){const e={x:T(n,"x","softplus")};return $.runKernel(Cf,e)}}),zs=z({split_:function qre(n,t,e=0){const s={x:T(n,"x","split")};return $.runKernel(Vy,s,{numOrSizeSplits:t,axis:e})}}),qr=z({sqrt_:function Kre(n){const e={x:T(n,"x","sqrt","float32")};return $.runKernel(Df,e)}}),zf=z({squeeze_:function Xre(n,t){const e=T(n,"x","squeeze");return j(e,Sa(e.shape,t).newShape)}}),Bl=z({stack_:function Yre(n,t=0){const e=s2(n,"tensors","stack","string_or_numeric");return S(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&S(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),$.runKernel(Ty,e,{axis:t})}}),aS=z({tanh_:function Zre(n){const e={x:T(n,"x","tanh","float32")};return $.runKernel(Tf,e)}});function bs(n,t){sC(n);const e=Ff(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Pf(n,null,e,t)}const Y2=z({truncatedNormal_:function Qre(n,t=0,e=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const i=new nS(t,e,r,!0,s),o=Nt(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),Eu=z({unstack_:function Jre(n,t=0){const e=T(n,"x","unstack","string_or_numeric");return S(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),$.runKernel(Uy,{value:e},{axis:t})}}),__=z({broadcastTo_:function tse(n,t){let e=T(n,"broadcastTo","x");const r=e.shape;if(t.some(c=>!(c>0)||c%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const c=e.shape.slice();for(;c.length<t.length;)c.unshift(1);e=j(e,c)}const s=e.shape,i=Array.from(t);for(let c=t.length-1;c>=0;c--)if(s[c]===t[c])i[c]=1;else if(1!==e.shape[c])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===i.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length?Fl(e):$.runKernel(kf,{x:e},{reps:i})}}),xs=z({where_:function nse(n,t,e){const r=T(t,"a","where"),s=T(e,"b","where"),i=T(n,"condition","where","bool"),o=gt(gt(i.shape,r.shape),s.shape),a=__(i,o),l=__(r,o),c=__(s,o);return $.runKernel(Fy,{condition:a,t:l,e:c})}}),Ft=z({zerosLike_:function rse(n){const e={x:T(n,"x","zerosLike")};return $.runKernel(jy,e)}}),zt=z({transpose_:function sse(n,t){const e=T(n,"x","transpose");return null==t&&(t=e.shape.map((i,o)=>o).reverse()),S(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of perm ${t}.`),t.forEach(i=>{S(i>=0&&i<e.rank,()=>`All entries in 'perm' must be between 0 and ${e.rank-1} but got ${t}`)}),e.rank<=1?e.clone():$.runKernel(zy,{x:e},{perm:t})}}),ase=z({dropout_:function ose(n,t,e,r){const s=T(n,"x","dropout");if(S("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),S(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof Ln?s.clone():s;const i=function ise(n,t){if(null==t)return n.shape.slice();if(Ut(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let r=0;r<n.shape.length;r++)e.push(null==t[r]&&null!=n.shape[r]?n.shape[r]:t[r]);return e}return t}(s,e),o=1-t,a=Ze(p_(we(g_(i,0,1,"float32",r),o)),o);return P(s,a)}}),Z2=z({imag_:function lse(n){const e={input:T(n,"input","imag")};return $.runKernel(FC,e)}}),lS=z({real_:function cse(n){const e={input:T(n,"input","real")};return $.runKernel(jC,e)}}),cS=z({fft_:function use(n){return S("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),$.runKernel("FFT",{input:n})}}),uS=z({rfft_:function dse(n,t){S("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const r=n.size/e;let s;if(null!=t&&t<e){const p=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=t,s=Yt(n,p,m),e=t}else if(null!=t&&t>e){const p=n.shape.map(m=>m);p[n.shape.length-1]=t-e,s=Lr([n,_r(p)],n.shape.length-1),e=t}else s=n;const i=Ft(s),o=j(gu(s,i),[r,e]),a=cS(o),l=Math.floor(e/2)+1,c=lS(a),u=Z2(a),d=zs(c,[l,e-l],c.shape.length-1),h=zs(u,[l,e-l],u.shape.length-1),f=s.shape.slice();return f[s.shape.length-1]=l,j(gu(d[0],h[0]),f)}}),v_=z({ifft_:function hse(n){return S("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),$.runKernel(OC,{input:n})}}),Q2=z({irfft_:function fse(n){const t=n.shape[n.shape.length-1],e=n.size/t;let r;if(t<=2){const s=j(n,[e,t]);r=v_(s)}else{const s=[e,2*(t-1)],i=j(lS(n),[e,t]),o=j(Z2(n),[e,t]),a=Vl(Yt(i,[0,1],[e,t-2]),1),l=P(Vl(Yt(o,[0,1],[e,t-2]),1),lt(-1)),c=Lr([i,a],1),u=Lr([o,l],1),d=j(gu(c,u),[s[0],s[1]]);r=v_(d)}if(r=lS(r),3===n.rank&&0!==n.shape[0]){const s=r,i=n.shape[0];r=j(r,[i,r.shape[0]/i,r.shape[1]]),s.dispose()}return r}}),dS=z({conv2DBackpropFilter_:function pse(n,t,e,r,s,i="NHWC",o){let a=n;3===n.rank&&(a=j(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;3===l.rank&&(l=j(t,[1,t.shape[0],t.shape[1],t.shape[2]])),S(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),S(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),S(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const c="NHWC"===i?a.shape[3]:a.shape[1],u="NHWC"===i?l.shape[3]:l.shape[1];return S(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),S(u===e[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${e[3]}).`),Gr("conv2dDerFilter",s,o),$.runKernel(bC,{x:a,dy:l},{strides:r,pad:s,dataFormat:i,dimRoundingMode:o,filterShape:e})}}),J2=z({relu6_:function mse(n){const e={x:T(n,"x","relu6")};return $.runKernel(mf,e)}}),Uf=z({step_:function gse(n,t=0){const r={x:T(n,"x","step")};return $.runKernel(Nf,r,{alpha:t})}});function b_(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return P(n,Uf(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function x_(n,t){let e=t;const r=er(n.shape,t.shape);return r.length>0&&(e=He(e,r)),j(e,n.shape)}function w_(n,t,e,r){if("linear"===t)return n;if("relu"===t)return Xo(n);if("elu"===t)return h_(n);if("relu6"===t)return J2(n);if("prelu"===t)return tS(n,e);if("leakyrelu"===t)return XD(n,r);if("sigmoid"===t)return Su(n);throw new Error(`Unknown fused activation ${t}.`)}const C_=(n,t)=>!(n>0)||"linear"===t,_se=z({fusedConv2d_:function yse({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(!1===C_($.state.gradientDepth,l=l||"linear")){let w=Ll(n,t,e,r,s,i,o);return null!=a&&(w=we(w,a)),w_(w,l,c,u)}const d=T(n,"x","conv2d","float32"),h=T(t,"filter","conv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=j(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),Gr("fused conv2d",r,o),S(f.shape[3]===h.shape[2],()=>`Error in conv2d: depth of input (${f.shape[3]}) must match input depth for filter ${h.shape[2]}.`),S(Er(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),S("NHWC"===s,()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const m=gr(f.shape,h.shape,e,i,r,o);let g,_;null!=a&&(g=T(a,"bias","fused conv2d"),[g]=Nn(g,d),gt(m.outShape,g.shape)),null!=c&&(_=T(c,"prelu weights","fused conv2d"));const y=(w,C)=>{const[E,k,M,O]=C,K=b_(w,M,l);S(Ma(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const re=[qD(k.shape,K,E,e,r),dS(k,K,E.shape,e,r)];if(null!=O){const ne=x_(O,K);re.push(ne)}return re},v={x:f,filter:h,bias:g,preluActivationWeights:_},b={strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return null==a?Wo((C,E,k)=>{let M=$.runKernel(Gy,v,b);return k([E,C,M]),p&&(M=j(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:y}})(f,h):Wo((C,E,k,M)=>{let O=$.runKernel(Gy,v,b);return M([E,C,O,k]),p&&(O=j(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:y}})(f,h,g)}}),e$=z({depthwiseConv2dNativeBackpropFilter_:function vse(n,t,e,r,s,i=[1,1],o){let a=n;3===n.rank&&(a=j(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;return 3===l.rank&&(l=j(t,[1,t.shape[0],t.shape[1],t.shape[2]])),$.runKernel(EC,{x:a,dy:l},{strides:r,pad:s,dimRoundingMode:o,dilations:i,filterShape:e})}}),t$=z({depthwiseConv2dNativeBackpropInput_:function bse(n,t,e,r,s,i=[1,1],o){let a=t,l=!1;3===t.rank&&(l=!0,a=j(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const d=$.runKernel(IC,{dy:a,filter:e},{strides:r,pad:s,dimRoundingMode:o,dilations:i,inputShape:n});return l?j(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});z({fusedDepthwiseConv2d_:function xse({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(!1===C_($.state.gradientDepth,l)){let w=d_(n,t,e,r,s,i,o);return null!=a&&(w=we(w,a)),w_(w,l,c,u)}const d=T(n,"x","depthwiseConv2d","float32"),h=T(t,"filter","depthwiseConv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=j(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),S(f.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==i&&(i=[1,1]),S(Er(e,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),Gr("fused depthwiseConv2d",r,o);const m=gr(f.shape,h.shape,e,i,r,o,!0);let g,_;null!=a&&(g=T(a,"bias","fused conv2d"),[g]=Nn(g,d),gt(m.outShape,g.shape)),null!=c&&(_=T(c,"prelu weights","fused depthwiseConv2d"));const y=(w,C)=>{S(Ma(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[E,k,M,O]=C,K=b_(w,M,l),X=t$(k.shape,K,E,e,r,i,o),Q=e$(k,K,E.shape,e,r,i,o);return null!=O?[X,Q,x_(g,K)]:[X,Q]},v={x:f,filter:h,bias:g,preluActivationWeights:_},b={strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return null==a?Wo((C,E,k)=>{let M=$.runKernel(qy,v,b);return k([E,C,M]),p&&(M=j(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:y}})(f,h):Wo((C,E,k,M)=>{let O=$.runKernel(qy,v,b);return M([E,C,O,k]),p&&(O=j(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:y}})(f,h,g)}});const n$=z({fusedMatMul_:function wse({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a}){if(!1===C_($.state.gradientDepth,i)){let K=Ht(n,t,e,r);return null!=s&&(K=we(K,s)),w_(K,i,o,a)}let l=T(n,"a","fused matMul"),c=T(t,"b","fused matMul");[l,c]=Nn(l,c);const u=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?c.shape[c.rank-1]:c.shape[c.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?c.shape[c.rank-2]:c.shape[c.rank-1],p=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=ce(p),_=ce(m);S(u===d,()=>`Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${r} must match.`);const v=gt(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([h,f]),b=j(l,e?[g,u,h]:[g,h,u]),w=j(c,r?[_,f,d]:[_,d,f]);let C,E;null!=s&&(C=T(s,"bias","fused matMul"),[C]=Nn(C,l),gt(v,C.shape)),null!=o&&(E=T(o,"prelu weights","fused matMul"));const k=(K,X)=>{const[Q,re,ne,V]=X,G=b_(j(K,ne.shape),ne,i);let W,J;return e||r?!e&&r?(W=Ht(G,re,!1,!1),J=Ht(G,Q,!0,!1)):e&&!r?(W=Ht(re,G,!1,!0),J=Ht(Q,G,!1,!1)):(W=Ht(re,G,!0,!0),J=Ht(G,Q,!0,!0)):(W=Ht(G,re,!1,!0),J=Ht(Q,G,!0,!1)),null!=s?[W,J,x_(V,G)]:[W,J]},M={a:b,b:w,bias:C,preluActivationWeights:E},O={transposeA:e,transposeB:r,activation:i,leakyreluAlpha:a};return null==s?Wo((X,Q,re)=>{const ne=$.runKernel(Wy,M,O);return re([X,Q,ne]),{value:j(ne,v),gradFunc:k}})(b,w):Wo((X,Q,re,ne)=>{const V=$.runKernel(Wy,M,O);return ne([X,Q,V,re]),{value:j(V,v),gradFunc:k}})(b,w,C)}});function r$(n,t,e){const r=1-n%2,s=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+r-1);s[i]=t-e*Math.cos(o)}return bs(s,"float32")}z({hammingWindow_:function Dse(n){return r$(n,.54,.46)}});const s$=z({hannWindow_:function Ese(n){return r$(n,.5,.5)}});function D_(n,t,e){if(sC(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Ff(n,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Pf(n,t,r,e)}const i$=z({frame_:function Ise(n,t,e,r=!1,s=0){let i=0;const o=[];for(;i+t<=n.size;)o.push(Yt(n,i,t)),i+=e;if(r)for(;i<n.size;){const a=i+t-n.size,l=Lr([Yt(n,i,t-a),f_([a],s)]);o.push(l),i+=e}return 0===o.length?D_([],[0,t]):j(Lr(o),[o.length,t])}});z({stft_:function Tse(n,t,e,r,s=s$){null==r&&(r=function Cse(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}(t));const i=i$(n,t,e),o=P(i,s(t));return uS(o,r)}});const Ase=z({cropAndResize_:function Nse(n,t,e,r,s="bilinear",i=0){const o=T(n,"image","cropAndResize"),a=T(t,"boxes","cropAndResize","float32"),l=T(e,"boxInd","cropAndResize","int32"),c=a.shape[0];return S(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),S(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),S(1===l.rank&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),S(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),S(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),S("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),$.runKernel(DC,{image:o,boxes:a,boxInd:l},{method:s,extrapolationValue:i,cropSize:r})}}),Mse=z({flipLeftRight_:function Rse(n){const t=T(n,"image","flipLeftRight","float32");return S(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),$.runKernel(MC,{image:t},{})}}),Fse=z({grayscaleToRGB_:function Ose(n){const t=T(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];S(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),S(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,e),s[e]=3,Vi(t,s)}}),$se=z({rotateWithOffset_:function Pse(n,t,e=0,r=.5){const s=T(n,"image","rotateWithOffset","float32");return S(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),$.runKernel(oD,{image:s},{radians:t,fillValue:e,center:r})}});function Iu(n,t,e,r,s,i){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==i&&(i=0);const o=n.shape[0];return e=Math.min(e,o),S(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),S(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),S(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),S(1===t.rank,()=>"scores must be a 1D tensor"),S(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),S(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}const Vse=z({nonMaxSuppression_:function Lse(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const i=T(n,"boxes","nonMaxSuppression","float32"),o=T(t,"scores","nonMaxSuppression","float32"),a=Iu(i,o,e,r,s);return $.runKernel(VC,{boxes:i,scores:o},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function Bse(n,t,e){const r=function zse(n,t,e){return function Hse(n,t,e){let r=0,s=n.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=e(t,n[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}(n,t,e||Use)}(n,t,e);n.splice(r<0?-(r+1):r,0,t)}function Use(n,t){return n>t?1:n<t?-1:0}function hS(n,t,e,r,s){return mS(n,t,e,r,s,0)}function fS(n,t,e,r,s,i){return mS(n,t,e,r,s,0,!1,i,!0)}function pS(n,t,e,r,s,i){return mS(n,t,e,r,s,i,!0)}function mS(n,t,e,r,s,i,o=!1,a=!1,l=!1){const c=[];for(let g=0;g<t.length;g++)t[g]>s&&c.push({score:t[g],boxIndex:g,suppressBeginIndex:0});c.sort(o$);const u=i>0?-.5/i:0,d=[],h=[];for(;d.length<e&&c.length>0;){const g=c.pop(),{score:_,boxIndex:y,suppressBeginIndex:v}=g;if(_<s)break;let b=!1;for(let w=d.length-1;w>=v;--w){const C=jse(n,y,d[w]);if(C>=r){b=!0;break}if(g.score=g.score*Wse(r,u,C),g.score<=s)break}g.suppressBeginIndex=d.length,b||(g.score===_?(d.push(y),h.push(g.score)):g.score>s&&Bse(c,g,o$))}const f=d.length,p=e-f;a&&p>0&&(d.push(...new Array(p).fill(0)),h.push(...new Array(p).fill(0)));const m={selectedIndices:d};return o&&(m.selectedScores=h),l&&(m.validOutputs=f),m}function jse(n,t,e){const r=n.subarray(4*t,4*t+4),s=n.subarray(4*e,4*e+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),f=(a-i)*(l-o),p=(d-c)*(h-u);if(f<=0||p<=0)return 0;const m=Math.max(i,c),g=Math.max(o,u),_=Math.min(a,d),y=Math.min(l,h),v=Math.max(_-m,0)*Math.max(y-g,0);return v/(f+p-v)}function Wse(n,t,e){const r=Math.exp(t*e*e);return e<=n?r:0}function o$(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function gS(){return(gS=he(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const i=T(n,"boxes","nonMaxSuppressionAsync"),o=T(t,"scores","nonMaxSuppressionAsync"),a=Iu(i,o,e,r,s);e=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=yield Promise.all([i.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:d}=hS(c,u,e,r,s);return i!==n&&i.dispose(),o!==t&&o.dispose(),bs(d,"int32")})).apply(this,arguments)}const Xse=z({nonMaxSuppressionWithScore_:function Kse(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=T(n,"boxes","nonMaxSuppression"),a=T(t,"scores","nonMaxSuppression"),l=Iu(o,a,e,r,s,i),d=$.runKernel(zC,{boxes:o,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function yS(){return(yS=he(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=T(n,"boxes","nonMaxSuppressionAsync"),a=T(t,"scores","nonMaxSuppressionAsync"),l=Iu(o,a,e,r,s,i);e=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const c=yield Promise.all([o.data(),a.data()]),u=c[0],d=c[1],{selectedIndices:h,selectedScores:f}=pS(u,d,e,r,s,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:bs(h,"int32"),selectedScores:bs(f)}})).apply(this,arguments)}const Jse=z({nonMaxSuppressionPadded_:function Qse(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=T(n,"boxes","nonMaxSuppression"),a=T(t,"scores","nonMaxSuppression"),l=Iu(o,a,e,r,s,null),p=$.runKernel(BC,{boxes:o,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:p[0],validOutputs:p[1]}}});function _S(){return(_S=he(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=T(n,"boxes","nonMaxSuppressionAsync"),a=T(t,"scores","nonMaxSuppressionAsync"),l=Iu(o,a,e,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,d=l.scoreThreshold,[h,f]=yield Promise.all([o.data(),a.data()]),{selectedIndices:p,validOutputs:m}=fS(h,f,c,u,d,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:bs(p,"int32"),validOutputs:lt(m,"int32")}})).apply(this,arguments)}const a$=z({resizeBilinear_:function nie(n,t,e=!1,r=!1){const s=T(n,"images","resizeBilinear");S(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),S(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;3===s.rank&&(o=!0,i=j(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,c=$.runKernel(My,{images:i},{alignCorners:e,halfPixelCenters:r,size:t});return o?j(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),l$=z({resizeNearestNeighbor_:function rie(n,t,e=!1,r=!1){const s=T(n,"images","resizeNearestNeighbor");S(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),S("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),S(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;3===s.rank&&(o=!0,i=j(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,c=$.runKernel(Ry,{images:i},{alignCorners:e,halfPixelCenters:r,size:t});return o?j(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),iie=z({bincount_:function sie(n,t,e){const r=T(n,"x","bincount"),s=T(t,"weights","bincount");return S("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),$.runKernel(_C,{x:r,weights:s},{size:e})}}),Tu=z({lessEqual_:function oie(n,t){let e=T(n,"a","lessEqual","string_or_numeric"),r=T(t,"b","lessEqual","string_or_numeric");return[e,r]=Nn(e,r),gt(e.shape,r.shape),$.runKernel(fy,{a:e,b:r})}}),c$=z({round_:function aie(n){const e={x:T(n,"x","round")};return $.runKernel(gf,e)}});function S_(n,t,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return $.runKernel(HC,{},{start:n,stop:t,step:e,dtype:r})}const uie=z({threshold_:function lie(n,t="binary",e=!1,r=.5){const s=T(n,"image","threshold"),l=s.shape[0]*s.shape[1];let u,d,h,f,c=P(bs([r]),255);if(S(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),S(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),S("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),S("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[u,d,h]=zs(s,[1,1,1],-1);const g=P(u,.2989),_=P(d,.587),y=P(h,.114);f=we(we(g,_),y)}else f=n;"otsu"===t&&(c=function cie(n,t){let i,o,a,l,c,u,e=bs([-1]),r=bs([0]),s=bs([0]);for(let d=0;d<n.size-1;d++){i=Yt(n,0,d+1),o=Yt(n,d+1),c=Ze(He(i),t),u=Ze(He(o),t);const h=He(P(i,S_(0,i.size)));a=Ze(h,He(i));const f=f_(o.shape,i.size),p=we(S_(0,o.size),f),m=P(o,p);l=Ze(He(m),He(o));const g=Ue(a,l),_=Ue(a,l),y=P(c,u);s=P(P(y,g),_);const v=fi(s,r);r=xs(v,s,r),e=xs(v,bs([d]),e)}return e}(iie(Ne(c$(f),"int32"),n_([]),256),l));const p=e?Tu(f,c):fi(f,c);return Ne(P(p,255),"int32")}}),hie=z({transform_:function die(n,t,e="nearest",r="constant",s=0,i){const o=T(n,"image","transform","float32"),a=T(t,"transforms","transform","float32");return S(4===o.rank,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),S(2===a.rank&&(a.shape[0]===o.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),S(null==i||2===i.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`),$.runKernel(rD,{image:o,transforms:a},{interpolation:e,fillMode:r,fillValue:s,outputShape:i})}}),pie=z({bandPart_:function fie(n,t,e){S(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),S(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);const r=T(n,"a","bandPart");S(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);if(!(t<=i))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`);if(!(e<=o))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`);t<0&&(t=i),e<0&&(e=o);const a=j(S_(0,i,1,"int32"),[-1,1]),l=S_(0,o,1,"int32"),c=Ue(a,l),u=Ko(Tu(c,lt(+t,"int32")),Du(c,lt(-e,"int32"))),d=_r([i,o],r.dtype);return j(Bl(Eu(j(r,[-1,i,o])).map(h=>xs(u,h,d))),s)}}),vS=z({min_:function mie(n,t=null,e=!1){const s={x:T(n,"x","min")};return $.runKernel(wy,s,{axis:t,keepDims:e})}}),ku=z({pow_:function gie(n,t){let e=T(n,"base","pow"),r=T(t,"exp","pow");return[e,r]=Nn(e,r),$.runKernel(hf,{a:e,b:r})}});function u$(n,t,e=null){if(0===n.rank)return mr(n);if(1!==n.rank&&null===e)return u$(j(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return He(mr(n),e);if(t===1/0)return go(mr(n),e);if(t===-1/0)return vS(mr(n),e);if("euclidean"===t||2===t)return qr(He(ku(mr(n),lt(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return go(He(mr(n),e[0]),e[1]-1);if(t===1/0)return go(He(mr(n),e[1]),e[0]);if(t===-1/0)return vS(He(mr(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return qr(He(an(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const bS=z({norm_:function yie(n,t="euclidean",e=null,r=!1){const s=u$(n=T(n,"x","norm"),t,e);let i=s.shape;if(r){const o=It(e,n.shape);i=Bn(s.shape,o)}return j(s,i)}}),vie=z({gramSchmidt_:function _ie(n){let t;if(Array.isArray(n)){t=!1,S(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let i=1;i<n.length;++i)S(n[i].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${s})`)}else t=!0,n=zs(n,n.shape[0],0).map(s=>zf(s,[0]));S(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],r=n;for(let s=0;s<n.length;++s)e.push($.tidy(()=>{let i=r[s];if(s>0)for(let o=0;o<s;++o){const a=P(He(P(e[o],i)),e[o]);i=Ue(i,a)}return Ze(i,bS(i,"euclidean"))}));return t?Bl(e,0):e}});function d$(n,t=!1){return $.tidy(()=>{S(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],r=n.shape[1];let s=U2(e),i=Fl(n);const o=D_([[1]],[1,1]);let a=Fl(o);const l=e>=r?r:e;for(let c=0;c<l;++c){const u=i,d=a,h=s;[a,i,s]=$.tidy(()=>{const f=Yt(i,[c,c],[e-c,1]),p=bS(f),m=Yt(i,[c,c],[1,1]),g=xs(fi(m,0),D_([[-1]]),D_([[1]])),_=Ue(m,P(g,p)),y=Ze(f,_);a=1===y.shape[0]?Fl(o):Lr([o,Yt(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);const v=Rn(Ze(Ht(g,_),p)),b=Yt(i,[c,0],[e-c,r]),w=P(v,a),C=zt(a);if(0===c)i=Ue(b,Ht(w,Ht(C,b)));else{const M=Ue(b,Ht(w,Ht(C,b)));i=Lr([Yt(i,[0,0],[c,r]),M],0)}const E=zt(w),k=Yt(s,[0,c],[e,s.shape[1]-c]);if(0===c)s=Ue(k,Ht(Ht(k,a),E));else{const M=Ue(k,Ht(Ht(k,a),E));s=Lr([Yt(s,[0,0],[e,c]),M],1)}return[a,i,s]}),St([u,d,h])}return!t&&e>r&&(s=Yt(s,[0,0],[e,r]),i=Yt(i,[0,0],[r,r])),[s,i]})}const xie=z({qr_:function bie(n,t=!1){if(S(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return d$(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),r=Eu(j(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],i=[];return r.forEach(l=>{const[c,u]=d$(l,t);s.push(c),i.push(u)}),[j(Bl(s,0),n.shape),j(Bl(i,0),n.shape)]}}});var Kr=(()=>{return(n=Kr||(Kr={}))[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",Kr;var n})();const Yo=z({computeWeightedLoss_:function wie(n,t,e=Kr.SUM_BY_NONZERO_WEIGHTS){const r=T(n,"losses","computeWeightedLoss");let s=null;null!=t&&(s=T(t,"weights","computeWeightedLoss"));const i=null==s?r:P(r,s);if(e===Kr.NONE)return i;if(e===Kr.SUM)return He(i);if(e===Kr.MEAN){if(null==s)return Vn(i);{const o=r.size/s.size,a=Ze(He(i),He(s));return o>1?Ze(a,lt(o)):a}}if(e===Kr.SUM_BY_NONZERO_WEIGHTS){if(null==s)return Ze(He(i),lt(r.size));{const o=P(s,Pa(r.shape)),a=Ne(He(Vf(o,lt(0))),"float32");return Ze(He(i),a)}}throw Error(`Unknown reduction: ${e}`)}});z({absoluteDifference_:function Cie(n,t,e,r=Kr.SUM_BY_NONZERO_WEIGHTS){const s=T(n,"labels","absoluteDifference"),i=T(t,"predictions","absoluteDifference");let o=null;null!=e&&(o=T(e,"weights","absoluteDifference")),ai(s.shape,i.shape,"Error in absoluteDifference: ");const a=mr(Ue(s,i));return Yo(a,o,r)}}),z({cosineDistance_:function Sie(n,t,e,r,s=Kr.SUM_BY_NONZERO_WEIGHTS){const i=T(n,"labels","cosineDistance"),o=T(t,"predictions","cosineDistance");let a=null;null!=r&&(a=T(r,"weights","cosineDistance")),ai(i.shape,o.shape,"Error in cosineDistance: ");const l=lt(1),c=Ue(l,He(P(i,o),e,!0));return Yo(c,a,s)}}),z({hingeLoss_:function Iie(n,t,e,r=Kr.SUM_BY_NONZERO_WEIGHTS){let s=T(n,"labels","hingeLoss");const i=T(t,"predictions","hingeLoss");let o=null;null!=e&&(o=T(e,"weights","hingeLoss")),ai(s.shape,i.shape,"Error in hingeLoss: ");const a=lt(1);s=Ue(P(lt(2),s),a);const l=Xo(Ue(a,P(s,i)));return Yo(l,o,r)}}),z({huberLoss_:function kie(n,t,e,r=1,s=Kr.SUM_BY_NONZERO_WEIGHTS){const i=T(n,"labels","huberLoss"),o=T(t,"predictions","huberLoss");let a=null;null!=e&&(a=T(e,"weights","huberLoss")),ai(i.shape,o.shape,"Error in huberLoss: ");const l=lt(r),c=mr(Ue(o,i)),u=m_(c,l),d=Ue(c,u),h=we(P(lt(.5),an(u)),P(l,d));return Yo(h,a,s)}}),z({logLoss_:function Aie(n,t,e,r=1e-7,s=Kr.SUM_BY_NONZERO_WEIGHTS){const i=T(n,"labels","logLoss"),o=T(t,"predictions","logLoss");let a=null;null!=e&&(a=T(e,"weights","logLoss")),ai(i.shape,o.shape,"Error in logLoss: ");const l=lt(1),c=lt(r),u=Rn(P(i,pi(we(o,c)))),d=P(Ue(l,i),pi(we(Ue(l,o),c))),h=Ue(u,d);return Yo(h,a,s)}});const h$=z({squaredDifference_:function Mie(n,t){let e=T(n,"a","squaredDifference"),r=T(t,"b","squaredDifference");return[e,r]=Nn(e,r),gt(e.shape,r.shape),$.runKernel(Sf,{a:e,b:r},{})}});z({meanSquaredError_:function Oie(n,t,e,r=Kr.SUM_BY_NONZERO_WEIGHTS){const s=T(n,"labels","meanSquaredError"),i=T(t,"predictions","meanSquaredError");let o=null;null!=e&&(o=T(e,"weights","meanSquaredError")),ai(s.shape,i.shape,"Error in meanSquaredError: ");const a=h$(s,i);return Yo(a,o,r)}}),z({sigmoidCrossEntropy_:function $ie(n,t,e,r=0,s=Kr.SUM_BY_NONZERO_WEIGHTS){let i=T(n,"multiClassLabels","sigmoidCrossEntropy");const o=T(t,"logits","sigmoidCrossEntropy");let a=null;if(null!=e&&(a=T(e,"weights","sigmoidCrossEntropy")),ai(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=lt(r),u=lt(1),d=lt(.5);i=we(P(i,Ue(u,c)),P(d,c))}const l=function Pie(n,t){const e=T(n,"labels","sigmoidCrossEntropyWithLogits"),r=T(t,"logits","sigmoidCrossEntropyWithLogits");ai(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Xo(r),i=P(r,e),o=YD(di(Rn(mr(r))));return we(Ue(s,i),o)}(i,o);return Yo(l,a,s)}});const f$=z({logSumExp_:function Vie(n,t=null,e=!1){const r=T(n,"x","logSumExp"),s=It(t,r.shape),i=go(r,s,!0),o=Ue(r,i),a=di(o),l=He(a,s),c=pi(l),u=we(j(i,c.shape),c);if(e){const d=Bn(u.shape,s);return j(u,d)}return u}});z({softmaxCrossEntropy_:function zie(n,t,e,r=0,s=Kr.SUM_BY_NONZERO_WEIGHTS){let i=T(n,"onehotLabels","softmaxCrossEntropy");const o=T(t,"logits","softmaxCrossEntropy");let a=null;if(null!=e&&(a=T(e,"weights","softmaxCrossEntropy")),ai(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const c=lt(r),u=lt(1),d=lt(i.shape[1]);i=we(P(i,Ue(u,c)),Ze(c,d))}const l=function Bie(n,t,e=-1){if(-1===e&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return Wo((s,i,o)=>{const l=f$(i,[e],!0),c=Ue(Ne(i,"float32"),l);o([s,c]);const u=Rn(P(c,s));return{value:He(u,[e]),gradFunc:(f,p)=>{const[m,g]=p,_=Bn(f.shape,[e]);return[P(j(f,_),Ue(Ne(m,"float32"),di(g))),P(j(f,_),Ue(di(g),Ne(m,"float32")))]}}})(n,t)}(i,o);return Yo(l,a,s)}}),z({sparseFillEmptyRows_:function Hie(n,t,e,r){const s=T(n,"indices","sparseFillEmptyRows","int32"),i=T(t,"values","sparseFillEmptyRows"),o=T(e,"denseShape","sparseFillEmptyRows","int32"),a=T(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const c=$.runKernel(qC,{indices:s,values:i,denseShape:o,defaultValue:a});return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}}),z({sparseReshape_:function Wie(n,t,e){const r=T(n,"inputIndices","sparseReshape","int32"),s=T(t,"inputShape","sparseReshape","int32"),i=T(e,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a=$.runKernel(KC,{inputIndices:r,inputShape:s,newShape:i});return{outputIndices:a[0],outputShape:a[1]}}}),z({sparseSegmentMean_:function qie(n,t,e){const r=T(n,"data","sparseSegmentMean"),s=T(t,"indices","sparseSegmentMean","int32"),i=T(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);return $.runKernel(XC,{data:r,indices:s,segmentIds:i})}}),z({sparseSegmentSum_:function Xie(n,t,e){const r=T(n,"data","sparseSegmentSum"),s=T(t,"indices","sparseSegmentSum","int32"),i=T(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);return $.runKernel(YC,{data:r,indices:s,segmentIds:i})}}),z({stringNGrams_:function Zie(n,t,e,r,s,i,o,a){const l=T(n,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=T(t,"dataSplits","stringNGrams");if("int32"!==c.dtype)throw new Error("Data splits must be of datatype int32");const h=$.runKernel(JC,{data:l,dataSplits:c},{separator:e,nGramWidths:r,leftPad:s,rightPad:i,padWidth:o,preserveShortSequences:a});return{nGrams:h[0],nGramsSplits:h[1]}}}),z({stringSplit_:function Jie(n,t,e=!0){const r=T(n,"input","stringSplit","string"),s=T(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a=$.runKernel(eD,{input:r,delimiter:s},{skipEmpty:e});return{indices:a[0],values:a[1],shape:a[2]}}}),z({stringToHashBucketFast_:function toe(n,t){const e=T(n,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return $.runKernel(tD,{input:e},r)}});const Hf={flipLeftRight:Mse,grayscaleToRGB:Fse,resizeNearestNeighbor:l$,resizeBilinear:a$,rotateWithOffset:$se,cropAndResize:Ase,nonMaxSuppression:Vse,nonMaxSuppressionAsync:function Gse(n,t,e){return gS.apply(this,arguments)},nonMaxSuppressionWithScore:Xse,nonMaxSuppressionWithScoreAsync:function Yse(n,t,e){return yS.apply(this,arguments)},nonMaxSuppressionPadded:Jse,nonMaxSuppressionPaddedAsync:function eie(n,t,e){return _S.apply(this,arguments)},threshold:uie,transform:hie},roe={bandPart:pie,gramSchmidt:vie,qr:xie};let xS=(()=>{class n extends Aa{constructor(e,r,s=null){super(),this.learningRate=e,this.rho=r,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==s&&(this.epsilon=$.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=$.registeredVariables[s];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${s}/accum_grad`,variable:te(()=>Ft(o).variable(!1))}),null==this.accumulatedUpdates[i]&&(this.accumulatedUpdates[i]={originalName:`${s}/accum_var`,variable:te(()=>Ft(o).variable(!1))});const l=Array.isArray(e)?e[i].tensor:e[s];if(null==l)return;const c=this.accumulatedGrads[i].variable,u=this.accumulatedUpdates[i].variable;te(()=>{const d=we(P(c,this.rho),P(an(l),1-this.rho)),h=P(Ze(qr(we(u,this.epsilon)),qr(we(c,this.epsilon))),l),f=we(P(u,this.rho),P(an(h),1-this.rho));c.assign(d),u.assign(f);const p=we(P(h,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(St(this.accumulatedGrads.map(e=>e.variable)),St(this.accumulatedUpdates.map(e=>e.variable)))}getWeights(){var e=this;return he(function*(){const r=[...e.accumulatedGrads,...e.accumulatedUpdates];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return he(function*(){const s=(e=yield r.extractIterations(e)).length/2;r.accumulatedGrads=e.slice(0,s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),r.accumulatedUpdates=e.slice(s,2*s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.rho,r.epsilon)}}return n.className="Adadelta",n})();ge(xS);let wS=(()=>{class n extends Aa{constructor(e,r=.1){super(),this.learningRate=e,this.initialAccumulatorValue=r,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=$.registeredVariables[s];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${s}/accumulator`,variable:te(()=>f_(o.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[i].tensor:e[s];if(null==a)return;const l=this.accumulatedGrads[i].variable;te(()=>{const c=we(l,an(a));l.assign(c);const u=we(P(Ze(a,qr(we(c,$.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&St(this.accumulatedGrads.map(e=>e.variable))}getWeights(){var e=this;return he(function*(){return[yield e.saveIterations()].concat(e.accumulatedGrads.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return he(function*(){e=yield r.extractIterations(e),r.accumulatedGrads=e.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,r){return new e(r.learningRate,r.initialAccumulatorValue)}}return n.className="Adagrad",n})();ge(wS);let CS=(()=>{class n extends Aa{constructor(e,r,s,i=null){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],te(()=>{this.accBeta1=lt(r).variable(),this.accBeta2=lt(s).variable()}),null==i&&(this.epsilon=$.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);te(()=>{const s=Ue(1,this.accBeta1),i=Ue(1,this.accBeta2);r.forEach((o,a)=>{const l=$.registeredVariables[o];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:te(()=>Ft(l).variable(!1))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:te(()=>Ft(l).variable(!1))});const u=Array.isArray(e)?e[a].tensor:e[o];if(null==u)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedSecondMoment[a].variable,f=we(P(d,this.beta1),P(u,1-this.beta1)),p=we(P(h,this.beta2),P(an(u),1-this.beta2)),m=Ze(f,s),g=Ze(p,i);d.assign(f),h.assign(p);const _=we(P(Ze(m,we(qr(g),this.epsilon)),-this.learningRate),l);l.assign(_)}),this.accBeta1.assign(P(this.accBeta1,this.beta1)),this.accBeta2.assign(P(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&St(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&St(this.accumulatedSecondMoment.map(e=>e.variable))}getWeights(){var e=this;return he(function*(){const r=[...e.accumulatedFirstMoment,...e.accumulatedSecondMoment];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return he(function*(){e=yield r.extractIterations(e),te(()=>{r.accBeta1.assign(ku(r.beta1,r.iterations_+1)),r.accBeta2.assign(ku(r.beta2,r.iterations_+1))});const s=e.length/2;r.accumulatedFirstMoment=e.slice(0,s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),r.accumulatedSecondMoment=e.slice(s,2*s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon)}}return n.className="Adam",n})();ge(CS);let DS=(()=>{class n extends Aa{constructor(e,r,s,i=null,o=0){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=i,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],te(()=>{this.iteration=lt(0).variable(),this.accBeta1=lt(r).variable()}),null==i&&(this.epsilon=$.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);te(()=>{const s=Ue(1,this.accBeta1),i=Ze(-this.learningRate,we(P(this.iteration,this.decay),1));r.forEach((o,a)=>{const l=$.registeredVariables[o];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:Ft(l).variable(!1)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:Ft(l).variable(!1)});const u=Array.isArray(e)?e[a].tensor:e[o];if(null==u)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedWeightedInfNorm[a].variable,f=we(P(d,this.beta1),P(u,1-this.beta1)),p=P(h,this.beta2),m=mr(u),g=Oa(p,m);d.assign(f),h.assign(g);const _=we(P(Ze(i,s),Ze(f,we(g,this.epsilon))),l);l.assign(_)}),this.iteration.assign(we(this.iteration,1)),this.accBeta1.assign(P(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&St(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&St(this.accumulatedWeightedInfNorm.map(e=>e.variable))}getWeights(){return he(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(e){return he(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon,r.decay)}}return n.className="Adamax",n})();ge(DS);let E_=(()=>{class n extends Aa{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=Array.isArray(e)?e[i].tensor:e[s];if(null==o)return;const a=$.registeredVariables[s];te(()=>{const l=we(P(this.c,o),a);a.assign(l)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=po(lt(-e))}dispose(){this.c.dispose()}getWeights(){var e=this;return he(function*(){return[yield e.saveIterations()]})()}setWeights(e){var r=this;return he(function*(){if(0!==(e=yield r.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,r){return new e(r.learningRate)}}return n.className="SGD",n})();ge(E_);let SS=(()=>{class n extends E_{constructor(e,r,s=!1){super(e),this.learningRate=e,this.momentum=r,this.useNesterov=s,this.accumulations=[],this.m=lt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=$.registeredVariables[s];null==this.accumulations[i]&&(this.accumulations[i]={originalName:`${s}/momentum`,variable:te(()=>Ft(o).variable(!1))});const a=this.accumulations[i].variable,l=Array.isArray(e)?e[i].tensor:e[s];null!=l&&te(()=>{let c;const u=we(P(this.m,a),l);c=we(P(this.c,this.useNesterov?we(l,P(u,this.m)):u),o),a.assign(u),o.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&St(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}getWeights(){var e=this;return he(function*(){return[yield e.saveIterations()].concat(e.accumulations.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return he(function*(){e=yield r.extractIterations(e),r.accumulations=e.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,r){return new e(r.learningRate,r.momentum,r.useNesterov)}}return n.className="Momentum",n})();ge(SS);let ES=(()=>{class n extends Aa{constructor(e,r=.9,s=0,i=null,o=!1){if(super(),this.learningRate=e,this.decay=r,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==i&&(this.epsilon=$.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=$.registeredVariables[s],a=!1;null==this.accumulatedMeanSquares[i]&&(this.accumulatedMeanSquares[i]={originalName:`${s}/rms`,variable:te(()=>Ft(o).variable(a))}),null==this.accumulatedMoments[i]&&(this.accumulatedMoments[i]={originalName:`${s}/momentum`,variable:te(()=>Ft(o).variable(a))}),null==this.accumulatedMeanGrads[i]&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${s}/mg`,variable:te(()=>Ft(o).variable(a))});const l=Array.isArray(e)?e[i].tensor:e[s];if(null==l)return;const c=this.accumulatedMeanSquares[i].variable,u=this.accumulatedMoments[i].variable;te(()=>{const d=we(P(c,this.decay),P(an(l),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[i].variable,f=we(P(h,this.decay),P(l,1-this.decay)),p=Ze(P(l,this.learningRate),qr(Ue(d,we(an(f),this.epsilon)))),m=we(P(u,this.momentum),p);c.assign(d),h.assign(f),u.assign(m);const g=Ue(o,m);o.assign(g)}else{const h=we(P(c,this.decay),P(an(l),1-this.decay)),f=we(P(u,this.momentum),Ze(P(l,this.learningRate),qr(we(h,this.epsilon))));c.assign(h),u.assign(f);const p=Ue(o,f);o.assign(p)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&St(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&St(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&St(this.accumulatedMoments.map(e=>e.variable))}getWeights(){var e=this;return he(function*(){const r=[...e.accumulatedMeanSquares,...e.accumulatedMoments];return e.centered&&r.push(...e.accumulatedMeanGrads),[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return he(function*(){e=yield r.extractIterations(e);const s=r.centered?e.length/3:e.length/2,i=!1;r.accumulatedMeanSquares=e.slice(0,s).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})),r.accumulatedMoments=e.slice(s,2*s).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})),r.centered&&(r.accumulatedMeanGrads=e.slice(2*s,3*s).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,r){return new e(r.learningRate,r.decay,r.momentum,r.epsilon,r.centered)}}return n.className="RMSProp",n})();ge(ES);class zl{static sgd(t){return new E_(t)}static momentum(t,e,r=!1){return new SS(t,e,r)}static rmsprop(t,e=.9,r=0,s=null,i=!1){return new ES(t,e,r,s,i)}static adam(t=.001,e=.9,r=.999,s=null){return new CS(t,e,r,s)}static adadelta(t=.001,e=.95,r=null){return new xS(t,e,r)}static adamax(t=.002,e=.9,r=.999,s=null,i=0){return new DS(t,e,r,s,i)}static adagrad(t,e=.1){return new wS(t,e)}}const Nu={sgd:zl.sgd,momentum:zl.momentum,adadelta:zl.adadelta,adagrad:zl.adagrad,rmsprop:zl.rmsprop,adamax:zl.adamax,adam:zl.adam},soe="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:n=>n();function p$(){return new Promise(n=>soe(()=>n()))}function IS(n,t){const e=n[0].length;n.forEach((s,i)=>{S(s.length===e,()=>`Error in concat${e}D: rank of tensors[${i}] must be the same as the rank of the rest (${e})`)}),S(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=n[0];n.forEach((s,i)=>{for(let o=0;o<e;o++)S(o===t||s[o]===r[o],()=>`Error in concat${e}D: Shape of tensors[${i}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function yo(n,t){const e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}const TS=30;function I_(n){return n<=TS?n:cC(n,Math.floor(Math.sqrt(n)))}function kS(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function jf(n,t,e,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(n[0]/e),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const i=t.length;for(let o=0;o<i;++o)s=s.concat([n[o+1]/t[o],t[o]]);s=s.concat(n.slice(i+1))}return s}function Wf(n,t,e=!0){const r=[];if(e){r.push(t);for(let s=t+1;s<n;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],i=[];for(let o=1;o<n;++o)o>=2*t+1||o%2==1?i.push(o):s.push(o);r.push(...s),r.push(0),r.push(...i)}return r}function Gf(n,t,e,r=!0){const s=[];s.push(r?n[0]/e:n[0]*e);for(let i=1;i<n.length;++i)s.push(i<=t.length?r?t[i-1]*n[i]:n[i]/t[i-1]:n[i]);return s}function NS(n,t){const e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function AS(n,t,e){const r=n.slice(0,1);for(let s=0;s<e;++s)r.push(n[s+1]-t[s][0]-t[s][1]);return r}function RS(n,t){const e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if(0===ce(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=t.shape,i=s[s.length-1];let o=1;for(let d=0;d<s.length-1;++d)o*=s[d];const a=n.shape,l=s.slice();l.pop();let c=1;for(let d=i;d<e;++d)c*=a[d],l.push(a[d]);const u=[...Je(n.shape).map(d=>d/c),1].slice(0,i);return[l,o,c,u]}function m$(n,t,e){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(i+` update.rank < ${s}. `);if(n.length<r+(e.rank-s))throw new Error(i+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+n.length-r)throw new Error(i+" update.rank != "+(s+n.length-r));for(let o=0;o<s;++o)if(e.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-s;++o)if(e.shape[o+s]!==n[o+r])throw new Error(i+` updates.shape[${o+s}] (${e.shape[o+s]}) != shape[${o+s}] (${n[o+s]})`)}function ioe(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}m$(e,t,n)}function qf(n,t,e){const r=t.shape.length,s=r>1?t.shape[r-1]:1,i=e.length;let o=1;for(let d=s;d<i;++d)o*=e[d];const a=s<1?1:s;return{sliceRank:s,numUpdates:ce(t.shape)/a,sliceSize:o,strides:[...Je(e.slice(0,s)),1],outputSize:ce(e)}}const T_=1.7580993408473768,k_=1.0507009873554805,MS=.3275911,OS=.254829592,FS=-.284496736,PS=1.421413741,$S=-1.453152027,LS=1.061405429;function Zo(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function g$(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function y$(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function _$(n){const t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function VS(n,t){return{real:n[2*t],imag:n[2*t+1]}}function v$(n,t,e,r){n[2*r]=t,n[2*r+1]=e}function b$(n,t){const e=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const i=(t?2:-2)*Math.PI*(s/n);e[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:e,imag:r}}function x$(n,t,e){const r=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(r),imag:Math.sin(r)}}const ooe=/->/g;function zS(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(ooe,"").length)/"->".length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=n.split("->");S(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const i=r.split(","),o=i.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<s.length;++h){const f=s[h];if(!i.some(p=>-1!==p.indexOf(f)))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);-1===a.indexOf(f)&&a.push(f)}for(let h=0;h<r.length;++h){const f=r[h];-1===a.indexOf(f)&&","!==f&&a.push(f)}const l=new Array(i.length);for(let h=0;h<o;++h){if(new Set(i[h].split("")).size!==i[h].length)throw new Error(`Found duplicate axes in input component ${i[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let f=0;f<i[h].length;++f)l[h].push(a.indexOf(i[h][f]))}const c=a.length,d=[];for(let h=s.length;h<c;++h)d.push(h);return{allDims:a,summedDims:d,idDims:l}}function US(n,t){let e=new Array(n);e.fill(-1);for(let s=0;s<t.length;++s)e[t[s]]=s;const r=[];for(let s=0;s<n;++s)-1===e[s]&&r.push(s);return e=e.filter(s=>-1!==s),{permutationIndices:e,expandDims:r}}function HS(n,t,e){const r=new Array(n);for(let s=0;s<e.length;++s){const i=e[s].shape;for(let o=0;o<t[s].length;++o)void 0===r[t[s][o]]?r[t[s][o]]=i[o]:S(r[t[s][o]]===i[o],()=>`Expected dimension ${r[t[s][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function jS(n,t){const e=n,r=[];let s=0;0===n.length&&e.push(-1),s=n.length+1;for(let o=0;o<s;++o)r.push([]);const i=[];for(let o=0;o<e.length;++o){const l=aoe(t,e[o]);for(const c of l)-1===i.indexOf(c)&&(r[o].push(c),i.push(c))}return{path:e,steps:r}}function WS(n){return n.every((t,e)=>t===e)}function aoe(n,t){const e=[];for(let r=0;r<n.length;++r)(0===n[r].length||-1!==n[r].indexOf(t)||-1===t)&&e.push(r);return e}function GS(n,t,e=0){let r=[];if("number"==typeof t)S(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{S(t.reduce((o,a)=>(-1===a&&(o+=1),o),0)<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(-1!==i){const o=t.reduce((a,l)=>l>0?a+l:a);t[i]=n.shape[e]-o}S(n.shape[e]===t.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function D$(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function S$(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function E$(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function I$(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function T$(n,t){return`size ${n} must be non-negative, not ${t}`}function k$(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function N$(n,t){return`Input to reshape is a SparseTensor with ${ce(n)}\n  dense values, but the requested shape requires a multiple of ${ce(t)}. inputShape=${n} outputShape= ${t}`}function A$(n,t){return`Input to reshape is a tensor with ${ce(n)} dense values, but the requested shape has ${ce(t)}. inputShape=${n} outputShape=${t}`}function qS(){return"segment ids must be >= 0"}function R$(){return"segment ids are not increasing"}function M$(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function O$(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function F$(n,t){let r,e=!1;for(n<=TS?(r=n,e=!0):r=cC(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=cC(n,r+1);return r}function P$(n,t,e){const r=[],s=n.length;for(let i=0;i<s;i++)r.push(i!==t?n[i]:e);return r}function KS(n,t,e,r){const s=t.shape.length,i=n.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${i}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let d=0;d<r;++d)if(n.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const o=n.shape[e],a=[];let l=1,c=1,u=1;for(let d=0;d<r;++d)a.push(n.shape[d]),l*=n.shape[d];for(let d=r;d<e;d++)a.push(n.shape[d]),c*=n.shape[d];for(let d=r;d<s;d++)a.push(t.shape[d]);for(let d=e+1;d<i;d++)a.push(n.shape[d]),u*=n.shape[d];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}function Ul(n){try{return n.map(t=>pu(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function $$(n){return n.map(t=>Ta(t))}function L$(n,t){const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);const r=Nt(n,"int32"),s=Nt([e.length,n.length],"int32");for(let i=0;i<e.length;i++){const o=r.indexToLoc(e[i]);s.values.set(o,i*n.length)}return s.toTensor()}const V$={kernelName:Wg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>P(n,Uf(Ne(e,"float32"),-1))}}},loe={kernelName:Mh,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=an(Ne(e,"float32")),s=qr(Ue(lt(1),r));return Rn(Ze(n,s))}}}},coe={kernelName:Oh,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=qr(Ue(an(Ne(e,"float32")),1));return Ze(n,r)}}}},uoe={kernelName:hu,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=gt(e.shape,r.shape);return{a:()=>{let a=n;const l=er(e.shape,s);return l.length>0&&(a=He(a,l)),j(a,e.shape)},b:()=>{let a=n;const l=er(r.shape,s);return l.length>0&&(a=He(a,l)),j(a,r.shape)}}}},doe={kernelName:fC,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((r,s)=>{e[s]=()=>n.clone()}),e}},hoe={kernelName:Gg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ft(e)}}},foe={kernelName:qg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ft(e)}}},poe={kernelName:Fh,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ze(n,qr(Ue(lt(1),an(Ne(e,"float32")))))}}},moe={kernelName:Ph,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=qr(we(lt(1),an(Ne(e,"float32"))));return Ze(n,r)}}}},goe={kernelName:Vh,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=gt(e.shape,r.shape);return{a:()=>{const a=we(an(e),an(r));let l=P(n,Ze(r,a));const c=er(e.shape,s);return c.length>0&&(l=He(l,c)),j(l,e.shape)},b:()=>{const a=we(an(e),an(r));let l=Rn(P(n,Ze(e,a)));const c=er(r.shape,s);return c.length>0&&(l=He(l,c)),j(l,r.shape)}}}},yoe={kernelName:$h,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ze(n,we(an(Ne(e,"float32")),1))}}},_oe={kernelName:Lh,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ze(n,Ue(lt(1),an(Ne(e,"float32"))))}}},boe=z({avgPool3dGrad_:function voe(n,t,e,r,s,i){const o=T(n,"dy","avgPool3dGrad"),a=T(t,"input","avgPool3dGrad");let l=o,c=a,u=!1;4===a.rank&&(u=!0,l=j(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=j(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),S(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),S(5===c.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),Gr("avgPool3dGrad",s,i);const f=$.runKernel(yC,{dy:l,input:c},{filterSize:e,strides:r,pad:s,dimRoundingMode:i});return u?j(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),xoe={kernelName:Xg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:a}=e;return{x:()=>boe(n,r,s,i,o,a)}}},Coe=z({avgPoolGrad_:function woe(n,t,e,r,s){const i=T(n,"dy","avgPoolGrad"),o=T(t,"input","avgPoolGrad");S(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,c=!1;3===o.rank&&(c=!0,a=j(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=j(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),S(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=$.runKernel(gC,{dy:l,input:a},{filterSize:e,strides:r,pad:s});return c?j(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Doe={kernelName:Kg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:i,pad:o}=e;return{x:()=>Coe(n,r,s,i,o)}}},Soe={kernelName:Yg,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[r,s]=t,{transposeA:i,transposeB:o}=e;return i||o?!i&&o?{a:()=>Ht(n,s,!1,!1),b:()=>Ht(n,r,!0,!1)}:i&&!o?{a:()=>Ht(s,n,!1,!0),b:()=>Ht(r,n,!1,!1)}:{a:()=>Ht(s,n,!0,!0),b:()=>Ht(n,r,!0,!0)}:{a:()=>Ht(n,s,!1,!0),b:()=>Ht(r,n,!0,!1)}}},XS=z({spaceToBatchND_:function Eoe(n,t,e){const r=T(n,"x","spaceToBatchND");return S(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),S(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),S(r.shape.reduce((o,a,l)=>l>0&&l<=t.length?o&&(a+e[l-1][0]+e[l-1][1])%t[l-1]==0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),$.runKernel(Ly,{x:r},{blockShape:t,paddings:e})}}),Ioe={kernelName:Zg,gradFunc:(n,t,e)=>{const{blockShape:r,crops:s}=e;return{x:()=>XS(n,r,s)}}},Toe={kernelName:"BroadcastTo",gradFunc:(n,t,e)=>{const s=e.inputShape,i=e.shape,o=Array.from(i);for(let l=s.length-1;l>=0;l--)if(s[l]===i[l])o[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>He(n,a,!0)}}},koe={kernelName:Bh,gradFunc:n=>({x:()=>n.clone()})},Noe={kernelName:zh,gradFunc:n=>({x:()=>Ft(n)})},Aoe={kernelName:Uh,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{clipValueMin:s,clipValueMax:i}=e;return{x:()=>xs(Ko(Du(r,s),Tu(r,i)),n,Ft(n))}}},Roe={kernelName:Qg,inputsToSave:["x"],gradFunc:V$.gradFunc},Moe={kernelName:Jg,saveAllInputs:!0,gradFunc:(n,t,e)=>{const r=t.map(l=>l.shape),{axis:s}=e,i=It(s,t[0].shape)[0],o=r.map(l=>l[i]);return zs(n,o,i).map(l=>()=>l)}},Ooe={kernelName:ey,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{dilations:i,strides:o,pad:a,dataFormat:l}=e;return S(Ma(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>qD(r.shape,n,s,o,a,l),filter:()=>dS(r,n,s.shape,o,a,l)}}},Foe={kernelName:ty,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>Ll(n,s,i,o,a,1,l),filter:()=>dS(n,r,s.shape,i,o,a,l)}}},$oe=z({conv3DBackpropFilter_:function Poe(n,t,e,r,s){let i=n;4===n.rank&&(i=j(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;return 4===o.rank&&(o=j(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),S(5===i.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),S(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),S(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),S(i.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${e[3]}.`),S(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`),$.runKernel(xC,{x:i,dy:o},{strides:r,pad:s,filterShape:e})}}),Loe={kernelName:ny,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:i}=e;S(Ma(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=t;return{x:()=>B2(o.shape,n,a,s,i),filter:()=>$oe(o,n,a.shape,s,i)}}},B$=z({sin_:function Voe(n){const e={x:T(n,"x","sin","float32")};return $.runKernel(vf,e)}}),Boe={kernelName:Hh,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>P(Rn(B$(Ne(e,"float32"))),n)}}},z$=z({sinh_:function zoe(n){const e={x:T(n,"x","sinh")};return $.runKernel(bf,e)}}),Uoe={kernelName:jh,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>P(z$(Ne(e,"float32")),n)}}},U$=z({cumsum_:function Hoe(n,t=0,e=!1,r=!1){const i={x:T(n,"x","cumsum")};return $.runKernel(ry,i,{axis:t,exclusive:e,reverse:r})}}),joe={kernelName:ry,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s,exclusive:i,reverse:o}=e;return{x:()=>{const a=Sn([s],r.rank);let l=U$(n,s,i,!o);return null!=a&&(l=zt(l,a)),l}}}},Woe={kernelName:sy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:o}=e,a=null==r?[1,1]:r;S(Ma(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=t;return S(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),S(4===c.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),S(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),S(Er(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),Gr("depthwiseConv2d",i,o),{x:()=>t$(l.shape,n,c,s,i,a,o),filter:()=>e$(l,n,c.shape,s,i,a,o)}}},Goe={kernelName:iy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,i={x:r,filter:s,dy:n},o={x:r,filter:s,dy:n};return{x:()=>$.runKernel(TC,i,e),filter:()=>$.runKernel(kC,o,e)}}},qoe={kernelName:Gh,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,r={dy:n,y:e};return{x:()=>$.runKernel(NC,r)}}},Koe={kernelName:qh,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=P(di(Rn(an(e))),2/Math.sqrt(Math.PI));return{x:()=>P(n,r)}}},Xoe={kernelName:Kh,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>P(n,e)}}},Yoe={kernelName:ay,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>j(n,e.shape)}}},Zoe={kernelName:Xh,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>P(n,di(e))}}},Qoe={kernelName:Yh,gradFunc:n=>({x:()=>Ft(n)})},Joe={kernelName:Zh,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=gt(e.shape,r.shape);return{a:()=>{const a=Ze(n,Ne(r,"float32")),l=er(e.shape,s);return l.length>0?j(He(a,l),e.shape):a},b:()=>{let a=P(n,Ne(e,"float32"));const l=er(r.shape,s);l.length>0&&(a=j(He(a,l),r.shape));const c=an(r);return Rn(Ze(a,Ne(c,"float32")))}}}},H$=z({rsqrt_:function eae(n){const e={x:T(n,"x","rsqrt","float32")};return $.runKernel(yf,e)}}),tae={kernelName:ly,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:r}=e,[s,i,o,a]=t,l=null==a?lt(1):a,c=er(i.shape,s.shape),u=[];if(1===i.rank){for(let b=0;b<s.shape.length-1;++b)u.push(s.shape[b]);u.push(1)}const d=Ue(s,i),h=P(n,l),f=H$(we(o,lt(r))),p=P(P(P(f,f),f),lt(-.5));return{x:()=>j(P(P(n,1===i.rank?Vi(j(f,[1,1,1,i.shape[0]]),u):f),l),s.shape),mean:()=>{let b=P(P(f,lt(-1)),h);return 1===i.rank&&(b=He(b,c)),j(b,i.shape)},variance:()=>{let b=P(P(p,d),h);return 1===i.rank&&(b=He(b,c)),j(b,i.shape)},scale:()=>{const b=P(d,f);let w=P(n,b);return 1===i.rank&&(w=He(w,c)),j(w,i.shape)},offset:()=>{let b=n;return 1===i.rank&&(b=He(b,c)),j(b,i.shape)}}}},j$=z({unsortedSegmentSum_:function nae(n,t,e){const r=T(n,"x","unsortedSegmentSum"),s=T(t,"segmentIds","unsortedSegmentSum","int32");return S(uu(e),()=>"numSegments must be of dtype int"),$.runKernel(Hy,{x:r,segmentIds:s},{numSegments:e})}}),rae={kernelName:cy,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[r,s]=t,{axis:i}=e,o=It(i,r.shape)[0];return{x:()=>{const l=r.shape,c=s.size,u=l.slice(0,o),d=u.length,h=l.slice(i,l.length).slice(1),f=h.length,p=W$(0,d),m=W$(d+1,d+1+f),g=G$([u,[c],h]),_=j(n,g),y=j(s,[c]),v=G$([[d],p,m]),b=zt(_,v);let w=j$(b,y,r.shape[o]);const C=Fa(v);return w=zt(w,C),w},indices:()=>s}}};function W$(n,t){const e=[];for(let r=n;r<t;++r)e.push(r);return e}function G$(n){const t=[];for(let e=0;e<n.length;++e)for(let r=0;r<n[e].length;++r)t.push(n[e][r]);return t}const sae={kernelName:Qh,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>Ft(e),b:()=>Ft(r)}}},iae={kernelName:Jh,gradFunc:n=>({x:()=>Ne(n,"float32")})},oae={kernelName:ef,gradFunc:n=>({x:()=>Ft(n)})},aae={kernelName:nf,gradFunc:n=>({x:()=>Ft(n)})},lae={kernelName:rf,gradFunc:n=>({x:()=>Ft(n)})},cae={kernelName:dy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{alpha:s}=e,i=fi(r,0);return{x:()=>xs(i,n,P(n,s))}}},uae={kernelName:af,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ze(n,we(e,1))}}},dae={kernelName:sf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ze(n,Ne(e,"float32"))}}},hae={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;return{logits:()=>{const o=di(r);return Ue(n,P(He(n,s,!0),o))}}}},pae=z({localResponseNormalizationBackprop_:function fae(n,t,e,r=5,s=1,i=1,o=.5){return $.runKernel(PC,{x:n,y:t,dy:e},{depthRadius:r,bias:s,alpha:i,beta:o})}}),mae={kernelName:yy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{depthRadius:i,bias:o,alpha:a,beta:l}=e;return{x:()=>pae(r,s,n,i,o,a,l)}}};function q$(n,t,e,r){return t.rank<e.rank&&(t=j(t,Bn(t.shape,r))),n.rank<e.rank&&(n=j(n,Bn(n.shape,r))),{x:()=>P(n,Ne(mo(e,t),n.dtype))}}const K$={kernelName:_y,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{reductionIndices:s}=r,i=t[0],l=q$(n,t[1],i,It(s,i.shape));return{x:()=>l.x()}}},X$=z({less_:function gae(n,t){let e=T(n,"a","less","string_or_numeric"),r=T(t,"b","less","string_or_numeric");return[e,r]=Nn(e,r),gt(e.shape,r.shape),$.runKernel(hy,{a:e,b:r})}}),yae={kernelName:lf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>P(n,Ne(Du(e,r),"float32")),b:()=>P(n,Ne(X$(e,r),"float32"))}}},vae=z({maxPool3dGrad_:function _ae(n,t,e,r,s,i,o){const a=T(n,"dy","maxPool3dGrad"),l=T(t,"input","maxPool3dGrad"),c=T(e,"output","maxPool3dGrad");let u=a,d=l,h=c,f=!1;4===l.rank&&(f=!0,u=j(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=j(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=j(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),S(5===u.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),S(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),S(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),Gr("maxPool3dGrad",i,o);const g=$.runKernel(LC,{dy:u,input:d,output:h},{filterSize:r,strides:s,pad:i,dimRoundingMode:o});return f?j(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),bae={kernelName:by,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=e;return{x:()=>vae(n,r,s,i,o,a,l)}}},wae=z({maxPoolGrad_:function xae(n,t,e,r,s,i,o){const a=T(n,"dy","maxPoolGrad"),l=T(t,"input","maxPoolGrad"),c=T(e,"output","maxPoolGrad");return S(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),S(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),S(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Gr("maxPoolGrad",i,o),$.runKernel($C,{dy:a,input:l,output:c},{filterSize:r,strides:s,pad:i,dimRoundingMode:o})}}),Cae={kernelName:vy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:i,strides:o,pad:a}=e;return{x:()=>wae(n,r,s,i,o,a)}}},Dae={kernelName:xy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e,i=It(s,r.shape),l=ce(yr(r.shape,i)[1]);return{x:()=>{const u=r.shape.slice();i.forEach(f=>{u[f]=1});const d=j(n,u);return Ze(P(d,Pa(r.shape,"float32")),l)}}}},Sae={kernelName:wy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{axis:s}=r,[i,o]=t,l=q$(n,o,i,It(s,i.shape));return{x:()=>l.x()}}},Eae={kernelName:cf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>P(n,Ne(Tu(e,r),"float32")),b:()=>P(n,Ne(fi(e,r),"float32"))}}},Iae={kernelName:Cy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,i=s.map(o=>o[0]);return{x:()=>Yt(n,i,r.shape)}}},Tae={kernelName:uf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=gt(e.shape,r.shape);return{a:()=>{const a=er(e.shape,s);return a.length>0?j(He(n,a),e.shape):n},b:()=>{const a=P(n,Rn(p_(Ze(e,r)))),l=er(r.shape,s);return l.length>0?j(He(a,l),r.shape):a}}}},kae={kernelName:df,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=gt(e.shape,r.shape);return{a:()=>{const a=P(n,Ne(r,"float32")),l=er(e.shape,s);return l.length>0?j(He(a,l),e.shape):a},b:()=>{const a=P(n,Ne(e,"float32")),l=er(r.shape,s);return l.length>0?j(He(a,l),r.shape):a}}}},Nae={kernelName:Dy,gradFunc:n=>({x:()=>Rn(n)})},Aae={kernelName:Iy,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>_r(e.shape,"float32")}}},Rae={kernelName:Ey,gradFunc:n=>({x:()=>Ft(n)})},Mae={kernelName:Ty,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:r}=e;return Eu(n,r).map(i=>()=>i)}},Y$={kernelName:ky,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,i=s.map(o=>o[0]);return{x:()=>Yt(n,i,r.shape)}}},Oae={kernelName:hf,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,r,s]=t,i=e,o=r,a=gt(i.shape,o.shape);return{a:()=>{const u=Ne(o,"float32");let d=P(n,P(u,ku(i,Ue(u,lt(1)))));const h=er(i.shape,a);return h.length>0&&(d=He(d,h)),j(d,i.shape)},b:()=>{const u=fi(i,0),d=xs(u,pi(i),Ft(i));let h=P(n,P(s,d));const f=er(o.shape,a);return f.length>0&&(h=He(h,f)),j(h,o.shape)}}}},Fae={kernelName:Ny,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,r]=t,s=fi(e,0);return{x:()=>xs(s,n,P(n,r)),alpha:()=>{let i=xs(s,Ft(n),P(n,e));const o=er(r.shape,n.shape);return o.length>0&&(i=He(i,o)),j(i,r.shape)}}}},Pae={kernelName:Wh,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=gt(e.shape,r.shape);return{a:()=>{const a=Ze(n,Ne(r,"float32")),l=er(e.shape,s);return l.length>0?j(He(a,l),e.shape):a},b:()=>{let a=P(n,Ne(e,"float32"));const l=er(r.shape,s);l.length>0&&(a=j(He(a,l),r.shape));const c=an(r);return Rn(Ze(a,Ne(c,"float32")))}}}},$ae={kernelName:ff,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ze(n,Rn(an(e)))}}},Lae={kernelName:mf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=P(Tu(e,6),Uf(e));return{x:()=>P(n,Ne(r,"float32"))}}},Vae={kernelName:pf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>P(n,Ne(Uf(e),"float32"))}}},Bae={kernelName:Ay,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>j(n,e.shape)}}},zae={kernelName:My,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>$.runKernel(GC,s,e)}}},Uae={kernelName:Ry,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>$.runKernel(WC,s,e)}}},Hae={kernelName:Oy,gradFunc:(n,t,e)=>{const{dims:r}=e,s=It(r,n.shape);return{x:()=>Vl(n,s)}}},jae={kernelName:gf,gradFunc:n=>({x:()=>Ft(n)})},Wae={kernelName:yf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Rn(Ze(n,P(ku(e,1.5),2)))}}},YS=z({logicalNot_:function Gae(n){const e={x:T(n,"x","logicalNot","bool")};return $.runKernel(my,e)}}),qae={kernelName:Fy,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>Ne(Ft(e),"float32"),t:()=>P(n,Ne(e,n.dtype)),e:()=>P(n,Ne(YS(e),n.dtype))}}},Kae={kernelName:_f,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=fi(e,lt(0)),s=lt(T_),i=lt(k_),o=P(n,i),a=P(P(n,s),di(Ne(e,"float32")));return xs(r,o,a)}}}},Xae={kernelName:wf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>P(n,P(e,Ue(lt(1),e)))}}},Yae={kernelName:xf,gradFunc:n=>({x:()=>Ft(n)})},ZS=z({cos_:function Zae(n){const e={x:T(n,"x","cos","float32")};return $.runKernel(Hh,e)}}),Qae={kernelName:vf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>P(ZS(Ne(e,"float32")),n)}}},Z$=z({cosh_:function Jae(n){const e={x:T(n,"x","cosh","float32")};return $.runKernel(jh,e)}}),ele={kernelName:bf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>P(Z$(Ne(e,"float32")),n)}}},tle={kernelName:Py,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{begin:s,size:i}=e,o=r.shape,[a,l]=a_(r,s,i),c=[];for(let u=0;u<n.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>eS(n,c)}}},nle={kernelName:By,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{dim:s}=e,o=P(n,r);return{logits:()=>Ue(o,P(He(o,[s],!0),r))}}},rle={kernelName:Cf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>P(n,Su(e))}}},QS=z({batchToSpaceND_:function sle(n,t,e){const r=T(n,"x","batchToSpaceND"),s=t.reduce((a,l)=>a*l);return S(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),S(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),S(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),$.runKernel(Zg,{x:r},{blockShape:t,crops:e})}}),Q$={kernelName:Ly,gradFunc:(n,t,e)=>{const{blockShape:r,paddings:s}=e;return{x:()=>QS(n,r,s)}}},J$={kernelName:Vy,gradFunc:(n,t,e)=>{const{axis:r}=e;return{x:()=>Lr(n,r)}}},vle=[V$,loe,coe,uoe,doe,hoe,foe,poe,moe,goe,yoe,_oe,xoe,Doe,Soe,Ioe,Toe,koe,Noe,Aoe,Roe,Moe,Foe,Ooe,Loe,Boe,Uoe,joe,Woe,Goe,Pae,qoe,Koe,Xoe,Yoe,Zoe,Joe,Qoe,tae,rae,sae,iae,oae,aae,lae,cae,uae,dae,hae,mae,K$,K$,yae,bae,Cae,Dae,Sae,Eae,Iae,Tae,kae,Nae,Aae,Rae,Mae,Y$,Y$,Oae,Fae,$ae,Lae,Vae,Bae,zae,Uae,Hae,jae,Wae,qae,Kae,Xae,Yae,Qae,ele,tle,nle,rle,Q$,Q$,J$,J$,{kernelName:Df,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ze(n,P(qr(Ne(e,"float32")),2))}}},{kernelName:Sf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=lt(2);return{a:()=>P(n,P(s,Ue(e,r))),b:()=>P(n,P(s,Ue(r,e)))}}},{kernelName:ZC,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>P(n,P(Ne(e,"float32"),2))}}},{kernelName:Nf,gradFunc:n=>({x:()=>Ft(n)})},{kernelName:Ef,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=gt(e.shape,r.shape);return{a:()=>{let a=n;const l=er(e.shape,s);return l.length>0&&(a=He(a,l)),j(a,e.shape)},b:()=>{let a=n;const l=er(r.shape,s);return l.length>0&&(a=He(a,l)),j(Rn(a),r.shape)}}}},{kernelName:$y,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,s=r.shape.slice(),{axis:i}=e;It(i,r.shape).forEach(c=>{s[c]=1});const a=j(n,s),l=P(a,Pa(r.shape,"float32"));return{x:()=>l}}},{kernelName:If,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ze(n,an(ZS(e)))}}},{kernelName:Tf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>P(Ue(lt(1),an(e)),n)}}},{kernelName:kf,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{reps:s}=e;return{x:()=>{let o=Ft(r);if(1===r.rank)for(let a=0;a<s[0];++a)o=we(o,Yt(n,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)o=we(o,Yt(n,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)o=we(o,Yt(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)for(let u=0;u<s[3];++u)o=we(o,Yt(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return o}}}},{kernelName:zy,gradFunc:(n,t,e)=>{const r=e,{perm:s}=r,i=Fa(s);return{x:()=>zt(n,i)}}},{kernelName:Uy,gradFunc:(n,t,e)=>{const r=e,{axis:s}=r;return{value:()=>Bl(n,s)}}},{kernelName:Hy,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function yle(n,t){const e=Oa(t,Ft(t)),r=KD(n,e);let s=Du(t,lt(0,"int32"));const i=r.rank-s.rank;for(let a=0;a<i;++a)s=hi(s,a+1);s=Ko(s,Pa(r.shape,"bool"));const o=Ft(r);return xs(s,r,o)}(n,e)}}},{kernelName:jy,gradFunc:n=>({x:()=>Ft(n)})}];for(const n of vle)Pee(n);le().prototype.abs=function(){return this.throwIfDisposed(),mr(this)};const xle=z({acos_:function ble(n){const e={x:T(n,"x","acos")};return $.runKernel(Mh,e)}});le().prototype.acos=function(){return this.throwIfDisposed(),xle(this)};const Cle=z({acosh_:function wle(n){const e={x:T(n,"x","acosh")};return $.runKernel(Oh,e)}});le().prototype.acosh=function(){return this.throwIfDisposed(),Cle(this)},le().prototype.add=function(n){return this.throwIfDisposed(),we(this,n)},le().prototype.all=function(n,t){return this.throwIfDisposed(),$2(this,n,t)},le().prototype.any=function(n,t){return this.throwIfDisposed(),HD(this,n,t)},le().prototype.argMax=function(n){return this.throwIfDisposed(),$f(this,n)};const Sle=z({argMin_:function Dle(n,t=0){const r={x:T(n,"x","argMin")};return $.runKernel(qg,r,{axis:t})}});le().prototype.argMin=function(n){return this.throwIfDisposed(),Sle(this,n)},le().prototype.asScalar=function(){return this.throwIfDisposed(),S(1===this.size,()=>"The array must have only 1 element."),j(this,[])},le().prototype.asType=function(n){return this.throwIfDisposed(),Ne(this,n)},le().prototype.as1D=function(){return this.throwIfDisposed(),j(this,[this.size])},le().prototype.as2D=function(n,t){return this.throwIfDisposed(),j(this,[n,t])},le().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),j(this,[n,t,e])},le().prototype.as4D=function(n,t,e,r){return this.throwIfDisposed(),j(this,[n,t,e,r])},le().prototype.as5D=function(n,t,e,r,s){return this.throwIfDisposed(),j(this,[n,t,e,r,s])};const Ile=z({asin_:function Ele(n){const e={x:T(n,"x","asin")};return $.runKernel(Fh,e)}});le().prototype.asin=function(){return this.throwIfDisposed(),Ile(this)};const kle=z({asinh_:function Tle(n){const e={x:T(n,"x","asinh")};return $.runKernel(Ph,e)}});le().prototype.asinh=function(){return this.throwIfDisposed(),kle(this)};const Ale=z({atan_:function Nle(n){const e={x:T(n,"x","atan")};return $.runKernel($h,e)}});le().prototype.atan=function(){return this.throwIfDisposed(),Ale(this)};const Mle=z({atan2_:function Rle(n,t){let e=T(n,"a","atan2"),r=T(t,"b","atan2");return[e,r]=Nn(e,r),$.runKernel(Vh,{a:e,b:r})}});le().prototype.atan2=function(n){return this.throwIfDisposed(),Mle(this,n)};const Fle=z({atanh_:function Ole(n){const e={x:T(n,"x","atanh")};return $.runKernel(Lh,e)}});le().prototype.atanh=function(){return this.throwIfDisposed(),Fle(this)},le().prototype.avgPool=function(n,t,e,r){return this.throwIfDisposed(),GD(this,n,t,e,r)},le().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),QS(this,n,t)},le().prototype.batchNorm=function(n,t,e,r,s){return this.throwIfDisposed(),u_(this,n,t,e,r,s)},le().prototype.broadcastTo=function(n){return this.throwIfDisposed(),__(this,n)},le().prototype.cast=function(n){return this.throwIfDisposed(),Ne(this,n)};const $le=z({ceil_:function Ple(n){const e={x:T(n,"x","ceil","float32")};return $.runKernel(zh,e)}});le().prototype.ceil=function(){return this.throwIfDisposed(),$le(this)},le().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Bs(this,n,t)},le().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof Ln&&(n=[n]),Lr([this,...n],t)},le().prototype.conv1d=function(n,t,e,r,s,i){return this.throwIfDisposed(),L2(this,n,t,e,r,s,i)},le().prototype.conv2dTranspose=function(n,t,e,r,s){return this.throwIfDisposed(),V2(this,n,t,e,r,s)},le().prototype.conv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),Ll(this,n,t,e,r,s,i)},le().prototype.cos=function(){return this.throwIfDisposed(),ZS(this)},le().prototype.cosh=function(){return this.throwIfDisposed(),Z$(this)};const Vle=z({cumprod_:function Lle(n,t=0,e=!1,r=!1){const i={x:T(n,"x","cumprod")};return $.runKernel(CC,i,{axis:t,exclusive:e,reverse:r})}});le().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),Vle(this,n,t,e)},le().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),U$(this,n,t,e)};const zle=z({depthToSpace_:function Ble(n,t,e="NHWC"){const r=T(n,"x","depthToSpace","float32"),s="NHWC"===e?r.shape[1]:r.shape[2],i="NHWC"===e?r.shape[2]:r.shape[3],o="NHWC"===e?r.shape[3]:r.shape[1];return S(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),S(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),S(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t} for depthToSpace with input shape\n        ${r.shape}`),S(o%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${r.shape}`),$.runKernel(SC,{x:r},{blockSize:t,dataFormat:e})}});le().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),zle(this,n,t)},le().prototype.depthwiseConv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),d_(this,n,t,e,r,s,i)};const Hle=z({dilation2d_:function Ule(n,t,e,r,s=[1,1],i="NHWC"){const o=T(n,"x","dilation2d"),a=T(t,"filter","dilation2d");S(3===o.rank||4===o.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),S(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),S("NHWC"===i,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;3===o.rank&&(l=j(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0);const h=$.runKernel(iy,{x:l,filter:a},{strides:e,pad:r,dilations:s});return c?j(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});le().prototype.dilation2d=function(n,t,e,r,s){return this.throwIfDisposed(),Hle(this,n,t,e,r,s)};const Wle=z({divNoNan_:function jle(n,t){let e=T(n,"a","div"),r=T(t,"b","div");[e,r]=Nn(e,r);const s=Ze(e,r),i=Ft(s),o=mo(r,i);return xs(o,i,s)}});le().prototype.divNoNan=function(n){return this.throwIfDisposed(),Wle(this,n)},le().prototype.div=function(n){return this.throwIfDisposed(),Ze(this,n)};const qle=z({dot_:function Gle(n,t){const e=T(n,"t1","dot"),r=T(t,"t2","dot");S(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],i=1===r.rank?r.size:r.shape[0];if(S(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),1===e.rank&&1===r.rank){const o=j(e,[1,-1]),a=j(r,[-1,1]),l=Ht(o,a);return j(l,[])}if(1===e.rank&&2===r.rank){const o=j(e,[1,-1]),a=j(r,[r.shape[0],r.shape[1]]),l=Ht(o,a);return j(l,[l.size])}if(2===e.rank&&1===r.rank){const o=j(r,[-1,1]),a=Ht(e,o);return j(a,[a.size])}{const o=j(r,[r.shape[0],r.shape[1]]);return Ht(e,o)}}});le().prototype.dot=function(n){return this.throwIfDisposed(),qle(this,n)},le().prototype.elu=function(){return this.throwIfDisposed(),h_(this)},le().prototype.equal=function(n){return this.throwIfDisposed(),mo(this,n)};const Xle=z({erf_:function Kle(n){let t=T(n,"x","erf");return S("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=Ne(t,"float32")),$.runKernel(qh,{x:t})}});le().prototype.erf=function(){return this.throwIfDisposed(),Xle(this)},le().prototype.exp=function(){return this.throwIfDisposed(),di(this)},le().prototype.expandDims=function(n){return this.throwIfDisposed(),hi(this,n)};const Zle=z({expm1_:function Yle(n){const e={x:T(n,"x","expm1")};return $.runKernel(Xh,e)}});le().prototype.expm1=function(){return this.throwIfDisposed(),Zle(this)},le().prototype.fft=function(){return this.throwIfDisposed(),cS(this)},le().prototype.flatten=function(){return this.throwIfDisposed(),j(this,[this.size])},le().prototype.floor=function(){return this.throwIfDisposed(),p_(this)},le().prototype.floorDiv=function(n){return this.throwIfDisposed(),z2(this,n)},le().prototype.gather=function(n,t){return this.throwIfDisposed(),KD(this,n,t)},le().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Du(this,n)},le().prototype.greater=function(n){return this.throwIfDisposed(),fi(this,n)},le().prototype.ifft=function(){return this.throwIfDisposed(),v_(this)},le().prototype.irfft=function(){return this.throwIfDisposed(),Q2(this)};const Jle=z({isFinite_:function Qle(n){const e={x:T(n,"x","isFinite")};return $.runKernel(ef,e)}});le().prototype.isFinite=function(){return this.throwIfDisposed(),Jle(this)};const tce=z({isInf_:function ece(n){const e={x:T(n,"x","isInf")};return $.runKernel(nf,e)}});le().prototype.isInf=function(){return this.throwIfDisposed(),tce(this)};const rce=z({isNaN_:function nce(n){const e={x:T(n,"x","isNaN")};return $.runKernel(rf,e)}});le().prototype.isNaN=function(){return this.throwIfDisposed(),rce(this)},le().prototype.leakyRelu=function(n){return this.throwIfDisposed(),XD(this,n)},le().prototype.lessEqual=function(n){return this.throwIfDisposed(),Tu(this,n)},le().prototype.less=function(n){return this.throwIfDisposed(),X$(this,n)};const ice=z({localResponseNormalization_:function sce(n,t=5,e=1,r=1,s=.5){const i=T(n,"x","localResponseNormalization");S(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),S(uu(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=i,a=!1;3===i.rank&&(a=!0,o=j(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u=$.runKernel(yy,{x:o},{depthRadius:t,bias:e,alpha:r,beta:s});return a?j(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});le().prototype.localResponseNormalization=function(n,t,e,r){return this.throwIfDisposed(),ice(this,n,t,e,r)};const ace=z({logSigmoid_:function oce(n){const t=T(n,"x","logSigmoid");return Wo(r=>({value:Rn(Bf(Rn(r))),gradFunc:o=>P(o,Su(Rn(r)))}))(t)}});le().prototype.logSigmoid=function(){return this.throwIfDisposed(),ace(this)},le().prototype.logSoftmax=function(n){return this.throwIfDisposed(),H2(this,n)},le().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),f$(this,n,t)},le().prototype.log=function(){return this.throwIfDisposed(),pi(this)},le().prototype.log1p=function(){return this.throwIfDisposed(),YD(this)},le().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Ko(this,n)},le().prototype.logicalNot=function(){return this.throwIfDisposed(),YS(this)};const eL=z({logicalOr_:function lce(n,t){const e=T(n,"a","logicalOr","bool"),r=T(t,"b","logicalOr","bool");return gt(e.shape,r.shape),$.runKernel(gy,{a:e,b:r})}});le().prototype.logicalOr=function(n){return this.throwIfDisposed(),eL(this,n)};const uce=z({logicalXor_:function cce(n,t){const e=T(n,"a","logicalXor","bool"),r=T(t,"b","logicalXor","bool");return gt(e.shape,r.shape),Ko(eL(n,t),YS(Ko(n,t)))}});le().prototype.logicalXor=function(n){return this.throwIfDisposed(),uce(this,n)},le().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),Ht(this,n,t,e)},le().prototype.maxPool=function(n,t,e,r){return this.throwIfDisposed(),ZD(this,n,t,e,r)},le().prototype.max=function(n,t){return this.throwIfDisposed(),go(this,n,t)},le().prototype.maximum=function(n){return this.throwIfDisposed(),Oa(this,n)},le().prototype.mean=function(n,t){return this.throwIfDisposed(),Vn(this,n,t)},le().prototype.min=function(n,t){return this.throwIfDisposed(),vS(this,n,t)},le().prototype.minimum=function(n){return this.throwIfDisposed(),m_(this,n)};const hce=z({mirrorPad_:function dce(n,t,e){S("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=T(n,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");S(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===e?1:0;for(let a=0;a<r.rank;a++)S(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),S(t[a][0]>=0&&t[a][0]<=r.shape[a]-s&&t[a][1]>=0&&t[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return $.runKernel(Cy,{x:r},{paddings:t,mode:e})}});le().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),hce(this,n,t)};const pce=z({mod_:function fce(n,t){let e=T(n,"a","mod"),r=T(t,"b","mod");return[e,r]=Nn(e,r),$.runKernel(uf,{a:e,b:r})}});le().prototype.mod=function(n){return this.throwIfDisposed(),pce(this,n)},le().prototype.mul=function(n){return this.throwIfDisposed(),P(this,n)},le().prototype.neg=function(){return this.throwIfDisposed(),Rn(this)},le().prototype.norm=function(n,t,e){return this.throwIfDisposed(),bS(this,n,t,e)},le().prototype.notEqual=function(n){return this.throwIfDisposed(),Vf(this,n)},le().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),W2(this,n,t,e)},le().prototype.onesLike=function(){return this.throwIfDisposed(),mi(this)},le().prototype.pad=function(n,t){return this.throwIfDisposed(),eS(this,n,t)};const _ce=z({pool_:function mce(n,t,e,r,s,i,o){null==s&&(s=[1,1]),null==i&&(i=1),0===r&&(r="valid");const a=T(n,"x","maxPool");let l=a,c=!1;3===a.rank&&(c=!0,l=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(Er(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const u=ui(l.shape,t,i,s,r),d=[u.dilationHeight,u.dilationWidth];let h;h="same"===r?function yce(n,t){const r=n.map((o,a)=>o+(o-1)*(t[a]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),i=r.map((o,a)=>o-s[a]);return r.map((o,a)=>[s[a],i[a]])}([u.filterHeight,u.filterWidth],d):[[0,0],[0,0]];const f=1===d[0]&&1===d[1],[p,m]=function gce(n,t,e){const r=e.map(u=>u[0]),s=e.map(u=>u[1]),i=n.concat(r,s),o=t.map((u,d)=>(u-i[d]%u)%u),a=s.map((u,d)=>u+o[d]),l=t.map((u,d)=>[r[d],a[d]]),c=t.map((u,d)=>[0,o[d]]);return[l,c]}([u.inHeight,u.inWidth],d,h),g=f?r:"valid",_=f?l:XS(l,d,p),v=("avg"===e?()=>GD(_,t,i,g,o):()=>ZD(_,t,i,g,o))(),b=f?v:QS(v,d,m);return c?j(b,[b.shape[1],b.shape[2],b.shape[3]]):b}});le().prototype.pool=function(n,t,e,r,s,i){return this.throwIfDisposed(),_ce(this,n,t,e,r,s,i)},le().prototype.pow=function(n){return this.throwIfDisposed(),ku(this,n)},le().prototype.prelu=function(n){return this.throwIfDisposed(),tS(this,n)};const bce=z({prod_:function vce(n,t=null,e=!1){let r=T(n,"x","prod");return"bool"===r.dtype&&(r=Ne(r,"int32")),$.runKernel(UC,{x:r},{axis:t,keepDims:e})}});le().prototype.prod=function(n,t){return this.throwIfDisposed(),bce(this,n,t)};const wce=z({reciprocal_:function xce(n){const e={x:T(n,"x","reciprocal")};return $.runKernel(ff,e)}});le().prototype.reciprocal=function(){return this.throwIfDisposed(),wce(this)},le().prototype.relu=function(){return this.throwIfDisposed(),Xo(this)},le().prototype.relu6=function(){return this.throwIfDisposed(),J2(this)},le().prototype.reshapeAs=function(n){return this.throwIfDisposed(),j(this,n.shape)},le().prototype.reshape=function(n){return this.throwIfDisposed(),j(this,n)},le().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),a$(this,n,t,e)},le().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),l$(this,n,t,e)},le().prototype.reverse=function(n){return this.throwIfDisposed(),Vl(this,n)},le().prototype.rfft=function(){return this.throwIfDisposed(),uS(this)},le().prototype.round=function(){return this.throwIfDisposed(),c$(this)},le().prototype.rsqrt=function(){return this.throwIfDisposed(),H$(this)},le().prototype.selu=function(){return this.throwIfDisposed(),q2(this)},le().prototype.separableConv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),K2(this,n,t,e,r,s,i)},le().prototype.sigmoid=function(){return this.throwIfDisposed(),Su(this)};const Dce=z({sign_:function Cce(n){const e={x:T(n,"x","sign")};return $.runKernel(xf,e)}});le().prototype.sign=function(){return this.throwIfDisposed(),Dce(this)},le().prototype.sin=function(){return this.throwIfDisposed(),B$(this)},le().prototype.sinh=function(){return this.throwIfDisposed(),z$(this)},le().prototype.slice=function(n,t){return this.throwIfDisposed(),Yt(this,n,t)},le().prototype.softmax=function(n){return this.throwIfDisposed(),oS(this,n)},le().prototype.softplus=function(){return this.throwIfDisposed(),Bf(this)},le().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),XS(this,n,t)},le().prototype.split=function(n,t){return this.throwIfDisposed(),zs(this,n,t)},le().prototype.sqrt=function(){return this.throwIfDisposed(),qr(this)},le().prototype.square=function(){return this.throwIfDisposed(),an(this)},le().prototype.squaredDifference=function(n){return this.throwIfDisposed(),h$(this,n)},le().prototype.squeeze=function(n){return this.throwIfDisposed(),zf(this,n)},le().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof Ln?[this,n]:[this,...n];return Bl(e,t)},le().prototype.step=function(n){return this.throwIfDisposed(),Uf(this,n)};const Ece=z({stridedSlice_:function Sce(n,t,e,r,s=0,i=0,o=0,a=0,l=0){const u={x:T(n,"x","stridedSlice","string_or_numeric")};return $.runKernel(QC,u,{begin:t,end:e,strides:r,beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l})}});le().prototype.stridedSlice=function(n,t,e,r,s,i,o,a){return this.throwIfDisposed(),Ece(this,n,t,e,r,s,i,o,a)},le().prototype.sub=function(n){return this.throwIfDisposed(),Ue(this,n)},le().prototype.sum=function(n,t){return this.throwIfDisposed(),He(this,n,t)};const Tce=z({tan_:function Ice(n){const e={x:T(n,"x","tan","float32")};return $.runKernel(If,e)}});le().prototype.tan=function(){return this.throwIfDisposed(),Tce(this)},le().prototype.tanh=function(){return this.throwIfDisposed(),aS(this)},le().prototype.tile=function(n){return this.throwIfDisposed(),Vi(this,n)},le().prototype.toBool=function(){return this.throwIfDisposed(),Ne(this,"bool")},le().prototype.toFloat=function(){return this.throwIfDisposed(),Ne(this,"float32")},le().prototype.toInt=function(){return this.throwIfDisposed(),Ne(this,"int32")};const Nce=z({topk_:function kce(n,t=1,e=!0){const r=T(n,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const i={x:r},o={k:t,sorted:e},[a,l]=$.runKernel(nD,i,o);return{values:a,indices:l}}});le().prototype.topk=function(n,t){return this.throwIfDisposed(),Nce(this,n,t)},le().prototype.transpose=function(n){return this.throwIfDisposed(),zt(this,n)};const Rce=z({unique_:function Ace(n,t=0){const e=T(n,"x","unique","string_or_numeric");S(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:t},[i,o]=$.runKernel(sD,r,s);return{values:i,indices:o}}});let N_;function tr(){return null==N_&&(N_=function rne(){return $.backend}().epsilon()),N_}le().prototype.unique=function(n){return this.throwIfDisposed(),Rce(this,n)},le().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),j$(this,n,t)},le().prototype.unstack=function(n){return this.throwIfDisposed(),Eu(this,n)},le().prototype.where=function(n,t){return this.throwIfDisposed(),xs(n,this,t)},le().prototype.zerosLike=function(){return this.throwIfDisposed(),Ft(this)};class _o extends Error{constructor(t){super(t),Object.setPrototypeOf(this,_o.prototype)}}class gi extends Error{constructor(t){super(t),Object.setPrototypeOf(this,gi.prototype)}}class L extends Error{constructor(t){super(t),Object.setPrototypeOf(this,L.prototype)}}class ft extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ft.prototype)}}class JS extends Error{constructor(t){super(t),Object.setPrototypeOf(this,JS.prototype)}}function Hl(n,t){if(Array.isArray(n)){let e=[];for(let r=0;r<t;r++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function Us(n,t){if(!n)throw new JS(t)}function nL(n,t){let e=0;for(const r of n)r===t&&e++;return e}function ls(n){return 1===n.length?n[0]:n}function ln(n){return Array.isArray(n)?n:[n]}function Qo(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function jl(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}Error;let yi={};function eE(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function tE(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>tE(t));else{const t=Object.keys(n);for(const e of t){const r=n[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?tE(r):n[e]=r.value)}}}function Kf(n,t={},e={},r="object",s=!1){if("string"==typeof n){const i=n;let o;if(i in e)o=e[i];else if(i in yi)o=yi[i];else if(o=t[i],null==o)throw new L(`Unknown ${r}: ${n}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}{const i=n;if(null==i.className||null==i.config)throw new L(`${r}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const o=i.className;let a,l;if(o in e?[a,l]=e[o]:o in yi?[a,l]=yi.className:o in t&&([a,l]=t[o]),null==a)throw new L(`Unknown ${r}: ${o}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const c={};for(const f of Object.keys(yi))c[f]=yi[f];for(const f of Object.keys(e))c[f]=e[f];i.config.customObjects=c;const d=Object.assign({},yi);for(const f of Object.keys(e))yi[f]=e[f];tE(i.config);const h=l(a,i.config,e,s);return yi=Object.assign({},d),h}{const c=Object.assign({},yi);for(const d of Object.keys(e))yi[d]=e[d];const u=new a(i.config);return yi=Object.assign({},c),u}}}function A_(n,t){return-1*function Mce(n,t){return n<t?-1:n>t?1:0}(n,t)}function $a(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function Oce(n){if(null==n)throw new L(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function Wl(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new L(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function nE(n,t,e=0,r=1/0){return Us(e>=0),Us(r>=e),Array.isArray(n)&&n.length>=e&&n.length<=r&&n.every(s=>typeof s===t)}function vr(n,t){Array.isArray(n)?(S(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,r)=>vr(e,`element ${r+1} of ${t}`))):S(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${rL(n)}.`)}function rL(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>rL(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function sL(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}function rE(n,t){return te(()=>qr(He(P(n,n),t,!0)))}class Xf extends wu{getConfig(){return{}}}ge((()=>{class n extends Xf{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return te(()=>{const r=rE(e,this.axis),s=Bs(r,0,this.maxValue);return P(e,Ze(s,we(tr(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})()),ge((()=>{class n extends Xf{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return te(()=>Ze(e,we(tr(),rE(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})()),ge((()=>{class n extends Xf{apply(e){return Xo(e)}}return n.className="NonNeg",n})()),ge((()=>{class n extends Xf{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return te(()=>{const r=rE(e,this.axis),s=we(P(this.rate,Bs(r,this.minValue,this.maxValue)),P(1-this.rate,r));return P(e,Ze(s,we(tr(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})());const iL={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function nr(n){return eE(n)}function oL(n,t={}){return Kf(n,ci.getMap().classNameMap,t,"constraint")}function rr(n){return null==n?null:"string"==typeof n?oL({className:n in iL?iL[n]:n,config:{}}):n instanceof Xf?n:oL(n)}const Pce=["channelsFirst","channelsLast"],$ce=["nearest","bilinear"],Lce=["valid","same","causal"],Vce=["max","avg"],Bce=["sum","mul","concat","ave"],Au=new Map;function zn(n){Wl(Pce,"DataFormat",n)}function Hs(n){Wl(Lce,"PaddingMode",n)}function aL(n){Wl(Vce,"PoolMode",n)}const Yf=[];function Gl(n,t){Yf.push(n);try{const e=t();return Yf.pop(),e}catch(e){throw Yf.pop(),e}}function cL(n){if(!dL(n))throw new Error("Not a valid tensor name: '"+n+"'");return function Uce(){return 0===Yf.length?"":Yf.join("/")+"/"}()+n}function uL(n){if(!dL(n))throw new Error("Not a valid tensor name: '"+n+"'");Au.has(n)||Au.set(n,0);const t=Au.get(n);if(Au.set(n,Au.get(n)+1),t>0){const e=`${n}_${t}`;return Au.set(e,1),e}return n}const Hce=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function dL(n){return!!n.match(Hce)}function jce(n){return n===parseInt(n.toString(),10)}function La(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let r=1;for(let s=t;s<e;++s)r*=n[s];return r}function Ru(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r<t&&(t=r)}return t}function Va(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r>t&&(t=r)}return t}function zi(n,t){if(t<n)throw new L(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let r=n;r<t;++r)e.push(r);return e}function R_(n,t){return Ne(n,t)}function Zf(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),j(n,e)}function ql(n,t,e){return te(()=>{switch(n.rank){case 1:return sS(n,t,e);case 2:return X2(n,[t,0],[e,n.shape[1]]);case 3:return iS(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return y_(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Yt(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Yt(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new L(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function sE(n,t,e){return te(()=>{switch(n.rank){case 1:return sS(n,t,e);case 2:return X2(n,[0,t],[n.shape[0],e]);case 3:return iS(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return y_(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new L(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function M_(n,t,e,r){return te(()=>{switch(n.rank){case 1:return sS(n,t,e);case 2:switch(r){case 1:return ql(n,t,e);case 2:return sE(n,t,e);default:throw new L(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return ql(n,t,e);case 2:return iS(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return sE(n,t,e);default:throw new L(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return ql(n,t,e);case 2:return y_(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return y_(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return sE(n,t,e);default:throw new L(`The axis is not within the rank of the tensor ${r}`)}default:throw new L(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function iE(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),Lr(n,t)}function fL(n,t){switch(n.rank){case 1:return kne([n,t]);case 2:return Ane([n,t],0);case 3:return Mne([n,t],0);case 4:return Fne([n,t],0);default:throw new L(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function oE(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new L(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Vi(n,t)}function O_(n,t=0,e=1,r,s){return Mre(n,t,e,r,s)}function vo(n,t,e,r){if(n.rank<2||t.rank<2)throw new ft(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new ft(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return n$({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?aE(n.rank,r,"channelsLast"):null,activation:e});{const s=n.shape.slice(),i=s.pop();n=j(n,[-1,i]);const o=t.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:t.rank},(p,m)=>0===m?t.rank-2:m<=t.rank-2?m-1:m);t=j(zt(t,u),[l,-1]);const d=[...s,...c];return j(n$({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?aE(n.rank,r,"channelsLast"):null,activation:e}),d)}}function pL(n,t,e){return te(()=>(t=Array.isArray(t)?bs(t,"int32"):Ne(t,"int32"),KD(n,t,e)))}function Qf(n){return P(n,n)}function aE(n,t,e){const r=t.shape;if(1!==t.rank&&t.rank!==n)throw new L(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return j(t,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return j(t,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===n){if("channelsFirst"===e)return j(t,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return j(t,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===n){if("channelsFirst"===e)return j(t,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return j(t,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(n<3)return t;throw new L(`Unsupported input rank by biasAdd: ${t.rank}`)}function Ui(n,t,e){return te(()=>(null==e&&(e="channelsLast"),zn(e),we(n,aE(n.rank,t,e))))}function mL(n,t,e,r){return te(()=>ase(n,t,e,r))}function Jf(n,t,e=!1){return e?n():t()}const Jce=["fanIn","fanOut","fanAvg"],eue=["normal","uniform","truncatedNormal"];class _i extends wu{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}ge((()=>{class n extends _i{apply(e,r){return _r(e,r)}}return n.className="Zeros",n})());let gL=(()=>{class n extends _i{apply(e,r){return Pa(e,r)}}return n.className="Ones",n})();ge(gL),ge((()=>{class n extends _i{constructor(e){if(super(),"object"!=typeof e)throw new L(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new L(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return te(()=>P(lt(this.value),Pa(e,r)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})()),ge((()=>{class n extends _i{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return g_(e,this.minval,this.maxval,r)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})()),ge((()=>{class n extends _i{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new ft(`randomNormal does not support dType ${r}.`);return O_(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})()),ge((()=>{class n extends _i{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new ft(`truncatedNormal does not support dType ${r}.`);return Y2(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})()),ge((()=>{class n extends _i{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return te(()=>{if(2!==e.length||e[0]!==e[1])throw new L("Identity matrix initializer can only be used for 2D square matrices.");return P(this.gain,U2(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})());let js=(()=>{class n extends _i{constructor(e){if(super(),e.scale<0)throw new L(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function tue(n){Wl(Jce,"FanMode",n)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function nue(n){Wl(eue,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,r){const s=function rue(n,t="channelsLast"){let e,r;if(zn(t),2===n.length)e=n[0],r=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const s=La(n,2);e=n[1]*s,r=n[0]*s}else if("channelsLast"===t){const s=La(n,0,n.length-2);e=n[n.length-2]*s,r=n[n.length-1]*s}}else{const s=La(n);e=Math.sqrt(s),r=Math.sqrt(s)}return[e,r]}(e),i=s[0],o=s[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,i):"fanOut"===this.mode?Math.max(1,o):Math.max(1,(i+o)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new ft(`${this.getClassName()} does not support dType ${r}.`);return Y2(e,0,l,r,this.seed)}{const l=Math.sqrt(3*a);return g_(e,-l,l,r)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();ge(js);let yL=(()=>{class n extends js{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return js.className}}return n.className="GlorotUniform",n})();ge(yL);let _L=(()=>{class n extends js{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return js.className}}return n.className="GlorotNormal",n})();ge(_L);let vL=(()=>{class n extends js{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return js.className}}return n.className="HeNormal",n})();ge(vL);let bL=(()=>{class n extends js{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return js.className}}return n.className="HeUniform",n})();ge(bL);let xL=(()=>{class n extends js{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return js.className}}return n.className="LeCunNormal",n})();ge(xL);let wL=(()=>{class n extends js{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return js.className}}return n.className="LeCunNormal",n})();ge(wL),ge((()=>{class n extends _i{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new ft("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,r){return te(()=>{if(e.length<2)throw new ft("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const i=O_(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let o=roe.gramSchmidt(i);return e[0]>e[1]&&(o=zt(o)),P(this.gain,o)})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})());const CL={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function DL(n,t={}){return Kf(n,ci.getMap().classNameMap,t,"initializer")}function En(n){return eE(n)}function _n(n){if("string"==typeof n){const t=n in CL?CL[n]:n;if("GlorotNormal"===t)return new _L;if("GlorotUniform"===t)return new yL;if("HeNormal"===t)return new vL;if("HeUniform"===t)return new bL;if("LeCunNormal"===t)return new xL;if("LeCunUniform"===t)return new wL;{const e={};return e.className=t,e.config={},DL(e)}}return n instanceof _i?n:DL(n)}let sue=0;function SL(){return sue++}const F_={};function P_(n=""){return n in F_||(F_[n]=0),F_[n]+=1,n+F_[n].toString()}function lE(n){return Array.isArray(n)&&Array.isArray(n[0])}function $_(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function yt(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new L(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Gt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return(n=n)[0];throw new L(`Expected exactly 1 Shape; got ${n.length}`)}return n}function L_(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((r,s)=>r*s);return t}const EL="Variable";class bo{constructor(t,e="float32",r=EL,s=!0,i=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=SL(),this.originalName=cL(r=null==r?EL:r),this.name=uL(this.originalName),this.trainable_=s,this.constraint=i,this.val=function ese(n,t=!0,e,r){return $.makeVariable(n,t,e,r)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function iue(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function cE(n){return n.map(t=>t.read())}function uE(n){n.forEach(t=>{t[0].write(t[1])})}class sr{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class xo{constructor(t,e,r,s,i,o,a){this.dtype=t,this.shape=e,this.sourceLayer=r,this.inputs=s,this.callArgs=i,this.outputTensorIndex=a,this.id=SL(),null!=o&&(this.originalName=cL(o),this.name=uL(this.originalName)),this.rank=e.length}}let oue=0;class V_{constructor(t,e){this.callArgs=e,this.id=oue++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)null!=r&&r.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let aue=0;class Pt extends wu{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=aue++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const r=this.getClassName();e=Qo(r)+"_"+P_(r)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let r;if(null!=t.batchInputShape)r=t.batchInputShape;else if(null!=t.inputShape){let i=null;null!=t.batchSize&&(i=t.batchSize),r=[i].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;null==s&&(s=t.inputDType),null==s&&(s="float32"),this.dtype=s}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new gi(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new L(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return ls(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return ls(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new _o(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new _o(`Layer ${this.name} is not connected, no input to return.`);return ls(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new _o(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new _o(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ls(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=ln(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=ln(this.inputSpec);if(t.length!==e.length)throw new L(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let r=0;r<t.length;r++){const s=t[r],i=e[r];if(null==i)continue;const o=s.rank;if(null!=i.ndim&&o!==i.ndim)throw new L(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(null!=i.maxNDim&&o>i.maxNDim)throw new L(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(null!=i.minNDim&&o<i.minNDim)throw new L(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(null!=i.dtype&&s.dtype!==i.dtype)throw new L(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${s.dtype}.`);if(i.axes){const a=s.shape;for(const l in i.axes){const c=Number(l),u=i.axes[l],d=c>=0?a[c]:a[a.length+c];if(null!=u&&-1===[u,null].indexOf(d))throw new L(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${u} but got shape ${a}.`)}}if(null!=i.shape)for(let a=0;a<i.shape.length;++a){const l=i.shape[a],c=s.shape[a];if(null!=l&&null!=c&&l!==c)throw new L(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const r=ln(t);let s=!0;for(const o of r)if(!(o instanceof xo)){s=!1;break}let i=!0;for(const o of r)if(o instanceof xo){i=!1;break}if(s===i)throw new L("Arguments to apply() must be all SymbolicTensors or all Tensors");return Gl(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const a of ln(t))o.push(a.shape);this.build(ls(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let o=this.call(t,e);const a=ln(o),l=[];for(let c of a)-1!==r.indexOf(c)&&(c=c.clone()),l.push(c);if(o=ls(l),null!=this.activityRegularizer)throw new ft("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}{const o=function lue(n){n=ln(n);const t=[];for(const e of n)t.push(e.shape);return ls(t)}(t),a=this.computeOutputShape(o);let l;const c="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((u,d)=>new xo(c,u,this,ln(t),e,this.name,d)):new xo(c,a,this,ln(t),e,this.name),this.addInboundNode(t,l,null,null,o,a,e),this._refCount++,null!=this.activityRegularizer)throw new ft("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,s)=>{null!=r&&null!=t[s]&&t[s]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new _o(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===t.indexOf(r)&&t.push(r)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new _o(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new gi(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return L_(this.weights)}build(t){this.built=!0}getWeights(t=!1){return cE(t?this.trainableWeights:this.weights)}setWeights(t){te(()=>{const e=this.weights;if(e.length!==t.length)throw new L(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const r=[],s=cE(e);for(let i=0;i<s.length;++i){const o=s[i],a=e[i],l=t[i];if(!Ut(o.shape,l.shape))throw new L(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}uE(r)})}addWeight(t,e,r,s,i,o,a,l){if(-1!==this._addedWeightNames.indexOf(t))throw new L(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(s=null!=l?l():_n("zeros"));const c=s.apply(e,r),u=new bo(c,r,t,o,a);return c.dispose(),null!=i&&this.addLoss(()=>i.apply(u.read())),null==o&&(o=!0),o?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=ln(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,r,s,i,o,a=null){const l=ln(t);e=ln(e),r=ln(r),s=ln(s),i=$_(i),o=$_(o);const c=[],u=[],d=[];for(const h of l)c.push(h.sourceLayer),u.push(h.nodeIndex),d.push(h.tensorIndex);new V_({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:s,inputShapes:i,outputShapes:o},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function IL(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const r=t.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const s=[];for(let i=0;i<r.inboundLayers.length;i++){const c=IL(r.inputTensors[i],r.inboundLayers[i],r.nodeIndices[i]);for(const u of c)-1===s.indexOf(u)&&s.push(u)}return s}}}let B_=(()=>{class n extends Pt{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:P_("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new L("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new L("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new L("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=r,this.dtype=s,this.inputSpec=[{shape:r}];const i=new xo(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new V_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new L(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();function Ba(n){return dE.apply(this,arguments)}function dE(){return(dE=he(function*(n){if(null==n)return;const t=[],e=[],r=[];for(const s in n){const i=n[s];if("number"!=typeof i){const o=i;t.push(o.data()),e.push(s),r.push(o)}}if(t.length>0){const s=yield Promise.all(t);for(let i=0;i<s.length;++i)n[e[i]]=s[i][0];St(r)}})).apply(this,arguments)}function TL(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}ge(B_);class Mu{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return he(function*(){})()}onEpochEnd(t,e){return he(function*(){})()}onBatchBegin(t,e){return he(function*(){})()}onBatchEnd(t,e){return he(function*(){})()}onTrainBegin(t){return he(function*(){})()}onTrainEnd(t){return he(function*(){})()}setModel(t){}}class hue{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var r=this;return he(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochBegin(t,e)})()}onEpochEnd(t,e){var r=this;return he(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochEnd(t,e)})()}onBatchBegin(t,e){var r=this;return he(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchBegin(t,e)})()}onBatchEnd(t,e){var r=this;return he(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return he(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return he(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainEnd(t)})()}}class fue extends Mu{constructor(){super()}onEpochBegin(t){var e=this;return he(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var r=this;return he(function*(){null==e&&(e={});const s=null==e.size?0:e.size;r.seen+=s;for(const i in e){const o=e[i];if("number"==typeof o)r.totals.hasOwnProperty(i)||(r.totals[i]=0),r.totals[i]=r.totals[i]+o*s;else{let a;i in r.totals?a=r.totals[i]:r.totals[i]=0;const l=te(()=>we(r.totals[i],P(o,s)));r.totals[i]=l,null!=a&&a.dispose()}}})()}onEpochEnd(t,e){var r=this;return he(function*(){if(null!=e)for(const s of r.params.metrics)null!=r.totals[s]&&("number"==typeof r.totals[s]?e[s]=r.totals[s]/r.seen:te(()=>{const i=P(Ze(1,r.seen),r.totals[s]);e[s]=i,r.totals[s].dispose(),po(e[s])}))})()}}class pue extends Mu{onTrainBegin(t){var e=this;return he(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var r=this;return he(function*(){null==e&&(e={}),r.epoch.push(t);for(const s in e)null==r.history[s]&&(r.history[s]=[]),r.history[s].push(e[s])})()}syncData(){var t=this;return he(function*(){const e=[],r=[],s=[];for(const o in t.history){const a=t.history[o];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(e.push(a[l].data()),r.push(o),s.push(l))}const i=yield Promise.all(e);for(let o=0;o<i.length;++o)t.history[r[o]][s[o]].dispose(),t.history[r[o]][s[o]]=i[o][0]})()}}class mue extends Mu{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||p$,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");aC(this.yieldEvery)&&(this.maybeWait=function Fce(n,t,e){let s,r=null!=e?e():as();return(...o)=>{const a=null!=e?e():as();return a-r<t||(r=a,s=n(...o)),s}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,r){var s=this;return he(function*(){const i=[];null!=s.yield&&(yield Ba(r),i.push(s.yield(t,e,r))),i.push(s.nextFrameFunc()),yield Promise.all(i)})()}onEpochBegin(t,e){var r=this;return he(function*(){r.currentEpoch=t,null!=r.epochBegin&&(yield Ba(e),yield r.epochBegin(t,e))})()}onEpochEnd(t,e){var r=this;return he(function*(){const s=[];null!=r.epochEnd&&(yield Ba(e),s.push(r.epochEnd(t,e))),"epoch"===r.yieldEvery&&s.push(r.nextFrameFunc()),yield Promise.all(s)})()}onBatchBegin(t,e){var r=this;return he(function*(){null!=r.batchBegin&&(yield Ba(e),yield r.batchBegin(t,e))})()}onBatchEnd(t,e){var r=this;return he(function*(){const s=[];null!=r.batchEnd&&(yield Ba(e),s.push(r.batchEnd(t,e))),"batch"===r.yieldEvery?s.push(r.nextFrameFunc()):aC(r.yieldEvery)&&s.push(r.maybeWait(r.currentEpoch,t,e)),yield Promise.all(s)})()}onTrainBegin(t){var e=this;return he(function*(){null!=e.trainBegin&&(yield Ba(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return he(function*(){null!=e.trainEnd&&(yield Ba(t),yield e.trainEnd(t))})()}}function kL(n,t){return null==n&&(n={}),n instanceof Mu?[n]:Array.isArray(n)&&n[0]instanceof Mu?n:ln(n).map(r=>new mue(r,t))}let gue=(()=>{class n{constructor(){}static registerCallbackConstructor(e,r){S(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(r),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(r)}static checkForDuplicate(e){for(const r in n.constructors)n.constructors[+r].forEach(i=>{if(i===e)throw new L("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const r=[];for(const s in n.constructors){const i=+s;e>=i&&r.push(...n.constructors[i])}return r.map(s=>new s)}}return n.constructors={},n})();function NL(n,t,e,r,s,i,o,a,l){const c=new pue,u=[new fue,...gue.createCallbacks(t)];null!=n&&u.push(...n),u.push(c);const d=new hue(u);return d.setParams({epochs:e,initialEpoch:r,samples:s,steps:i,batchSize:o,verbose:t,doValidation:a,metrics:l}),{callbackList:d,history:c}}function wo(n,t={},e=!1){return Kf(n,ci.getMap().classNameMap,t,"layer",e)}function z_(n,t){return te(()=>{"float32"!==n.dtype&&(n=Ne(n,"float32"));const e=He(Qf(n),t,!0),r=f_(e.shape,tr()),s=qr(Oa(e,r));return Ze(n,s)})}function U_(n,t){return te(()=>Vn(Qf(Ue(t,n)),-1))}function hE(n,t){return te(()=>Vn(mr(Ue(t,n)),-1))}function fE(n,t){return te(()=>{const e=Ue(n,t),r=Bs(mr(n),tr(),Number.MAX_VALUE),s=mr(Ze(e,r));return P(100,Vn(s,-1))})}function ep(n,t,e=!1){return te(()=>{if(e)t=oS(t);else{const r=He(t,t.shape.length-1,!0);t=Ze(t,r)}return t=Bs(t,tr(),1-tr()),Rn(He(P(Ne(n,"float32"),pi(t)),t.shape.length-1))})}function H_(n,t,e=!1){return te(()=>{const r=Ne(p_(function Kce(n){const t=[La(n.shape)];return j(n,t)}(n)),"int32"),s=(t=Bs(t,tr(),1-tr())).shape;return ep(j(W2(r,s[s.length-1]),s),t,e)})}function j_(n,t){return te(()=>{let e;return e=Bs(t,tr(),1-tr()),e=pi(Ze(e,Ue(1,e))),Vn(function wue(n,t){if(!Ut(n.shape,t.shape))throw new L(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return te(()=>{const e=Xo(t),r=Rn(mr(t));return we(Ue(e,P(t,n)),YD(di(r)))})}(n,e),-1)})}function AL(n,t){return te(()=>{const e=z_(n,-1),r=z_(t,-1),s=P(e,r);return Rn(He(s,-1))})}const W_={meanSquaredError:U_,meanAbsoluteError:hE,meanAbsolutePercentageError:fE,meanSquaredLogarithmicError:function yue(n,t){return te(()=>{const e=Bs(t,tr(),Number.MAX_VALUE),r=pi(we(1,e)),s=Bs(n,tr(),Number.MAX_VALUE),i=pi(we(1,s));return Vn(Qf(Ue(r,i)),-1)})},squaredHinge:function _ue(n,t){return te(()=>{const e=Oa(0,Ue(1,P(n,t)));return Vn(Qf(e),-1)})},hinge:function vue(n,t){return te(()=>{const e=Oa(0,Ue(1,P(n,t)));return Vn(e,-1)})},categoricalHinge:function bue(n,t){return te(()=>{const e=He(P(n,t),-1),r=go(P(Ue(1,n),t),-1);return Oa(0,we(1,Ue(r,e)))})},logcosh:function xue(n,t){return te(()=>{const e=Math.log(2),r=Ue(t,n),s=Ue(we(r,Bf(P(-2,r))),e);return Vn(s,-1)})},categoricalCrossentropy:ep,sparseCategoricalCrossentropy:H_,binaryCrossentropy:j_,kullbackLeiblerDivergence:function Cue(n,t){return te(()=>{const e=Bs(n,tr(),1),r=Bs(t,tr(),1);return He(P(n,pi(Ze(e,r))),-1)})},poisson:function Due(n,t){return te(()=>{const e=pi(we(tr(),t));return Vn(Ue(t,P(n,e)),-1)})},cosineProximity:AL};function pE(n){if("string"==typeof n){if(n in W_)return W_[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new L(t)}return n}function RL(n,t){return te(()=>{const e=P(.5,mi(t)),r=R_(fi(t,e),n.dtype);return Vn(mo(n,r),-1)})}function ML(n,t){return te(()=>R_(mo($f(n,-1),$f(t,-1)),"float32"))}function Tue(n,t){return j_(n,t)}function kue(n,t){return n.rank===t.rank&&(n=zf(n,[n.rank-1])),(t=$f(t,-1)).dtype!==n.dtype&&(t=Ne(t,n.dtype)),Ne(mo(n,t),"float32")}const FL=ep,PL=H_,G_={binaryAccuracy:RL,categoricalAccuracy:ML,precision:function Iue(n,t){return te(()=>{const e=function OL(n,t){return te(()=>Ne(He(Ko(mo(n,1),mo(t,1))),"float32"))}(n,t),r=function Eue(n,t){return te(()=>Ne(He(Ko(mo(n,0),mo(t,1))),"float32"))}(n,t),s=we(e,r);return Ne(xs(fi(s,0),Ze(e,s),0),"float32")})},categoricalCrossentropy:FL,sparseCategoricalCrossentropy:PL,mse:U_,MSE:U_,mae:hE,MAE:hE,mape:fE,MAPE:fE,cosine:AL};function $ue(n){if("string"==typeof n&&n in G_)return G_[n];if("string"!=typeof n&&null!=n)return n;throw new L(`Unknown metric ${n}`)}function q_(n){if(Us(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(W_))if(W_[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(G_))if(G_[e]===n){t=e;break}return void 0!==t?t:n.name}}function LL(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!mE(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(n);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function mE(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!mE(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!mE(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function K_(n,t,e=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);e(r)}function Uue(n,t,e){let r,s;try{s=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch(l){s="multiple"}try{r=JSON.stringify(n.outputShape)}catch(l){r="multiple"}K_([`${n.name} (${n.getClassName()})`,s,r,n.countParams().toString()],t,e)}function Hue(n,t,e,r){let s,i;try{i=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch(d){i="multiple"}try{s=JSON.stringify(n.outputShape)}catch(d){s="multiple"}const o=[];for(const d of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(d)))for(let h=0;h<d.inboundLayers.length;++h)o.push(`${d.inboundLayers[h].name}[${d.nodeIndices[h]}][${d.tensorIndices[h]}]`);const a=n.name,l=n.getClassName(),c=0===o.length?"":o[0];K_([`${a} (${l})`,i,s,n.countParams().toString(),c],t,r);for(let d=1;d<o.length;++d)K_(["","","","",o[d]],t,r)}function VL(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function X_(n,t){if(null===n)return null;if("string"==typeof n)return jl(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];VL(t,s,i)?e.push(i):e.push(X_(i,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];if("name"===r&&"string"==typeof s)e[r]=s;else{const i=jl(r);e[i]=X_(s,i)}}return e}}function gE(n,t){if(null==n)return null;if("string"==typeof n)return Qo(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];VL(t,s,i)?e.push(i):e.push(gE(i,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];e[Qo(r)]="name"!==r&&"className"!==r||"string"!=typeof s?gE(s,r):s}return e}}class za{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof za)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,r){if(null!=this.id2Value[t.id])throw new L(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function jue(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return Ne(t,n.dtype)}catch(e){throw new L(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=r&&(this.id2Mask[t.id]=r),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof xo){if(null==this.id2Value[t.id])throw new L(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new L(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof xo){if(null==this.id2Value[t.id])throw new L(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new L(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&St(this.id2Mask)}}const _E={},BL={};function tp(n,t,e,r){const s=null!=e&&e.training,i=Array.isArray(n),o=i?n:[n],a=o.map(p=>p.name),l=[],c=t.names();for(const p of a)-1!==c.indexOf(p)?l.push(t.getValue(p)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=a.join(",")+"|"+t.names().join(",");let d,h;if(null==_E[u]){const p=function Wue(n,t){S(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===n.length){const s=zL(n[0],t);e=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of n){const{sorted:o,recipientMap:a}=zL(i,t);for(const l of o)s.has(l.name)||(e.push(l),s.add(l.name));for(const l in a)null==r[l]&&(r[l]=new Set),a[l].forEach(c=>r[l].add(c))}}return{sorted:e,recipientCounts:Gue(r)}}(o,t);d=p.sorted,h=p.recipientCounts,_E[u]=d,BL[u]=h}d=_E[u],h={},s||Object.assign(h,BL[u]);const f=new za(t);for(let p=0;p<d.length;++p){if(null!=r){const M=UD().numTensors;M>r.maxNumTensors&&(r.maxNumTensors=M),M<r.minNumTensors&&(r.minNumTensors=M)}const m=d[p],g=m.sourceLayer;if(g instanceof B_)continue;const _=[],y=[],v=[];let b=!1;for(const M of m.inputs){const O=f.getValue(M),K=f.getMask(M);_.push(O),y.push(K),null!=K&&(b=!0),s||(h[M.name]--,0===h[M.name]&&!t.hasKey(M)&&-1===a.indexOf(M.name)&&!O.isDisposed&&!0!==M.sourceLayer.stateful&&v.push(O))}b&&((e=e||{}).mask=y[0]);const w=ln(g.apply(_,e));let C=null;g.supportsMasking&&(C=g.computeMask(_,y));const E=que(m),k=Array.isArray(E)?E:[E];for(let M=0;M<k.length;++M){f.hasKey(k[M])||f.add(k[M],w[M],Array.isArray(C)?C[0]:C);const O=a.indexOf(k[M].name);-1!==O&&(l[O]=w[M])}s||St(v)}return f.disposeMasks(),i?l:l[0]}function Gue(n){const t={};for(const e in n)t[e]=n[e].size;return t}function zL(n,t){const e=new Set,r=[],s={};for(const a of t.names())e.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(e.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(0===a.inputs.length||l)i.pop(),r.push(a),e.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)null==s[c.name]&&(s[c.name]=new Set),s[c.name].add(a.name),!e.has(c.name)&&i.push(c)}}return{sorted:r,recipientMap:s}}function que(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){e=r;break}t=n.sourceLayer.getOutputAt(e)}return t}class Hi extends Pt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const y=this.getClassName().toLowerCase();this.name=P_(y)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],$a(this.inputs).length!==this.inputs.length)throw new L(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(y=>y.name)}`);$a(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(y=>y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const b=y.nodeIndex,w=y.tensorIndex;this.outputLayers.push(y.sourceLayer),this.outputLayersNodeIndices.push(b),this.outputLayersTensorIndices.push(w)}for(const y of this.inputs){const v=y.sourceLayer,b=y.nodeIndex,w=y.tensorIndex;Us(0===b,"input layer has >1 nodes"),Us(0===w,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(b),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const v=this.inputLayers[y];if(!(v instanceof B_))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(y=>y.shape),this.internalOutputShapes=this.outputs.map(y=>y.shape);const e={},r={},s={},i={},o={},a=[],l=(y,v,b,w,C,E)=>{(null==w||null==C||null==E)&&(w=y.sourceLayer,C=y.nodeIndex,E=y.tensorIndex);const k=w.inboundNodes[C];if(-1!==b.indexOf(k))throw new gi(`The tensor ${y.name} at layer "${w.name}" is part of a cycle.`);if(-1!==v.indexOf(k))return;this.containerNodes.add(Hi.nodeKey(w,C)),w.id in o||(o[w.id]=Object.keys(o).length),-1===b.indexOf(k)&&b.push(k);const M=k.inboundLayers.length;for(let O=0;O<M;O++)l(k.inputTensors[O],v,b,k.inboundLayers[O],k.nodeIndices[O],k.tensorIndices[O]);for(v.push(k);b.indexOf(k)>=0;)b.splice(b.indexOf(k),1);a.push(k)},c=[],u=[];for(const y of this.outputs)l(y,c,u);const d=a.slice().reverse();for(const y of d){r[y.id]=y,y.id in e||(e[y.id]=0);let v=e[y.id];v=Math.max(v,null==s[y.outboundLayer.id]?0:s[y.outboundLayer.id]),s[y.outboundLayer.id]=v,i[y.outboundLayer.id]=y.outboundLayer,e[y.id]=v;for(let w=0;w<y.inboundLayers.length;w++){const k=y.inboundLayers[w].inboundNodes[y.nodeIndices[w]];e[k.id]=Math.max(v+1,null==e[k.id]?0:e[k.id]),r[k.id]=k}}const h={};for(const y in e){const v=e[y];v in h||(h[v]=[]),h[v].push(r[y])}const f={};for(const y in s){const v=s[y];v in f||(f[v]=[]),f[v].push(i[y])}let p=Object.keys(f).map(y=>parseInt(y,10)).sort(A_);this.layers=[];for(const y of p){const v=f[y];v.sort((b,w)=>{const C=o[b.id],E=o[w.id];return C<E?-1:C>E?1:0});for(const b of v)b instanceof Hi&&this.internalContainerRefs.push(b),this.layers.push(b)}this.layersByDepth=f,p=Object.keys(h).map(y=>parseInt(y,10)).sort(A_);const m=this.inputs.slice(),g=[];for(const y of p)for(const v of h[y]){const b=v.outboundLayer;if(null!=b){for(const w of v.inputTensors)if(-1===m.indexOf(w))throw new gi(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${b.name}". The following previous layers were accessed without issue: ${g}`);for(const w of v.outputTensors)m.push(w);g.push(b.name)}}this.nodesByDepth=h;const _=this.layers.map(y=>y.name);for(const y of _){const v=_.filter(b=>b===y).length;if(1!==v)throw new gi(`The name "${y}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(_))}this.outboundNodes=[],this.inboundNodes=[],new V_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(y=>null),outputMasks:this.outputs.map(y=>null),inputShapes:this.inputs.map(y=>y.shape),outputShapes:this.outputs.map(y=>y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new L("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const r={};let s=0;for(const o of this.layers)for(const a of o.weights){if(null!=r[a.originalName])throw new L(`Duplicate weight name: ${a.originalName}`);r[a.originalName]=a,s++}const i=[];for(const o in t){let a=o;if(null==r[o]){const l=o.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(null!=r[a])i.push([r[a],t[o]]);else if(e)throw new L(`Provided weight data has no target variable: ${o}`);delete r[a]}if(e){const o=[];for(const a in r)o.push(a);if(o.length>0)throw new L(`${o.length} of ${s} weights are not set: ${o}`)}uE(i)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 3.15.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const r=gE(this.updatedConfig());return e?JSON.stringify(r):r}call(t,e){return te(()=>{t=ln(t);const r=new za;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return tp(this.outputs,r,e)})}computeMask(t,e){return te(()=>{let r;return t=ln(t),r=null==e?Hl(null,t.length):ln(e),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const e=$_(t);if(e.length!==this.inputLayers.length)throw new L(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(A_);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const c of l){const u=c.outboundLayer;if(-1!==this.inputLayers.map(m=>m.id).indexOf(u.id))continue;const d=[];for(let m=0;m<c.inboundLayers.length;m++)d.push(r[`${c.inboundLayers[m].name}_${c.nodeIndices[m]}_${c.tensorIndices[m]}`]);const f=$_(u.computeOutputShape(ls(d))),p=u.inboundNodes.indexOf(c);for(let m=0;m<f.length;m++)r[`${u.name}_${p}_${m}`]=f[m]}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++)o.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<o.length;a++){const l=o[a];Us(l in r),i.push(r[l])}return ls(i)}runInternalGraph(t,e){null==e&&(e=Hl(null,t.length));const r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[t[l],e[l]];const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(A_);for(const l of s){const c=this.nodesByDepth[l];for(const u of c){const d=u.outboundLayer,h=u.inputTensors,f=u.outputTensors,p=new Array;for(const m of h)m.id in r&&p.push(r[m.id]);if(p.length===h.length){let g,_,y,v,m={};if(null!=u.callArgs&&(m=u.callArgs),1===p.length){const[b,w]=p[0];null==m.mask&&(m.mask=w),y=ln(d.call(b,m)),v=ln(d.computeMask(b,w)),g=[b],_=[w]}else g=p.map(b=>b[0]),_=p.map(b=>b[1]),null==m.mask&&(m.mask=_),y=ln(d.call(g,m)),v=ln(d.computeMask(g,_));if(d.activityRegularizer)throw new ft("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let b=0;b<f.length;++b)r[f[b].id]=[y[b],v[b]]}}}const i=[],o=[],a=[];for(const l of this.outputs){Us(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=r[l.id];a.push(c.shape),i.push(c),o.push(u)}return[i,o,a]}buildNodeConversionMap(t){const e={};let r;for(const s of this.layers){r=s instanceof Hi?1:0;for(let i=0;i<s.inboundNodes.length;i++){const o=Hi.nodeKey(s,i);this.containerNodes.has(o)&&(e[o]=r,r+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new L(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new L("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===t)return r;throw new L(`No such layer: ${t}`)}calculateLosses(){return te(()=>{const t=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const s=Hi.nodeKey(e,r);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let d=0;d<o.inboundNodes.length;d++){const h=o.inboundNodes[d],f=Hi.nodeKey(o,d);let p={};if(this.containerNodes.has(f)){if(h.callArgs)try{JSON.stringify(h.callArgs),p=h.callArgs}catch(m){console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const _=h.inboundLayers[g],v=h.tensorIndices[g];let w=e[Hi.nodeKey(_,h.nodeIndices[g])];null==w&&(w=0),m.push([_.name,w,v,p])}c.push(m)}}}const u={};u.name=o.name,u.className=a,u.config=l,u.inboundNodes=c,r.push(u)}t.layers=r;const s=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],c=Hi.nodeKey(a,this.inputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let u=e[c];null==u&&(u=0),s.push([a.name,u,this.inputLayersTensorIndices[o]])}t.inputLayers=s;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],c=Hi.nodeKey(a,this.outputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let u=e[c];null==u&&(u=0),i.push([a.name,u,this.outputLayersTensorIndices[o]])}return t.outputLayers=i,t}static fromConfig(t,e,r={},s=!1){const i={},o={};function a(g,_){g.name in o?o[g.name].push(_):o[g.name]=[_]}function l(g,_){const y=[];let v;for(const b of _){const w=b[0],C=b[1],E=b[2];if(v=null==b[3]?{}:b[3],!(w in i))return void a(g,_);const k=i[w];if(k.inboundNodes.length<=C)return void a(g,_);y.push(k.inboundNodes[C].outputTensors[E])}y.length>0&&g.apply(ls(y),v)}function c(g){const _=g.name,y=wo(g,null!=e.customObjects?e.customObjects:{});y.setFastWeightInitDuringBuild(s),i[_]=y,g.inboundNodes.forEach(b=>{if(!(b instanceof Array))throw new L(`Corrupted configuration, expected array for nodeData: ${b}`);a(y,b)})}const u=e.name,d=e.layers;for(const g of d)c(g);for(;!Oce(o);)for(const g of d){const _=i[g.name];if(_.name in o){const y=o[_.name];delete o[_.name];for(const v of y)l(_,v)}}const h=[],f=[],p=e.inputLayers;for(const g of p){const _=g[0],y=g[1],v=g[2];Us(_ in i),h.push(i[_].inboundNodes[y].outputTensors[v])}const m=e.outputLayers;for(const g of m){const _=g[0],y=g[1],v=g[2];Us(_ in i),f.push(i[_].inboundNodes[y].outputTensors[v])}return new t({inputs:h,outputs:f,name:u})}get stateful(){if(this._stateful)throw new L("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){te(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function HL(n,t){return function UL(n,t,e){const r=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(s=>null);if(1===r)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const s=[];return t.forEach(i=>{s.push(i in n?n[i]:null)}),s}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function jL(n,t,e,r){return vE.apply(this,arguments)}function vE(){return(vE=he(function*(n,t,e,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const s=te(()=>{if(1===n.shape.length)return Fl(n);if(2===n.shape.length){if(n.shape[1]>1)return $f(n,1);if(1===n.shape[1])return j(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(yield s.data());St(s);const o=[];return i.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(e[a])}),bs(o,"float32")}return null})).apply(this,arguments)}function Kue(n,t){return P(n,t)}function WL(n,t){let e,r;e=t.xs,r=t.ys,S(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=GL("input",n.inputNames,e),o=GL("output",n.outputNames,r),a=i[0].shape[0];S(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),S(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)S(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)S(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function GL(n,t,e){if(e instanceof Ln)return[e];if(Array.isArray(e))return S(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const r=[];for(const s of t){if(null==e[s])throw new L(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(e[s])}return r}}function Yue(n){if(3===n.length)throw new ft("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}function bE(){return(bE=he(function*(n,t,e){const r=null!=e.batchesPerEpoch;if(S(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),S(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),S(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),S(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),S(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const s=null!=e.validationData;let i,o;if(s)if(qL(e.validationData))S(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const g=Yue(e.validationData);i=g.xs,o=g.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;c=s?l.slice().concat(l.map(g=>"val_"+g)):l.slice();const u=kL(e.callbacks,e.yieldEvery),d=null==e.verbose?1:e.verbose,{callbackList:h,history:f}=NL(u,d,e.epochs,null,null,Que(t,e),null,s,c);h.setModel(n),n.history=f,yield h.onTrainBegin(),n.stopTraining_=!1;let p=null==e.initialEpoch?0:e.initialEpoch,m=yield t.iterator();for(;p<e.epochs;){const g={};yield h.onEpochBegin(p);let _=0,y=0;for(r||(m=yield t.iterator());!r||_<e.batchesPerEpoch;){const v=yield m.next();if(r&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${_} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=v.value){const{xs:b,ys:w}=WL(n,v.value),C={};C.batch=y,C.size=b[0].shape[0],yield h.onBatchBegin(y,C);const E=[];if(null!=e.classWeight){const O=HL(e.classWeight,n.outputNames);for(let K=0;K<O.length;++K)E.push(yield jL(w[K],null,O[K]))}const k=b.concat(w).concat(E),M=a(k);St(k);for(let O=0;O<l.length;++O){const X=M[O];C[l[O]]=X,po(X)}yield h.onBatchEnd(y,C),TL(C),y++,_++}if(r?_>=e.batchesPerEpoch:v.done){if(s){let b;b=qL(e.validationData)?ln(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):ln(n.evaluate(i,o,{batchSize:null==e.validationBatchSize?32:e.validationBatchSize,verbose:0}));for(let w=0;w<n.metricsNames.length;++w)g[`val_${n.metricsNames[w]}`]=b[w]}break}if(n.stopTraining_)break}if(yield h.onEpochEnd(p,g),p++,n.stopTraining_)break}return yield h.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})).apply(this,arguments)}function Que(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function qL(n){return"function"==typeof n.iterator}function Jue(n){return"function"==typeof n.next}function xE(){return(xE=he(function*(n,t,e){const r=null!=(e=e||{}).batches,s=n.testFunction;let i=[];if(e.verbose>0)throw new ft("Verbose mode is not implemented yet.");S(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=Jue(t)?t:yield t.iterator();let a=0,l=0;for(;!r||l<e.batches;){const c=yield o.next();if(i=te(()=>{if(c.value){const{xs:u,ys:d}=WL(n,c.value),h=u.concat(d),f=te(()=>s(h));if(St(h),0===l)for(let m=0;m<f.length;++m)i.push(lt(0));const p=h[0].shape[0];for(let m=0;m<f.length;++m){const g=f[m],_=i[m];i[m]=te(()=>we(i[m],P(p,g))),l>0&&St(_)}St(f),a+=p,++l}return i}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const u=i[c];i[c]=Ze(i[c],a),St(u)}return ls(i)})).apply(this,arguments)}function wE(n){S(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function np(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(r=>ql(r,t,e-t)):ql(n,t,e-t)}function CE(n,t){return te(()=>null==n?null:Array.isArray(n)?n.map(e=>CE(e,t)):pL(n,"int32"===t.dtype?t:Ne(t,"int32")))}function DE(n,t){const e=[];let r=0,s=null;for(;r<n;)s=r+t,s>=n&&(s=n),e.push([r,s]),r=s;return e}function tde(n,t,e,r,s,i,o,a,l,c,u,d,h,f,p){return SE.apply(this,arguments)}function SE(){return(SE=he(function*(n,t,e,r,s,i,o,a,l,c,u,d,h,f,p){null==s&&(s=32),null==i&&(i=1),null==u&&(u=!0),null==h&&(h=0);let m=!1;if(null!=l&&null!=c&&(m=!0),null!=p&&(m=!0,null==f))throw new L("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=n.checkNumSamples(e,s,f,"steps_per_epoch");let _;null!=g&&(_=zi(0,g)),null==o&&(o=1);const{callbackList:y,history:v}=NL(a,o,i,h,g,f,s,m,d);y.setModel(n),n.history=v,yield y.onTrainBegin(),n.stopTraining_=!1;for(let b=h;b<i;++b){yield y.onEpochBegin(b);const w={};if(null!=f)throw new ft("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new ft("batch shuffling is not implemneted yet");u&&bP(_);const C=bs(_),E=DE(g,s);for(let k=0;k<E.length;++k){const M={};if(yield y.onBatchBegin(k,M),te(()=>{const O=E[k][0],K=E[k][1],X=ql(C,O,K-O);M.batch=k,M.size=K-O;const Q=CE(e,X),re=t(Q);for(let ne=0;ne<r.length;++ne){const G=re[ne];M[r[ne]]=G,po(G)}if(k===E.length-1&&m){const ne=n.testLoop(l,c,s);for(let V=0;V<r.length;++V){const G=r[V],W=ne[V];po(W),w["val_"+G]=W}}}),yield y.onBatchEnd(k,M),TL(M),n.stopTraining_)break}C.dispose()}if(yield y.onEpochEnd(b,w),n.stopTraining_)break}return yield y.onTrainEnd(),yield n.history.syncData(),n.history})).apply(this,arguments)}function EE(){return(EE=he(function*(n,t,e,r={}){if(n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let s,i,o,a,l,c,u,d,h;n.isTraining=!0;try{const f=null==r.batchSize?32:r.batchSize;wE(f);const p=!1,m=yield n.standardizeUserData(t,e,r.sampleWeight,r.classWeight,p,f);s=m[0],i=m[1],h=m[2];let _,g=!1;if(null!=r.validationData&&r.validationData.length>0){if(g=!0,2!==r.validationData.length)throw 3===r.validationData.length?new ft("validationData including sample weights is not supported yet."):new L(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);l=r.validationData[0],c=r.validationData[1];const M=!0,O=yield n.standardizeUserData(l,c,null,null,M,f);u=O[0],d=O[1],_=u.concat(d)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){g=!0;const M=Math.floor(s[0].shape[0]*(1-r.validationSplit)),O=s[0].shape[0];u=np(s,M,O),o=s,s=np(s,0,M),d=np(i,M,O),a=i,i=np(i,0,M),_=u.concat(d)}else null!=r.validationSteps&&(g=!0);const y=s.concat(i).concat(h);n.checkTrainableWeightsConsistency();const v=n.makeTrainFunction(),b=n.getDedupedMetricsNames();let w,C;g?(n.makeTestFunction(),w=n.testFunction,C=b.slice().concat(b.map(M=>"val_"+M))):(w=null,_=[],C=b.slice());const E=kL(r.callbacks,r.yieldEvery);return yield tde(n,v,y,b,f,r.epochs,r.verbose,E,w,_,r.shuffle,C,r.initialEpoch,null,null)}finally{n.isTraining=!1,ji(s,t),ji(i,e),ji(o,t),ji(a,e),ji(u,l),ji(d,c),null!=h&&St(h)}})).apply(this,arguments)}function KL(n){const t=[];n instanceof Ln&&(n=[n]);for(let e=0;e<n.length;++e){const r=n[e];if(1===r.rank)t.push(Zf(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function ji(n,t){if(null==n)return;const e=[];if(t instanceof Ln)e.push(t.id);else if(Array.isArray(t))t.forEach(s=>e.push(s.id));else if(null!=t)for(const s in t)e.push(t[s].id);const r=[];if(n instanceof Ln)-1===e.indexOf(n.id)&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{-1===e.indexOf(s.id)&&r.push(s)});else if(null!=n)for(const s in n){const i=n[s];-1===e.indexOf(i.id)&&r.push(i)}r.forEach(s=>{s.isDisposed||s.dispose()})}function IE(n){return Array.isArray(n)}function XL(n){return!function rde(n){return n instanceof Ln}(n)&&!IE(n)}function YL(n,t,e,r=!0,s=""){if(null==t||0===t.length){if(null!=n){let o=!1;if(IE(n)&&n.length>0)o=!0;else if(XL(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new L(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(o=>null);let i;if(XL(n)){n=n,i=[];for(const o of t){if(null==n[o])throw new L(`No data provided for "${o}". Need data for each key in: ${t}`);i.push(n[o])}}else if(IE(n)){if((n=n).length!==t.length)throw new L(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,t.length>1)throw new L(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=KL(i),null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=i[o];if(a.shape.length!==e[o].length)throw new L(`Error when checking ${s}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[o].length;++l){if(0===l&&!r)continue;const c=a.shape[l],u=e[o][l];if(null!=u&&u>=0&&c!==u)throw new L(`${s} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function ZL(n,t,e,r=!0,s=""){let i;if(Array.isArray(n)){if(n.length!==t.length)throw new L(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(t.length>1)throw new L(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=i[o];if(a.shape.length!==e[o].length)throw new L(`Error when checking ${s}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[o].length;++l){if(0===l&&!r)continue;const c=a.shape[l],u=e[o][l];if(null!=u&&u!==c)throw new L(`Error when checking ${s}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let Ou=(()=>{class n extends Hi{constructor(e){super(e),this.isTraining=!1}summary(e,r,s=console.log){if(!this.built)throw new L("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function Vue(n,t,e,r=console.log){const s=function zue(n){let t=!0;const e=[],r=[];for(const s in n.nodesByDepth)e.push(n.nodesByDepth[s]);for(const s of e){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of n.layers){let i=!1;for(const o of s.inboundNodes)if(-1!==r.indexOf(o)){if(i){t=!1;break}i=!0}if(!t)break}return t}(n),i=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(s?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(u=>Math.floor(t*u))),!s){i.push("Receives inputs"),o=[];for(const u in n.nodesByDepth)o.push(...n.nodesByDepth[u])}r("_".repeat(t)),K_(i,e,r),r("=".repeat(t));const a=n.layers;for(let u=0;u<a.length;++u)s?Uue(a[u],e,r):Hue(a[u],e,o,r),r((u===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=function Bue(n){let t;return t=L_(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),c=L_(n.nonTrainableWeights);r(`Total params: ${l+c}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${c}`),r("_".repeat(t))}(this,e,r,s)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function Lue(n){const t={Adagrad:()=>Nu.adagrad(.01),Adadelta:()=>Nu.adadelta(1,.95,tr()),Adam:()=>Nu.adam(.001,.9,.999,tr()),Adamax:()=>Nu.adamax(.002,.9,.999,tr(),0),RMSProp:()=>Nu.rmsprop(.001,.9,0,tr()),SGD:()=>Nu.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new L(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Aa))throw new L("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new L(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>pE(l))}else{const a=pE(e.loss);this.outputs.forEach(l=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new L(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(pE(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Gl("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(-1!==s.indexOf(a))continue;const l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const i=function ode(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(r=>e);{const r=[];for(const s of t){let i=e.hasOwnProperty(s)?e[s]:[];Array.isArray(i)||(i=[i]),r.push(i)}return r}}(e.metrics,this.outputNames),o=(a,l,c)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([c,a])};Gl("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&(u=>{let h,f,p;for(const m of u){if("string"==typeof m&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(m)){const _=this.internalOutputShapes[a];let y;1===_[_.length-1]||this.lossFunctions[a]===j_?-1!==["accuracy","acc"].indexOf(m)?f=RL:-1!==["crossentropy","ce"].indexOf(m)&&(f=Tue):this.lossFunctions[a]===H_?-1!==["accuracy","acc"].indexOf(m)?f=kue:-1!==["crossentropy","ce"].indexOf(m)&&(f=PL):-1!==["accuracy","acc"].indexOf(m)?f=ML:-1!==["crossentropy","ce"].indexOf(m)&&(f=FL),-1!==["accuracy","acc"].indexOf(m)?y="acc":-1!==["crossentropy","ce"].indexOf(m)&&(y="ce"),p=f,h=""+y}else p=$ue(m),h=""+q_(m);let g;Gl(h,()=>{g=p}),o(a,h,g)}})(i[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,s={}){const i=null==s.batchSize?32:s.batchSize;wE(i);const a=this.standardizeUserDataXY(e,r,!0,i);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),ls(this.testLoop(this.testFunction,l,i,s.verbose,s.steps))}finally{ji(a[0],e),ji(a[1],r)}}evaluateDataset(e,r){var s=this;return he(function*(){return s.makeTestFunction(),function ede(n,t,e){return xE.apply(this,arguments)}(s,e,r)})()}checkNumSamples(e,r,s,i="steps"){let o;if(null!=s){if(o=null,null!=r)throw new L(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new L(`Either the input data should have a defined shape, or ${i} shoud be specified.`);o=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return o}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new L("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(r),o=this.retrieveSymbolicTensors(s?r:[r]),a=new za;if(e instanceof Ln&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new L(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)a.add(this.inputs[c],e[c])}else for(const c of this.inputs){const u=e[c.name];if(null==u)throw new L(`No value is provided for the model's input ${c.name}`);a.add(c,u)}const l=tp(o,a);return s?l:l[0]}retrieveSymbolicTensors(e){const r=Hl(null,e.length);let s=e.length;for(const i of this.layers){const o=Array.isArray(i.output)?i.output:[i.output],a=o.map(l=>l.name);for(let l=0;l<e.length;++l){const c=a.indexOf(e[l]);if(-1!==c&&(r[l]=o[c],s--),0===s)break}if(0===s)break}if(s>0){const i=[];throw r.forEach((o,a)=>{null==o&&i.push(e[a])}),new L(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return r}predictLoop(e,r=32,s=!1){return te(()=>{const i=this.checkNumSamples(e);if(s)throw new ft("Verbose predictLoop() is not implemented yet.");const o=DE(i,r),a=this.outputs.map(l=>[]);for(let l=0;l<o.length;++l)te(()=>{const h=np(e,o[l][0],o[l][1]),f=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)f.push({key:this.inputs[m],value:h[m]});else f.push({key:this.inputs[0],value:h});const p=new za(f);return tp(this.outputs,p)}).forEach((u,d)=>a[d].push(u));return ls(a.map(l=>Lr(l,0)))})}predict(e,r={}){const s=KL(e);ZL(s,this.inputNames,this.feedInputShapes,!1);try{const i=null==r.batchSize?32:r.batchSize;return wE(i),this.predictLoop(s,i)}finally{ji(s,e)}}predictOnBatch(e){ZL(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,s=!0,i){if(null==this.optimizer_)throw new gi("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];o.push(this.feedLossFns[a]===H_?l.slice(0,l.length-1).concat([1]):l)}if(function sde(n,t,e){const r=$a(n.map(i=>i.shape[0]));r.sort();const s=$a(t.map(i=>i.shape[0]));if(s.sort(),r.length>1)throw new L(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(s.length>1)throw new L(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(r.length>0&&s.length>0&&!Ut(r,s))throw new L(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=YL(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=YL(r,this.feedOutputNames,o,!1,"target")),function ide(n,t,e){const r=[U_,j_,ep];for(let s=0;s<n.length;++s){const i=n[s],o=t[s],a=e[s];if(null!=o){if(o===ep&&1===i.shape[i.shape.length-1])throw new L(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(o)){const l=i.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){const d=l[u],h=c[u];if(null!=h&&d!==h)throw new L(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=i&&i>0&&e[0].shape[0]%i!=0)throw new L(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,s,i,o=!0,a){var l=this;return he(function*(){const[c,u]=l.standardizeUserDataXY(e,r,o,a);if(null!=s)throw new Error("sample weight is not supported yet.");let d=null;if(null!=i){const h=HL(i,l.outputNames);d=[];for(let f=0;f<h.length;++f)d.push(yield jL(u[f],null,h[f]))}return[c,u,d]})()}testLoop(e,r,s,i=0,o){return te(()=>{const a=this.checkNumSamples(r,s,o,"steps"),l=[];if(i>0)throw new ft("Verbose mode is not implemented yet.");if(null!=o)throw new ft("steps mode in testLoop() is not implemented yet");{const c=DE(a,s),u=bs(zi(0,a));for(let d=0;d<c.length;++d){const h=c[d][0],f=c[d][1],p=ql(u,h,f-h),m=CE(r,p),g=e(m);if(0===d)for(let _=0;_<g.length;++_)l.push(lt(0));for(let _=0;_<g.length;++_)l[_]=we(l[_],P(f-h,g[_]))}for(let d=0;d<l.length;++d)l[d]=Ze(l[d],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let s=0;s<e.length;++s){const i=e[s];let o=i;nL(e,i)>1&&(o+=`_${nL(e.slice(0,s),i)}`),r.push(o)}return r}makeTrainFunction(){return e=>{const r=[],s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],c=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const f=new za(h),p=tp(this.outputs,f,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){let y=this.lossFunctions[g](i[g],p[g]);null!=o[g]&&(y=Kue(y,o[g]));const v=Vn(y);r.push(v),m=0===g?y:we(m,y)}for(let g=0;g<this.metricsTensors.length;++g){let _;if(this.outputs.length>1&&g<this.outputs.length)_=r[g];else{const v=this.metricsTensors[g][1];_=Vn((0,this.metricsTensors[g][0])(i[v],p[v]))}po(_),a.push(_)}return m=Vn(m),this.calculateLosses().forEach(g=>{m=we(m,g)}),m},!0,c)].concat(a)}}makeTestFunction(){this.testFunction=e=>te(()=>{const r=[];let s;const i=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:i[u]});const l=new za(a),c=tp(this.outputs,l);for(let u=0;u<this.lossFunctions.length;++u){const h=Vn((0,this.lossFunctions[u])(o[u],c[u]));s=0===u?h:we(s,h),r.push(s)}for(let u=0;u<this.metricsTensors.length;++u){const h=this.metricsTensors[u][1],f=Vn((0,this.metricsTensors[u][0])(o[h],c[h]));r.push(f)}return r})}fit(e,r,s={}){var i=this;return he(function*(){return function nde(n,t,e){return EE.apply(this,arguments)}(i,e,r,s)})()}fitDataset(e,r){var s=this;return he(function*(){return function Zue(n,t,e){return bE.apply(this,arguments)}(s,e,r)})()}trainOnBatch(e,r){var s=this;return he(function*(){const i=yield s.standardizeUserData(e,r),o=i[0],a=i[1],c=s.makeTrainFunction()(o.concat(a)),u=[];for(const d of c){const h=yield d.data();u.push(h[0])}return St(c),ji(i[0],e),ji(i[1],r),ls(u)})()}getNamedWeights(e){const r=[],s=null!=e&&e.trainableOnly,i=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let a=0;a<i.length;++a)s&&!i[a].trainable||r.push({name:i[a].originalName,tensor:o[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=UD().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-UD().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Qo(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>Qo(r))}else{const r=Object.keys(this.loss);e={};const s=this.loss;for(const i of r){if("string"!=typeof s[i])throw new Error("Serialization of non-string loss is not supported.");e[i]=Qo(s[i])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Qo(q_(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Qo(q_(e)));{const e={};for(const r in this.metrics)e[r]=Qo(q_(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const s=wo(X_(e.optimizer_config));let i,o;if("string"==typeof e.loss)i=jl(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(a=>jl(a));else if(null!=e.loss){i={};for(const a in e.loss)i[a]=jl(e.loss[a])}if(Array.isArray(e.metrics))o=e.metrics.map(a=>jl(a));else if(null!=e.metrics){o={};for(const a in e.metrics)o[a]=jl(e.metrics[a])}this.compile({loss:i,metrics:o,optimizer:s})}save(e,r){var s=this;return he(function*(){if("string"==typeof e){const d=(n=>Dn.getSaveHandlers(n))(e);if(0===d.length)throw new L(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new L(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(null==e.save)throw new L("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const i=yield o2(s.getNamedWeights(r)),c={modelTopology:s.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.15.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=s.optimizer){c.trainingConfig=s.getTrainingConfig();const d="optimizer",{data:h,specs:f}=yield o2(yield s.optimizer.getWeights(),d);i.specs.push(...f),i.data=vD([i.data,h])}return null!=s.userDefinedMetadata&&(LL(s.userDefinedMetadata,s.name,!0),c.userDefinedMetadata=s.userDefinedMetadata),c.weightData=i.data,c.weightSpecs=i.specs,e.save(c)})()}setUserDefinedMetadata(e){LL(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();function kE(){return(kE=he(function*(n,t){if(null==t&&(t={}),"string"==typeof n){const e=gte(n,t);if(0===e.length)e.push(Hte(n,t));else if(e.length>1)throw new L(`Found more than one (${e.length}) load handlers for URL '${n}'`);n=e[0]}return cde(n,void 0,t)})).apply(this,arguments)}function cde(n,t,e){return NE.apply(this,arguments)}function NE(){return(NE=he(function*(n,t,e){if(null==e&&(e={}),null==n.load)throw new L("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=yield n.load();let s=r.modelTopology;null!=s.model_config&&(s=s.model_config);const i=null==e.strict||e.strict,o=null!=r.weightData&&null!=r.weightSpecs&&i,a=wo(X_(s),t,o),l=r.trainingConfig;if(null!=l&&a.loadTrainingConfig(l),null!=r.userDefinedMetadata&&a.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new L("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:c,optimizerWeights:u}=ude(r.weightData,r.weightSpecs);a.loadWeights(c,i),null!=a.optimizer&&u.length>0&&(yield a.optimizer.setWeights(u)),St(c),St(u.map(d=>d.tensor))}return a})).apply(this,arguments)}function ude(n,t){const e=function a2(n,t){const e={};let r,s=0;for(const i of t){const o=i.name,a=i.dtype,l=i.shape,c=ce(l);let u;if("quantization"in i){const d=i.quantization;if("uint8"===d.dtype||"uint16"===d.dtype){if(!("min"in d)||!("scale"in d))throw new Error(`Weight ${i.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==d.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${i.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`)}const h=gD[d.dtype],f=n.slice(s,s+c*h),p="uint8"===d.dtype?new Uint8Array(f):new Uint16Array(f);if("float32"===a)if("uint8"===d.dtype||"uint16"===d.dtype){u=new Float32Array(p.length);for(let m=0;m<p.length;m++)u[m]=p[m]*d.scale+d.min}else{if("float16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);void 0===r&&(r=pte()),u=r(p)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);if("uint8"!==d.dtype&&"uint16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);u=new Int32Array(p.length);for(let m=0;m<p.length;m++)u[m]=Math.round(p[m]*d.scale+d.min)}s+=c*h}else if("string"===a){const d=ce(i.shape);u=[];for(let h=0;h<d;h++){const f=new Uint32Array(n.slice(s,s+4))[0];s+=4;const p=new Uint8Array(n.slice(s,s+f));u.push(p),s+=f}}else{const d=gD[a],h=n.slice(s,s+c*d);if("float32"===a)u=new Float32Array(h);else if("int32"===a)u=new Int32Array(h);else if("bool"===a)u=new Uint8Array(h);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);{u=new Float32Array(h);const f=new Float32Array(u.length/2),p=new Float32Array(u.length/2);for(let _=0;_<f.length;_++)f[_]=u[2*_],p[_]=u[2*_+1];const m=n_(f,l,"float32"),g=n_(p,l,"float32");e[o]=gu(m,g),m.dispose(),g.dispose()}}s+=c*d}"complex64"!==a&&(e[o]=n_(u,l,a))}return e}(n,t),r={},s=[];return t.forEach(i=>{"optimizer"===i.group?s.push({name:i.name,tensor:e[i.name]}):r[i.name]=e[i.name]}),{modelWeights:r,optimizerWeights:s}}ge(Ou),ge((()=>{class n extends Ou{}return n.className="Functional",n})()),ge((()=>{class n extends Ou{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:P_("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new L(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof n||e instanceof Ou;let s;if(r){if(s=e,1!==s.outputs.length)throw new L("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new L("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new L("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=function uue(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new L("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new B_({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(r)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==e.inboundNodes.length)throw new L(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new L("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=IL(this.outputs[0])}this.inboundNodes=[],new V_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Hl(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(Gt(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ou({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,s=console.log){this.built||this.build(),super.summary(e,r,s)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,s={}){if(!this.built)throw new gi("The model needs to be compiled before being used.");return this.model.evaluate(e,r,s)}evaluateDataset(e,r){var s=this;return he(function*(){if(!s.built)throw new gi("The model needs to be compiled before being used.");return s.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,s={}){var i=this;return he(function*(){if(!i.built)throw new gi("The model needs to be compiled before being used.");return i.model.fit(e,r,s)})()}fitDataset(e,r){var s=this;return he(function*(){if(!s.built)throw new gi("The model needs to be compiled before being used.");return s.model.fitDataset(e,r)})()}trainOnBatch(e,r){var s=this;return he(function*(){return s.model.trainOnBatch(e,r)})()}static fromConfig(e,r,s={},i=!1){let o,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new L("Legacy serialization format not supported yet.");o=r}else S(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=r.layers,delete r.layers,a=r;const l=new e(a);if(!(l instanceof n))throw new ft(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const c of o){const d=wo(c,void 0,i);i&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(null==this.model)throw new L("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new L("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const s={};s.className=r.getClassName(),s.config=r.getConfig(),e.push(s)}return{name:this.name,layers:e}}}return n.className="Sequential",n})());class cs extends wu{getConfig(){return{}}}ge((()=>{class n extends cs{apply(e,r=1){return function Yce(n,t=1){if(1!==t)throw new ft(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return h_(n)}(e,r)}}return n.className="elu",n})()),ge((()=>{class n extends cs{apply(e){return q2(e)}}return n.className="selu",n})()),ge((()=>{class n extends cs{apply(e){return Xo(e)}}return n.className="relu",n})()),ge((()=>{class n extends cs{apply(e){return te(()=>m_(6,Xo(e)))}}return n.className="relu6",n})()),ge((()=>{class n extends cs{apply(e){return e}}return n.className="linear",n})()),ge((()=>{class n extends cs{apply(e){return Su(e)}}return n.className="sigmoid",n})()),ge((()=>{class n extends cs{apply(e){return function Qce(n){return te(()=>{const t=we(.5,P(.2,n));return Bs(t,0,1)})}(e)}}return n.className="hardSigmoid",n})()),ge((()=>{class n extends cs{apply(e){return Bf(e)}}return n.className="softplus",n})()),ge((()=>{class n extends cs{apply(e){return function Zce(n){return te(()=>Ze(n,we(mr(n),1)))}(e)}}return n.className="softsign",n})()),ge((()=>{class n extends cs{apply(e){return aS(e)}}return n.className="tanh",n})());let QL=(()=>{class n extends cs{apply(e,r=-1){return oS(e,r)}}return n.className="softmax",n})();function Ua(n){return n.getClassName()}function AE(n,t={}){return Kf(n,ci.getMap().classNameMap,t,"activation")}function Ha(n){if(null==n){return AE({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},AE(t)}return n instanceof cs?n:AE(n)}ge(QL),ge((()=>{class n extends cs{apply(e,r=-1){return H2(e,r)}}return n.className="logSoftmax",n})()),ge((()=>{class n extends cs{apply(e,r=1){return te(()=>P(Su(P(e,r)),e))}}return n.className="swish",n})()),ge((()=>{class n extends cs{apply(e){return te(()=>P(e,aS(Bf(e))))}}return n.className="mish",n})());class JL extends wu{}ge((()=>{class n extends JL{constructor(e){super(),function RE(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return te(()=>{let r=_r([1]);return this.hasL1&&(r=we(r,He(P(this.l1,mr(e))))),this.hasL2&&(r=we(r,He(P(this.l2,Qf(e))))),j(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return n.className="L1L2",n})());const eV={l1l2:"L1L2"};function tn(n){return eE(n)}function tV(n,t={}){return Kf(n,ci.getMap().classNameMap,t,"regularizer")}function vn(n){return null==n?null:"string"==typeof n?tV({className:n in eV?eV[n]:n,config:{}}):n instanceof JL?n:tV(n)}function Fu(n,t,e){if("number"==typeof n)return Hl(n,t);if(n.length!==t)throw new L(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let r=0;r<t;++r){const s=n[r];if(!jce(s))throw new L(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${s}`)}return n}function Wi(n,t,e,r,s=1){if(null==n)return n;let o;return o="same"===e?n:n-(t+(t-1)*(s-1))+1,Math.floor((o+r-1)/r)}function Co(n,t,e,r){if(null==n)return null;if("valid"===r)n=n*t+Va([e-t,0]);else{if("same"!==r)throw new L(`Unsupport padding mode: ${r}.`);n*=t}return n}function OE(n,t){return te(()=>(zn(t),"channelsFirst"===t?zt(n,[0,2,3,1]):n))}function nV(n,t){return te(()=>(zn(t),"channelsFirst"===t?zt(n,[0,2,3,4,1]):n))}function FE(n,t,e,r=[1,1],s="valid",i,o,a=null){return te(()=>{if(null==i&&(i="channelsLast"),zn(i),3!==n.rank&&4!==n.rank)throw new L(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new L(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=OE(n,i);if("causal"===s)throw new ft("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=_se({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===i&&(l=zt(l,[0,3,1,2])),l})}ge((()=>{class n extends Pt{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=yt(e);let s=Xo(e);return null!=this.maxValue&&(s=Bs(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ReLU",n})()),ge((()=>{class n extends Pt{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const s=yt(e);return XD(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LeakyReLU",n})()),ge((()=>{class n extends Pt{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=_n(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=vn(e.alphaRegularizer),this.alphaConstraint=rr(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new L(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=Gt(e)).slice(1);if(null!=this.sharedAxes)for(const i of this.sharedAxes)r[i-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let i=1;i<e.length;++i)s[i]=e[i];this.inputSpec=[new sr({ndim:e.length,axes:s})],this.built=!0}call(e,r){return e=yt(e),tS(e,this.alpha.read())}getConfig(){const e={alphaInitializer:En(this.alphaInitializer),alphaRegularizer:tn(this.alphaRegularizer),alphaConstraint:nr(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return n.className="PReLU",n})()),ge((()=>{class n extends Pt{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new ft(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const s=yt(e);return h_(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ELU",n})()),ge((()=>{class n extends Pt{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,r){const s=yt(e);return P(s,Ne(fi(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ThresholdedReLU",n})()),ge((()=>{class n extends Pt{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new QL).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,r){const s=yt(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Softmax",n})());class Y_ extends Pt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Y_.verifyArgs(e),this.rank=t,vr(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new ft(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Fu(e.kernelSize,t,"kernelSize"),this.strides=Fu(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,Hs(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,zn(this.dataFormat),this.activation=Ha(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=_n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=rr(e.biasConstraint),this.biasRegularizer=vn(e.biasRegularizer),this.activityRegularizer=vn(e.activityRegularizer),this.dilationRate=Fu(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new L(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new L(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new L(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(Us("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!nE(t.kernelSize,"number",1,3))throw new L(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ua(this.activation),useBias:this.useBias,biasInitializer:En(this.biasInitializer),biasRegularizer:tn(this.biasRegularizer),activityRegularizer:tn(this.activityRegularizer),biasConstraint:nr(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Pu extends Y_{constructor(t,e){super(t,e),this.kernel=null,Pu.verifyArgs(e),this.filters=e.filters,vr(this.filters,"filters"),this.kernelInitializer=_n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=rr(e.kernelConstraint),this.kernelRegularizer=vn(e.kernelRegularizer)}build(t){t=Gt(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new L(`The channel dimension of the input should be defined. Found ${t[e]}`);const r=t[e],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(t,e){return te(()=>{let r;t=yt(t);const s=null==this.bias?null:this.bias.read(),i=sL(this.activation.getClassName());if(null!=i&&2===this.rank)r=FE(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(1===this.rank)r=function rV(n,t,e,r=1,s="valid",i,o=1){return te(()=>{if(null==i&&(i="channelsLast"),zn(i),3!==n.shape.length)throw new L(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new L(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new L(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===i&&(n=zt(n,[0,2,1])),"causal"===s)throw new ft("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=L2(n,t,r,"same"===s?"same":"valid","NWC",o);return null!=e&&(a=Ui(a,e)),a})}(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=FE(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new ft("convolutions greater than 3D are not implemented yet.");r=function sV(n,t,e,r=[1,1,1],s="valid",i,o){return te(()=>{if(null==i&&(i="channelsLast"),zn(i),4!==n.rank&&5!==n.rank)throw new L(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new L(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=nV(n,i);if("causal"===s)throw new ft("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=zne(a,t,r,"same"===s?"same":"valid","NDHWC",o),null!=e&&(a=Ui(a,e)),"channelsFirst"===i&&(a=zt(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Gt(t);const e=[],r="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<r.length;++i){const o=Wi(r[i],this.kernelSize[i],this.padding,this.strides[i],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[i]);e.push(o)}let s=[t[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const t={filters:this.filters,kernelInitializer:En(this.kernelInitializer),kernelRegularizer:tn(this.kernelRegularizer),kernelConstraint:nr(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new L(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let iV=(()=>{class n extends Pu{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!nE(e.kernelSize,"number",1,2))throw new L(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();ge(iV);let oV=(()=>{class n extends Pu{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new L(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();ge(oV),ge((()=>{class n extends iV{constructor(e){if(super(e),this.inputSpec=[new sr({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new L(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Gt(e)).length)throw new L("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new L("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new sr({ndim:4,axes:{[r]:s}})],this.built=!0}call(e,r){return te(()=>{let s=yt(e);if(4!==s.shape.length)throw new L(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const u=i[l],h=this.kernelSize[1],p=this.strides[1],_=[i[0],Co(i[a],this.strides[0],this.kernelSize[0],this.padding),Co(u,p,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=zt(s,[0,2,3,1]));let y=V2(s,this.kernel.read(),_,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=zt(y,[0,3,1,2])),null!=this.bias&&(y=Ui(y,this.bias.read(),this.dataFormat)),null!=this.activation&&(y=this.activation.apply(y)),y})}computeOutputShape(e){const r=(e=Gt(e)).slice();let s,i,o;"channelsFirst"===this.dataFormat?(s=1,i=2,o=3):(s=3,i=1,o=2);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],u=this.strides[1];return r[s]=this.filters,r[i]=Co(r[i],c,a,this.padding),r[o]=Co(r[o],u,l,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})()),ge((()=>{class n extends oV{constructor(e){if(super(e),this.inputSpec=[new sr({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new L(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Gt(e)).length)throw new L("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new L("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new sr({ndim:5,axes:{[r]:s}})],this.built=!0}call(e,r){return te(()=>{let s=yt(e);if(5!==s.shape.length)throw new L(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape;let a,l,c;"channelsFirst"===this.dataFormat?(c=2,a=3,l=4):(c=1,a=2,l=3);const d=i[a],h=i[l],p=this.kernelSize[1],m=this.kernelSize[2],_=this.strides[1],y=this.strides[2],C=[i[0],Co(i[c],this.strides[0],this.kernelSize[0],this.padding),Co(d,_,p,this.padding),Co(h,y,m,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=zt(s,[0,2,3,4,1]));let E=jne(s,this.kernel.read(),C,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(E=zt(E,[0,4,1,2,3])),null!==this.bias&&(E=Ui(E,this.bias.read(),this.dataFormat)),null!==this.activation&&(E=this.activation.apply(E)),E})}computeOutputShape(e){const r=(e=Gt(e)).slice();let s,i,o,a;"channelsFirst"===this.dataFormat?(s=1,i=2,o=3,a=4):(s=4,i=1,o=2,a=3);const l=this.kernelSize[0],c=this.kernelSize[1],u=this.kernelSize[2],d=this.strides[0],h=this.strides[1],f=this.strides[2];return r[s]=this.filters,r[i]=Co(r[i],d,l,this.padding),r[o]=Co(r[o],h,c,this.padding),r[a]=Co(r[a],f,u,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})());let hde=(()=>{class n extends Pu{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new L("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new L("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new L(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=null==r.depthMultiplier?1:r.depthMultiplier,this.depthwiseInitializer=_n(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=vn(r.depthwiseRegularizer),this.depthwiseConstraint=rr(r.depthwiseConstraint),this.pointwiseInitializer=_n(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=vn(r.pointwiseRegularizer),this.pointwiseConstraint=rr(r.pointwiseConstraint)}build(e){if((e=Gt(e)).length<this.rank+2)throw new L(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new L(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const s=e[r],i=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let l=0;l<this.rank;++l)o.push(1);o.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new sr({ndim:this.rank+2,axes:{[r]:s}})],this.built=!0}call(e,r){return te(()=>{let s;if(e=yt(e),1===this.rank)throw new ft("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=zt(e,[0,2,3,1])),s=K2(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Ui(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),"channelsFirst"===this.dataFormat&&(s=zt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=En(this.depthwiseInitializer),e.pointwiseInitializer=En(this.pointwiseInitializer),e.depthwiseRegularizer=tn(this.depthwiseRegularizer),e.pointwiseRegularizer=tn(this.pointwiseRegularizer),e.depthwiseConstraint=nr(this.depthwiseConstraint),e.pointwiseConstraint=nr(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})();function aV(n,t,e,r){if(Array.isArray(n)){if(null!=t||null!=e)throw new L("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function s(i){return null==i||Array.isArray(i)?i:[i]}return{inputs:n,initialState:t=s(t),constants:e=s(e)}}function lV(n,t,e,r=!1,s,i,o=!1,a=!1){return te(()=>{const l=t.shape.length;if(l<3)throw new L(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(zi(2,l));if(t=zt(t,c),null!=i)throw new ft("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=Ne(Ne(s,"bool"),"float32")).rank===l-1&&(s=hi(s,-1)),s=zt(s,c)),r&&(t=Vl(t,0),null!=s&&(s=Vl(s,0)));const u=[];let d,h=e;const f=t.shape[0],p=Eu(t);let m,g;null!=s&&(m=Eu(s));for(let _=0;_<f;++_){const y=p[_],v=te(()=>n(y,h));if(null==s)d=v[0],h=v[1];else{const b=te(()=>{const w=m[_],C=Ue(mi(w),w);return{output:we(P(v[0],w),P(h[0],C)),newStates:h.map((M,O)=>we(P(v[1][O],w),P(M,C)))}});d=b.output,h=b.newStates}a&&u.push(d)}return a&&(g=Bl(u,1)),[d,g,h]})}ge((()=>{class n extends hde{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})()),ge((()=>{class n extends Pu{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!nE(e.kernelSize,"number",1,1))throw new L(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})()),ge((()=>{class n extends Pt{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return te(()=>{if(e=yt(e),"channelsLast"===this.dataFormat){const s=M_(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return M_(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const s=M_(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return M_(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Cropping2D",n})()),ge((()=>{class n extends Pt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,zn(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function zce(n){Wl($ce,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return te(()=>{let s=yt(e);const i=s.shape;if("channelsFirst"===this.dataFormat){s=zt(s,[0,2,3,1]);const o=this.size[0]*i[2],a=this.size[1]*i[3],l="nearest"===this.interpolation?Hf.resizeNearestNeighbor(s,[o,a]):Hf.resizeBilinear(s,[o,a]);return zt(l,[0,3,1,2])}{const o=this.size[0]*i[1],a=this.size[1]*i[2];return"nearest"===this.interpolation?Hf.resizeNearestNeighbor(s,[o,a]):Hf.resizeBilinear(s,[o,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="UpSampling2D",n})()),ge((()=>{class n extends Y_{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=_n(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=rr(e.depthwiseConstraint),this.depthwiseRegularizer=vn(e.depthwiseRegularizer)}build(e){if((e=Gt(e)).length<4)throw new L(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new L(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const s=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return te(()=>{let s=function fde(n,t,e=[1,1],r="valid",s,i){return te(()=>{null==s&&(s="channelsLast"),zn(s);let o=OE(n,s);if(4!==n.rank)throw new L(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new L(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=d_(o,t,e,"same"===r?"same":"valid","NHWC",i),"channelsFirst"===s&&(o=zt(o,[0,3,1,2])),o})}(e=yt(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Ui(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Gt(e);const s="channelsFirst"===this.dataFormat?e[3]:e[2],i="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=Wi("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=Wi(s,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],i,o,a]:[e[0],o,a,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=En(this.depthwiseInitializer),e.depthwiseRegularizer=tn(this.depthwiseRegularizer),e.depthwiseConstraint=nr(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})());let rp=(()=>{class n extends Pt{constructor(e){let r;if(super(e),null==e.cell)throw new L("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new dV({cells:e.cell}):e.cell,null==r.stateSize)throw new L("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new sr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?zi(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){lE(e)&&(e=e[0]),e=e;let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const s=r[0];let i;if(i=this.returnSequences?[e[0],e[1],s]:[e[0],s],this.returnState){const o=[];for(const a of r)o.push([e[0],a]);return[i].concat(o)}return i}computeMask(e,r){return te(()=>{Array.isArray(r)&&(r=r[0]);const s=this.returnSequences?r:null;if(this.returnState){const i=this.states.map(o=>null);return[s].concat(i)}return s})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let s=0;s<e;++s)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new ft("Constants support is not implemented in RNN yet.");lE(e)&&(e=e[0]),e=e;const s=this.stateful?e[0]:null,i=e.slice(2);this.inputSpec[0]=new sr({shape:[s,null,...i]});const o=[e[0]].concat(e.slice(2));let a;if(this.cell.build(o),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Ut(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new L(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new sr({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){te(()=>{if(!this.stateful)throw new _o("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new L("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>_r([s,i])):[_r([s,this.cell.stateSize])];else if(null==e)St(this.states_),null!=this.keptStates&&(St(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>_r([s,i])):this.states_[0]=_r([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new L(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):St(this.states_);for(let i=0;i<this.states_.length;++i){const o=e[i],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,l=[s,a];if(!Ut(o.shape,l))throw new L(`State ${i} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${o.shape}`);this.states_[i]=o}}this.states_=this.states_.map(i=>po(i.clone()))})}apply(e,r){let s=null==r?null:r.initialState,i=null==r?null:r.constants;null==r&&(r={});const o=aV(e,s,i,this.numConstants);e=o.inputs,s=o.initialState,i=o.constants;let a=[],l=[];if(null!=s){r.initialState=s,a=a.concat(s),this.stateSpec=[];for(const u of s)this.stateSpec.push(new sr({shape:u.shape}));l=l.concat(this.stateSpec)}if(null!=i&&(r.constants=i,a=a.concat(i),this.numConstants=i.length),a[0]instanceof xo){const u=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(u,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return te(()=>{const s=null==r?null:r.mask,i=null==r?null:r.training;let o=null==r?null:r.initialState;e=yt(e),null==o&&(o=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new L(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:i},u=lV((m,g)=>{const _=this.cell.call([m].concat(g),l);return[_[0],_.slice(1)]},e,o,this.goBackwards,s,null,this.unroll,this.returnSequences),d=u[0],h=u[1],f=u[2];this.stateful&&this.resetStates(f,i);const p=this.returnSequences?h:d;return this.returnState?[p].concat(f):p})}getInitialState(e){return te(()=>{let r=_r(e.shape);return r=He(r,[1,2]),r=Zf(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?oE(r,[1,s]):r):this.cell.stateSize>1?[oE(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===n.className&&(r.cell={className:this.cell.getClassName(),config:s}),Object.assign({},s,e,r)}static fromConfig(e,r,s={}){const o=wo(r.cell,s);return new e(Object.assign(r,{cell:o}))}}return n.className="RNN",n})();ge(rp);class Z_ extends Pt{}let cV=(()=>{class n extends Z_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,vr(this.units,"units"),this.activation=Ha(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=_n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=_n(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=_n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vn(e.kernelRegularizer),this.recurrentRegularizer=vn(e.recurrentRegularizer),this.biasRegularizer=vn(e.biasRegularizer),this.kernelConstraint=rr(e.kernelConstraint),this.recurrentConstraint=rr(e.recurrentConstraint),this.biasConstraint=rr(e.biasConstraint),this.dropout=Ru([1,Va([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Ru([1,Va([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Gt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return te(()=>{if(2!==(e=e).length)throw new L(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const i=null!=r.training&&r.training;let o;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ja({ones:()=>mi(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ja({ones:()=>mi(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,l=this.recurrentDropoutMask;o=vo(null!=a?P(e,a):e,this.kernel.read()),null!=this.bias&&(o=Ui(o,this.bias.read())),null!=l&&(s=P(s,l));let c=we(o,vo(s,this.recurrentKernel.read()));return null!=this.activation&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Ua(this.activation),useBias:this.useBias,kernelInitializer:En(this.kernelInitializer),recurrentInitializer:En(this.recurrentInitializer),biasInitializer:En(this.biasInitializer),kernelRegularizer:tn(this.kernelRegularizer),recurrentRegularizer:tn(this.recurrentRegularizer),biasRegularizer:tn(this.biasRegularizer),activityRegularizer:tn(this.activityRegularizer),kernelConstraint:nr(this.kernelConstraint),recurrentConstraint:nr(this.recurrentConstraint),biasConstraint:nr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,r)}}return n.className="SimpleRNNCell",n})();ge(cV),ge((()=>{class n extends rp{constructor(e){e.cell=new cV(e),super(e)}call(e,r){return te(()=>(null!=this.cell.dropoutMask&&(St(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(St(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return n.className="SimpleRNN",n})());let uV=(()=>{class n extends Z_{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new L("GRUCell does not support reset_after parameter set to true.");this.units=e.units,vr(this.units,"units"),this.activation=Ha(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ha(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=_n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=_n(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=_n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vn(e.kernelRegularizer),this.recurrentRegularizer=vn(e.recurrentRegularizer),this.biasRegularizer=vn(e.biasRegularizer),this.kernelConstraint=rr(e.kernelConstraint),this.recurrentConstraint=rr(e.recurrentConstraint),this.biasConstraint=rr(e.biasConstraint),this.dropout=Ru([1,Va([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Ru([1,Va([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Gt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return te(()=>{if(2!==(e=e).length)throw new L(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=null!=r.training&&r.training;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ja({ones:()=>mi(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ja({ones:()=>mi(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let l,c,u;0<this.dropout&&this.dropout<1&&(e=P(e,this.dropoutMask[0]));let d=vo(e,this.kernel.read());this.useBias&&(d=Ui(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=P(i,a[0]));const h=this.recurrentKernel.read(),[f,p]=zs(h,[2*this.units,this.units],h.rank-1),m=vo(i,f),[g,_,y]=zs(d,3,d.rank-1),[v,b]=zs(m,2,m.rank-1);l=this.recurrentActivation.apply(we(g,v)),c=this.recurrentActivation.apply(we(_,b));const w=vo(P(c,i),p);u=this.activation.apply(we(y,w));const C=we(P(l,i),P(we(1,Rn(l)),u));return[C,C]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Ua(this.activation),recurrentActivation:Ua(this.recurrentActivation),useBias:this.useBias,kernelInitializer:En(this.kernelInitializer),recurrentInitializer:En(this.recurrentInitializer),biasInitializer:En(this.biasInitializer),kernelRegularizer:tn(this.kernelRegularizer),recurrentRegularizer:tn(this.recurrentRegularizer),biasRegularizer:tn(this.biasRegularizer),activityRegularizer:tn(this.activityRegularizer),kernelConstraint:nr(this.kernelConstraint),recurrentConstraint:nr(this.recurrentConstraint),biasConstraint:nr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,r)}}return n.className="GRUCell",n})();ge(uV),ge((()=>{class n extends rp{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new uV(e),super(e)}call(e,r){return te(()=>(null!=this.cell.dropoutMask&&(St(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(St(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="GRU",n})());let PE=(()=>{class n extends Z_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,vr(this.units,"units"),this.activation=Ha(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ha(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=_n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=_n(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=_n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=vn(e.kernelRegularizer),this.recurrentRegularizer=vn(e.recurrentRegularizer),this.biasRegularizer=vn(e.biasRegularizer),this.kernelConstraint=rr(e.kernelConstraint),this.recurrentConstraint=rr(e.recurrentConstraint),this.biasConstraint=rr(e.biasConstraint),this.dropout=Ru([1,Va([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Ru([1,Va([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let i;if(e=Gt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,a=this.units;i=new((r=class extends _i{apply(c,u){const d=o.apply([a]),h=(new gL).apply([a]),f=o.apply([2*a]);return fL(fL(d,h),f)}}).className="CustomInit",r)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return te(()=>{const s=null!=r.training&&r.training;if(3!==(e=e).length)throw new L(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ja({ones:()=>mi(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ja({ones:()=>mi(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let c,u,d,h;0<this.dropout&&this.dropout<1&&(e=P(e,this.dropoutMask[0]));let f=vo(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=P(i,l[0])),f=we(f,vo(i,this.recurrentKernel.read())),this.useBias&&(f=Ui(f,this.bias.read()));const[p,m,g,_]=zs(f,4,f.rank-1);c=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(m),d=we(P(u,o),P(c,this.activation.apply(g))),h=this.recurrentActivation.apply(_);const y=P(h,this.activation.apply(d));return[y,y,d]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Ua(this.activation),recurrentActivation:Ua(this.recurrentActivation),useBias:this.useBias,kernelInitializer:En(this.kernelInitializer),recurrentInitializer:En(this.recurrentInitializer),biasInitializer:En(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:tn(this.kernelRegularizer),recurrentRegularizer:tn(this.recurrentRegularizer),biasRegularizer:tn(this.biasRegularizer),activityRegularizer:tn(this.activityRegularizer),kernelConstraint:nr(this.kernelConstraint),recurrentConstraint:nr(this.recurrentConstraint),biasConstraint:nr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,r)}}return n.className="LSTMCell",n})();ge(PE),ge((()=>{class n extends rp{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new PE(e),super(e)}call(e,r){return te(()=>(null!=this.cell.dropoutMask&&(St(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(St(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="LSTM",n})());let dV=(()=>{class n extends Z_{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return te(()=>{let s=(e=e).slice(1);const i=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?i.push(s.splice(0,l.stateSize.length)):i.push(s.splice(0,1));i.reverse();const o=[];let a;for(let l=0;l<this.cells.length;++l){const c=this.cells[l];s=i[l],a=0===l?[e[0]].concat(s):[a[0]].concat(s),a=c.call(a,r),o.push(a.slice(1))}s=[];for(const l of o.slice().reverse())s.push(...l);return[a[0]].concat(s)})}build(e){let r;lE(e)&&(e=e[0]),e=e,this.cells.forEach((s,i)=>{Gl(`RNNCell_${i}`,()=>{s.build(e),r=Array.isArray(s.stateSize)?s.stateSize[0]:s.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),i={cells:this.cells.map(o=>({className:o.getClassName(),config:o.getConfig()}))};return Object.assign({},e,i)}static fromConfig(e,r,s={}){const i=[];for(const o of r.cells)i.push(wo(o,s));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const s of this.cells)r.push(...s.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return cE(e)}setWeights(e){const r=[];for(const s of this.cells){const o=e.splice(s.weights.length);for(let a=0;a<s.weights.length;++a)r.push([s.weights[a],o[a]])}uE(r)}}return n.className="StackedRNNCells",n})();function ja(n){const{ones:t,rate:e,training:r=!1,count:s=1,dropoutFunc:i}=n,o=()=>null!=i?i(t(),e):mL(t(),e),a=()=>Jf(o,t,r);return!s||s<=1?po(a().clone()):Array(s).fill(void 0).map(a).map(c=>po(c.clone()))}ge(dV);let mde=(()=>{class n extends rp{constructor(e){if(e.unroll)throw new ft("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new ft("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new sr({ndim:5})]}call(e,r){return te(()=>{if(null!=this.cell.dropoutMask&&(St(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(St(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new L("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return te(()=>{const{stateSize:r}=this.cell,i=this.computeSingleOutputShape(e.shape),a=_r([i[0],...i.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){te(()=>{if(!this.stateful)throw new _o("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),o=[i[0],...i.slice(2)];if(null==s[0])throw new L("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>_r(o)):[_r(o)];else if(null==e)St(this.states_),null!=this.keptStates&&(St(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>_r(o)):this.states_[0]=_r(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new L(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):St(this.states_);for(let l=0;l<this.states_.length;++l){const c=e[l],u=o;if(!Ut(c.shape,u))throw new L(`State ${l} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${c.shape}`);this.states_[l]=c}}this.states_=this.states_.map(l=>po(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:s,kernelSize:i,padding:o,strides:a,dilationRate:l}=this.cell,c="channelsFirst"===r,d=e[c?4:3],h=Wi(e[c?3:2],i[0],o,a[0],l[0]),f=Wi(d,i[1],o,a[1],l[1]);return[...e.slice(0,2),...c?[s,h,f]:[h,f,s]]}}return n.className="ConvRNN2D",n})(),hV=(()=>{class n extends PE{constructor(e){const{filters:r,kernelSize:s,strides:i,padding:o,dataFormat:a,dilationRate:l}=e;super(Object.assign({},e,{units:r})),this.filters=r,vr(this.filters,"filters"),this.kernelSize=Fu(s,2,"kernelSize"),this.kernelSize.forEach(c=>vr(c,"kernelSize")),this.strides=Fu(i||1,2,"strides"),this.strides.forEach(c=>vr(c,"strides")),this.padding=o||"valid",Hs(this.padding),this.dataFormat=a||"channelsLast",zn(this.dataFormat),this.dilationRate=Fu(l||1,2,"dilationRate"),this.dilationRate.forEach(c=>vr(c,"dilationRate"))}build(e){var r;e=Gt(e);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new L(`The channel dimension of the input should be defined. Found ${e[s]}`);const a=this.kernelSize.concat([e[s],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const u=this.biasInitializer,d=this.filters;c=new((r=class extends _i{apply(f,p){return iE([u.apply([d]),Pa([d]),u.apply([2*d])])}}).className="CustomInit",r)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return te(()=>{if(3!==e.length)throw new L(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training||!1,i=e[0],o=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ja({ones:()=>mi(i),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,u=(me,De,be)=>De&&De[be]?P(De[be],me):me;let d=u(i,c,0),h=u(i,c,1),f=u(i,c,2),p=u(i,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ja({ones:()=>mi(o),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let g=u(o,m,0),_=u(o,m,1),y=u(o,m,2),v=u(o,m,3);const[w,C,E,k]=zs(this.kernel.read(),4,3),[M,O,K,X]=this.useBias?zs(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,w,M,this.padding),h=this.inputConv(h,C,O,this.padding),f=this.inputConv(f,E,K,this.padding),p=this.inputConv(p,k,X,this.padding);const[Q,re,ne,V]=zs(this.recurrentKernel.read(),4,3);g=this.recurrentConv(g,Q),_=this.recurrentConv(_,re),y=this.recurrentConv(y,ne),v=this.recurrentConv(v,V);const G=this.recurrentActivation.apply(we(d,g)),W=this.recurrentActivation.apply(we(h,_)),J=we(P(W,a),P(G,this.activation.apply(we(f,y)))),ue=P(this.recurrentActivation.apply(we(p,v)),this.activation.apply(J));return[ue,ue,J]})}getConfig(){const s=function(n,t){var e={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&t.indexOf(r)<0&&(e[r]=n[r]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(n);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(n,r[s])&&(e[r[s]]=n[r[s]])}return e}(super.getConfig(),["units"]);return Object.assign({},s,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(e,r,s,i){const o=Ll(e,r,this.strides,i||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return s?Ui(o,s,this.dataFormat):o}recurrentConv(e,r){return Ll(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();ge(hV),ge((()=>{class n extends mde{constructor(e){const r=new hV(e);super(Object.assign({},e,{cell:r}))}static fromConfig(e,r){return new e(r)}}return n.className="ConvLSTM2D",n})());let fV=(()=>{class n extends Pt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(null==this.noiseShape[i]?r[i]:this.noiseShape[i]);return s}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=yt(e);if(0<this.rate&&this.rate<1){const i=null!=r.training&&r.training,o=this.getNoiseShape(s);return Jf(()=>mL(s,this.rate,o,this.seed),()=>s,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();ge(fV),ge((()=>{class n extends fV{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return n.className="SpatialDropout1D",n})()),ge((()=>{class n extends Pt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,vr(this.units,"units"),this.activation=Ha(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=_n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=_n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=rr(e.kernelConstraint),this.biasConstraint=rr(e.biasConstraint),this.kernelRegularizer=vn(e.kernelRegularizer),this.biasRegularizer=vn(e.biasRegularizer),this.activityRegularizer=vn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=Gt(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=Gt(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=yt(e),i=sL(this.activation.getClassName());let o;return null!=i?o=vo(s,this.kernel.read(),i,this.bias?this.bias.read():null):(o=vo(s,this.kernel.read()),null!=this.bias&&(o=Ui(o,this.bias.read())),null!=this.activation&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:Ua(this.activation),useBias:this.useBias,kernelInitializer:En(this.kernelInitializer),biasInitializer:En(this.biasInitializer),kernelRegularizer:tn(this.kernelRegularizer),biasRegularizer:tn(this.biasRegularizer),activityRegularizer:tn(this.activityRegularizer),kernelConstraint:nr(this.kernelConstraint),biasConstraint:nr(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dense",n})()),ge((()=>{class n extends Pt{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Gt(e);for(const r of e.slice(1))if(null==r)throw new L(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],La(e,1)]}call(e,r){return te(()=>{this.invokeCallHook(e,r);let s=yt(e);if("channelsFirst"===this.dataFormat&&s.rank>1){const i=[0];for(let o=2;o<s.rank;++o)i.push(o);i.push(1),s=zt(s,i)}return function Xce(n){if(n.rank<=1)throw new L(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],La(n.shape,1)];return j(n,t)}(s)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return n.className="Flatten",n})()),ge((()=>{class n extends Pt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Ha(e.activation)}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=yt(e);return this.activation.apply(s)})}getConfig(){const e={activation:Ua(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Activation",n})()),ge((()=>{class n extends Pt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return te(()=>function qce(n,t){return te(()=>{if(2!==n.shape.length)throw new L(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return oE(Zf(n,1),[1,t,1])})}(e=yt(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return n.className="RepeatVector",n})()),ge((()=>{class n extends Pt{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const s="Total size of new array must be unchanged.",i=r.slice();let o=1,a=null;for(let c=0;c<i.length;++c){const u=i[c];if(this.isUnknown(u)){if(null!==a)throw new L("Can only specifiy one unknown dimension.");a=c}else o*=u}const l=La(e);if(null!==a){if(0===o||l%o!=0)throw new L(s);i[a]=l/o}else if(l!==o)throw new L(s);return i}computeOutputShape(e){let r=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=yt(e),i=s.shape,o=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return j(s,o)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Reshape",n})()),ge((()=>{class n extends Pt{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=zi(1,e.dims.length+1);if(!Ut(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new sr({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=Gt(e)).slice();return this.dims.forEach((s,i)=>{r[i+1]=e[s]}),r}call(e,r){return zt(yt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Permute",n})()),ge((()=>{class n extends Pt{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const s=yt(e);return HD(Vf(s,this.maskValue),-1)}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=yt(e),a=HD(Vf(s,this.maskValue),-1,!0);return P(s,Ne(a,s.dtype))})}}return n.className="Masking",n})()),ge((()=>{class n extends Pt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(ln(e.inputLength))}this.inputDim=e.inputDim,vr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,vr(this.outputDim,"outputDim"),this.embeddingsInitializer=_n(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=vn(e.embeddingsRegularizer),this.activityRegularizer=vn(e.activityRegularizer),this.embeddingsConstraint=rr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return te(()=>this.maskZero?(e=yt(e),Vf(e,Ft(e))):null)}computeOutputShape(e){if(e=Gt(e),null==this.inputLength)return[...e,this.outputDim];const r=ln(this.inputLength);if(r.length!==e.length-1)throw new L(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let i=0;i<r.length;++i){const o=r[i],a=e[i+1];if(null!=o&&null!=a&&o!==a)throw new L(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==o&&(r[s]=a),s++}}return[e[0],...r,this.outputDim]}call(e,r){return te(()=>{this.invokeCallHook(e,r);let s=yt(e);"int32"!==s.dtype&&(s=R_(s,"int32"));const i=pL(this.embeddings.read(),j(s,[s.size]));return j(i,Gt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:En(this.embeddingsInitializer),embeddingsRegularizer:tn(this.embeddingsRegularizer),activityRegularizer:tn(this.activityRegularizer),embeddingsConstraint:nr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Embedding",n})());class Kl extends Pt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new ft}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const r=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){const i=t[t.length-e.length+s],o=e[s];if(null==i||null==o||i<0||o<0)r.push(null);else if(1===i)r.push(o);else if(1===o)r.push(i);else{if(i!==o)throw new L("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));r.push(i)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Gt(t)]),(t=t).length<2)throw new L(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)null!=i&&null!==i[0]&&e.push(i[0]);if(e=$a(e),e.length>1)throw new L(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=null==t[0]?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=null==t[i]?null:t[i].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const s=t.map(i=>i.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==$a(s).length}call(t,e){return te(()=>{if(t=t,this.reshapeRequired){const r=[],s=t.map(i=>i.rank);if(-1===s.indexOf(null)){const i=Va(s);for(let o of t){const a=o.rank;for(let l=0;l<i-a;++l)o=Zf(o,1);r.push(o)}return this.mergeFunction(r)}{let i=!1;for(const l of t){const c=l.rank;if(null==c){const u=l.shape,d=u[0],h=u.slice(1).concat([d]);let f=j(l,[d].concat(La(u.slice(1))));f=zt(f,[1,0]),f=j(f,h),r.push(f),i=!0}else if(c>1){const u=zi(1,c).concat([0]);r.push(zt(l,u)),i=!0}else r.push(l)}let o=this.mergeFunction(r);const a=o.rank;if(i)if(null==a){const l=o.shape,u=l[l.length-1],d=[u].concat(l.slice(0,l.length-1));o=j(zt(j(o,[-1,u]),[1,0]),d)}else if(a>1){const l=[a-1].concat(zi(0,a-1));o=zt(o,l)}return o}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==(t=t)[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const i=null==t[s]?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let r=[];for(const s of t)null!=s&&null!==s[0]&&r.push(s[0]);return r=$a(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(t,e){return te(()=>{if(null==e)return null;if(!Array.isArray(e))throw new L("`mask` should be an Array");if(!Array.isArray(t))throw new L("`inputs` should be an Array");if(e.length!==t.length)throw new L(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(s=>null==s))return null;let r=(e=e.map(s=>null==s?s:hi(s,0)))[0];for(let s=1;s<e.length-1;++s)r=Ko(r,e[s]);return r})}}function sp(n,t){for(;n<0;)n+=t;return n}function ip(n,t,e,r,s,i=.001){let o;if(2===n.rank)o=xne(n,t,e,r,s,i);else if(3===n.rank)o=Cne(n,t,e,r,s,i);else{if(4!==n.rank)throw new ft(`batchNormalization is not implemented for array of rank ${n.rank} yet`);o=Sne(n,t,e,r,s,i)}return o}function Q_(n,t,e,r,s,i){return te(()=>{let o;zn(s),aL(i),Hs(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),n=OE(n,s);const a="same"===r?"same":"valid";return o="max"===i?ZD(n,t,e,a):GD(n,t,e,a),"channelsFirst"===s&&(o=zt(o,[0,3,1,2])),o})}function pV(n,t,e,r,s,i){return te(()=>{let o;zn(s),aL(i),Hs(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),n=nV(n,s);const a="same"===r?"same":"valid";return o="max"===i?gre(n,t,e,a):yne(n,t,e,a),"channelsFirst"===s&&(o=zt(o,[0,4,1,2,3])),o})}ge((()=>{class n extends Kl{constructor(e){super(e)}mergeFunction(e){return te(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=we(r,e[s]);return r})}}return n.className="Add",n})()),ge((()=>{class n extends Kl{constructor(e){super(e)}mergeFunction(e){return te(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=P(r,e[s]);return r})}}return n.className="Multiply",n})()),ge((()=>{class n extends Kl{constructor(e){super(e)}mergeFunction(e){return te(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=we(r,e[s]);return P(1/e.length,r)})}}return n.className="Average",n})()),ge((()=>{class n extends Kl{constructor(e){super(e)}mergeFunction(e){return te(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=Oa(r,e[s]);return r})}}return n.className="Maximum",n})()),ge((()=>{class n extends Kl{constructor(e){super(e)}mergeFunction(e){return te(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=m_(r,e[s]);return r})}}return n.className="Minimum",n})()),ge((()=>{class n extends Kl{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new L("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let r=!0;for(const i of e)if(null!=i){r=!1;break}if(r)return;const s=[];for(let i=0;i<e.length;++i){const o=e[i].slice();o.splice(this.axis,1);let a=!1;for(const l of s)if(Ut(l,o)){a=!0;break}a||s.push(o)}if(s.length>1)throw new L("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return te(()=>iE(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new L("A `Concatenate` layer should be called on a list of inputs.");const r=e,s=r[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const o of r.slice(1)){if(null==s[i]||null==o[i]){s[i]=null;break}s[i]+=o[i]}return s}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new L("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new L("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new L(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return te(()=>{let s=!0;if(r.forEach(a=>{null==a||(s=!1)}),s)return null;const i=[];for(let a=0;a<e.length;++a)i.push(null==r[a]?Ne(mi(e[a]),"bool"):r[a].rank<e[a].rank?hi(r[a],-1):r[a]);const o=Lr(i,this.axis);return $2(o,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Concatenate",n})()),ge((()=>{class n extends Kl{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],s=e[1];if(r.length>3||s.length>3)throw new ft("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(r,s);if(r[i[0]]!==s[i[1]])throw new L(`Dimension incompatibility: ${r[i[0]]} !== ${s[i[1]]}`)}mergeFunction(e){if(2!==e.length)throw new L(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let i,r=e[0],s=e[1];return i=Array.isArray(this.axes)?this.axes.map((o,a)=>sp(o,e[a].shape.length)):[sp(this.axes,r.shape.length),sp(this.axes,s.shape.length)],this.normalize&&(r=z_(r,i[0]),s=z_(s,i[1])),function gde(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new ft("batchDot is not implemented for tensors of 4D or higher rank yet");if(S(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),S(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new ft("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,s=t.shape.length;null==e&&(e=[r-1,s-2]);const i=e;return te(()=>{let o,a;if(r>s){o=r-s;const l=[];for(let c=0;c<o;++c)l.push(1);t=j(t,t.shape.concat(l))}else if(s>r){o=s-r;const l=[];for(let c=0;c<o;++c)l.push(1);n=j(n,n.shape.concat(l))}else o=0;if(a=2===n.shape.length&&2===t.shape.length?i[0]===i[1]?He(P(n,t),i[0]):He(P(zt(n,[1,0]),t),i[1]):Ht(n,t,i[0]!==n.shape.length-1,i[1]===t.shape.length-1),o>0){let l;l=r>s?r+s-3:r-1;const c=[];for(let u=l;u<l+o;++u)c.push(u);a=zf(a,c)}return 1===a.shape.length&&(a=hi(a,1)),a})}(r,s,i)}interpretAxes(e,r){let s;return s=Array.isArray(this.axes)?this.axes:[sp(this.axes,e.length),sp(this.axes,r.length)],s}computeOutputShape(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),s=e[1].slice();if(r.length>3||s.length>3)throw new ft("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(r,s);r.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const o=r.concat(s);return 1===o.length&&o.push(1),o}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dot",n})()),ge((()=>{class n extends Pt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=yt(e);return Jf(()=>we(O_(s.shape,0,this.stddev),s),()=>s,r.training||!1)})}}return n.className="GaussianNoise",n})()),ge((()=>{class n extends Pt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return te(()=>{this.invokeCallHook(e,r);const s=yt(e);return this.rate>0&&this.rate<1?Jf(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return P(s,O_(s.shape,1,o))},()=>s,r.training||!1):s})}}return n.className="GaussianDropout",n})()),ge((()=>{class n extends Pt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||yt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return te(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Jf(()=>{const o=yt(e),c=-1.7580993408473766;let u=Du(g_(s),this.rate);u=R_(u,"float32");const d=((1-this.rate)*(1+this.rate*c**2))**-.5,h=-d*c*this.rate,f=we(P(o,u),P(we(u,-1),c));return we(P(f,d),h)},()=>yt(e),r.training||!1)}return e})}}return n.className="AlphaDropout",n})()),ge((()=>{class n extends Pt{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=_n(e.betaInitializer||"zeros"),this.gammaInitializer=_n(e.gammaInitializer||"ones"),this.movingMeanInitializer=_n(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=_n(e.movingVarianceInitializer||"ones"),this.betaConstraint=rr(e.betaConstraint),this.gammaConstraint=rr(e.gammaConstraint),this.betaRegularizer=vn(e.betaRegularizer),this.gammaRegularizer=vn(e.gammaRegularizer)}build(e){e=Gt(e);const r=this.axis>=0?this.axis:this.axis+e.length,s=e[r];if(null==s)throw new L(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new sr({ndim:e.length,axes:{[r]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return te(()=>{const s=null!=r.training&&r.training,i=yt(e),o=i.shape,a=o.length,l=zi(0,a),c=this.axis>=0?this.axis:this.axis+a;l.splice(c,1);const u=Hl(1,a);u[c]=o[c];const d=l.slice();d.sort();const h=!Ut(d,zi(0,a).slice(0,a-1));if(!s)return(()=>{if(h){const v=j(this.movingMean.read(),u),b=j(this.movingVariance.read(),u),w=this.center?j(this.beta.read(),u):null,C=this.scale?j(this.gamma.read(),u):null;return ip(i,v,b,w,C,this.epsilon)}return ip(i,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[p,m,g]=function vde(n,t,e,r,s=.001){return Ut(r.slice().sort(),zi(0,n.rank-1))?function yde(n,t,e,r,s=.001){return te(()=>{const i=JD(n,r),o=i.mean,a=i.variance;return[ip(n,o,a,e,t,s),o,a]})}(n,t,e,r,s):function _de(n,t,e,r,s=.001){return te(()=>{const i=JD(n,r),o=i.mean,a=i.variance,l=[];for(const p of zi(0,n.rank))-1!==r.indexOf(p)?l.push(1):l.push(n.shape[p]);const c=j(o,l),u=j(a,l),d=null==t?null:j(t,l),h=null==e?null:j(e,l);return[ip(n,c,u,h,d,s),o,a]})}(n,t,e,r,s)}(i,this.gamma.read(),this.beta.read(),l,this.epsilon),_=(v,b,w)=>{te(()=>{const C=1-w,E=v.read(),k=P(Ue(E,b),C);v.write(Ue(E,k))})};return(()=>{_(this.movingMean,m,this.momentum),_(this.movingVariance,g,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:En(this.betaInitializer),gammaInitializer:En(this.gammaInitializer),movingMeanInitializer:En(this.movingMeanInitializer),movingVarianceInitializer:En(this.movingVarianceInitializer),betaRegularizer:tn(this.betaRegularizer),gammaRegularizer:tn(this.gammaRegularizer),betaConstraint:nr(this.betaConstraint),gammaConstraint:nr(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BatchNormalization",n})()),ge((()=>{class n extends Pt{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=_n(e.betaInitializer||"zeros"),this.gammaInitializer=_n(e.gammaInitializer||"ones"),this.betaRegularizer=vn(e.betaRegularizer),this.gammaRegularizer=vn(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=Gt(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=r);for(const o of this.axis)if(o<0||o>=r)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==$a(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(o=>e[o]);this.gamma=this.scale?this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const s=yt(e),i=s.shape,o=i.length;return te(()=>{let{mean:l,variance:c}=JD(s,this.axis,!0);const u=Hl(1,o);for(const g of this.axis)u[g]=i[g];const d=g=>null!=g&&g.shape.length!==o?j(g,u):g;let h=d(this.gamma.read()),f=d(this.beta.read());const p=[],m=[];for(let g=0;g<o;++g)-1!==this.axis.indexOf(g)?(p.push(i[g]),m.push(1)):(p.push(1),m.push(i[g]));return l=Vi(l,p),c=Vi(c,p),h=Vi(h,m),f=Vi(f,m),ip(s,l,c,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:En(this.betaInitializer),gammaInitializer:En(this.gammaInitializer),betaRegularizer:tn(this.betaRegularizer),gammaRegularizer:tn(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LayerNormalization",n})()),ge((()=>{class n extends Pt{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new L(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,s;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new L(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new L(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[r,s]}this.inputSpec=[new sr({ndim:4})]}computeOutputShape(e){let r,s;return e=Gt(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,s]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,s,e[3]])}call(e,r){return te(()=>function bde(n,t,e){return te(()=>{if(4!==n.rank)throw new L(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new L("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new L(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],eS(n,r)})}(yt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ZeroPadding2D",n})());class mV extends Pt{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new L(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(vr(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new L(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}vr(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,Hs(this.padding),this.inputSpec=[new sr({ndim:3})]}computeOutputShape(t){const e=Wi((t=Gt(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return te(()=>{this.invokeCallHook(t,e),t=Zf(yt(t),2);const r=this.poolingFunction(yt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return zf(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}ge((()=>{class n extends mV{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return zn(o),Hs(i),Q_(e,r,s,i,o,"max")}}return n.className="MaxPooling1D",n})()),ge((()=>{class n extends mV{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return zn(o),Hs(i),Q_(e,r,s,i,o,"avg")}}return n.className="AveragePooling1D",n})());class gV extends Pt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new L(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];vr(this.poolSize,"poolSize"),vr(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,zn(this.dataFormat),Hs(this.padding),this.inputSpec=[new sr({ndim:4})]}computeOutputShape(t){t=Gt(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2];return e=Wi(e,this.poolSize[0],this.padding,this.strides[0]),r=Wi(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r]:[t[0],e,r,t[3]]}call(t,e){return te(()=>(this.invokeCallHook(t,e),this.poolingFunction(yt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}ge((()=>{class n extends gV{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return zn(o),Hs(i),Q_(e,r,s,i,o,"max")}}return n.className="MaxPooling2D",n})()),ge((()=>{class n extends gV{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return zn(o),Hs(i),Q_(e,r,s,i,o,"avg")}}return n.className="AveragePooling2D",n})());class yV extends Pt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new L(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];vr(this.poolSize,"poolSize"),vr(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,zn(this.dataFormat),Hs(this.padding),this.inputSpec=[new sr({ndim:5})]}computeOutputShape(t){t=Gt(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[4]:t[3];return e=Wi(e,this.poolSize[0],this.padding,this.strides[0]),r=Wi(r,this.poolSize[1],this.padding,this.strides[1]),s=Wi(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r,s]:[t[0],e,r,s,t[4]]}call(t,e){return te(()=>(this.invokeCallHook(t,e),this.poolingFunction(yt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}ge((()=>{class n extends yV{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return zn(o),Hs(i),pV(e,r,s,i,o,"max")}}return n.className="MaxPooling3D",n})()),ge((()=>{class n extends yV{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return zn(o),Hs(i),pV(e,r,s,i,o,"avg")}}return n.className="AveragePooling3D",n})());class _V extends Pt{constructor(t){super(t),this.inputSpec=[new sr({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new ft}}ge((()=>{class n extends _V{constructor(e){super(e||{})}call(e,r){return te(()=>{const s=yt(e);return Vn(s,1)})}}return n.className="GlobalAveragePooling1D",n})()),ge((()=>{class n extends _V{constructor(e){super(e||{})}call(e,r){return te(()=>{const s=yt(e);return go(s,1)})}}return n.className="GlobalMaxPooling1D",n})());class vV extends Pt{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,zn(this.dataFormat),this.inputSpec=[new sr({ndim:4})]}computeOutputShape(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new ft}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}ge((()=>{class n extends vV{call(e,r){return te(()=>{const s=yt(e);return Vn(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})()),ge((()=>{class n extends vV{call(e,r){return te(()=>{const s=yt(e);return go(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})());class bV extends Pt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,r={}){const i=wo(e.layer,r);delete e.layer;const o={layer:i};return Object.assign(o,e),new t(o)}}var SV;function ze(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}ge((()=>{class n extends bV{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Gt(e)).length<3)throw new L(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=Gt(e))[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(r);return[s[0],e[1]].concat(s.slice(1))}call(e,r){return te(()=>lV((a,l)=>[yt(this.layer.call(a,r)),[]],e=yt(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})()),ge((()=>{class n extends bV{constructor(e){super(e);const r=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=r,this.forwardLayer=wo(s),r.goBackwards=!0!==r.goBackwards;const i={};if(i.className=e.layer.getClassName(),i.config=r,this.backwardLayer=wo(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function xde(n){Wl(Bce,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new ft("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const s=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let s,i,o,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r,this.returnState&&(o=r.slice(1)),s=r[0],s=s,"concat"===this.mergeMode?(s[s.length-1]*=2,i=[s]):i=null==this.mergeMode?[s,s.slice()]:[s],this.returnState?null==this.mergeMode?i.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):ls(i)}apply(e,r){let s=null==r?null:r.initialState,i=null==r?null:r.constants;null==r&&(r={});const o=aV(e,s,i,this.numConstants);if(e=o.inputs,s=o.initialState,i=o.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(null==s||0===s.length)&&null==i)return super.apply(e,r);const a=[],l=[];if(null!=s){const u=s.length;if(u%2>0)throw new L("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=s,a.push(...s);const d=s.map(h=>new sr({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,u/2),this.backwardLayer.stateSpec=d.slice(u/2),l.push(...d)}if(null!=i)throw new ft("Support for constants in Bidirectional layers is not implemented yet.");const c=a[0]instanceof xo;for(const u of a)if(u instanceof xo!==c)throw new L("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const u=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(u,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return te(()=>{const s=r.initialState;let i,o,a,l;if(null==s)i=this.forwardLayer.call(e,r),o=this.backwardLayer.call(e,r);else{const c=s.slice(0,s.length/2),u=s.slice(s.length/2);i=this.forwardLayer.call(e,Object.assign(r,{initialState:c})),o=this.backwardLayer.call(e,Object.assign(r,{initialState:u}))}return this.returnState&&(Array.isArray(i)&&(a=i.slice(1).concat(o.slice(1))),i=i[0],o=o[0]),this.returnSequences&&(o=Vl(o,1)),"concat"===this.mergeMode?l=iE([i,o]):"sum"===this.mergeMode?l=we(i,o):"ave"===this.mergeMode?l=P(.5,we(i,o)):"mul"===this.mergeMode?l=P(i,o):null==this.mergeMode&&(l=[i,o]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Gl(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Gl(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let s;if(Array.isArray(r)&&(r=r[0]),s=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const o=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const s=wo(r.layer);if(delete r.layer,null!=r.numConstants)throw new ft("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=r;return i.layer=s,new e(i)}}return n.className="Bidirectional",n})()),ae().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(SV||(SV={})),U(340),Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const che=L$;let uhe=(()=>{class n extends rC{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new vP(this,Na())}nextDataId(){return n.nextDataId++}write(e,r,s){this.firstUse&&(this.firstUse=!1,ae().get("IS_NODE")&&Vs("\n============================\nHi there \u{1f44b}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:s,refCount:1}),i}makeTensorInfo(e,r,s){let i;if("string"===r&&null!=s&&s.length>0&&Nh(s[0])){const o=s.map(a=>Ta(a));i=this.write(o,e,r)}else i=this.write(s,e,r);return{dataId:i,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,i,o){this.data.set(e,{values:r,dtype:i,refCount:o})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return he(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);return"complex64"===r?Zo(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.data.get(e).values}bufferSync(e){const r=this.readSync(e.dataId);let s=r;if("string"===e.dtype)try{s=r.map(i=>pu(i))}catch(i){throw new Error("Failed to decode encoded string bytes into utf-8")}return Nt(e.shape,e.dtype,s)}makeOutput(e,r,s){const i=this.write(e,r,s);return Na().makeTensorFromDataId(i,r,s,this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return he(function*(){const r=as();return e(),{kernelMs:as()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){ze([e],"where");const r=this.readSync(e.dataId);return che(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function qt(n,t,e){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;if(ze(o,n),"string"===o.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(o.dataId).values,c=ce(o.shape),u=e||o.dtype,d=os(u,c);for(let h=0;h<c;++h)d[h]=t(l[h],s);return a.makeTensorInfo(o.shape,u,d)}}function Lu(n,t,e){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;if(ze(o,n),"string"===o.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(o.dataId).values,c=e||o.dtype,u=t(l,c,s);return a.makeTensorInfo(o.shape,c,u)}}P2("cpu",()=>new uhe,1);const tB=qt(Gh,n=>n>=0?n:Math.exp(n)-1),hhe={kernelName:Gh,backendName:"cpu",kernelFunc:tB};function Do(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const fhe={kernelName:Jh,backendName:"cpu",kernelFunc:Do};function nB(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:i}=r;ze([s],"leakyRelu");const o=ce(s.shape),a=e.data.get(s.dataId).values,l=Sr("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?i*a[c]:a[c];return e.makeTensorInfo(s.shape,"float32",l)}const phe={kernelName:dy,backendName:"cpu",kernelFunc:nB};function Kn(n){return(t,e,r,s,i)=>{const o=gt(t,e),a=o.length,l=Je(o),u=Sr(i,ce(o)),d=t.length,h=e.length,f=Je(t),p=Je(e),m=xu(t,o),g=xu(e,o);if(m.length+g.length===0)for(let _=0;_<u.length;++_)u[_]=n(r[_%r.length],s[_%s.length]);else for(let _=0;_<u.length;++_){const y=Rh(_,a,l),v=y.slice(-d);m.forEach(E=>v[E]=0);const b=ho(v,d,f),w=y.slice(-h);g.forEach(E=>w[E]=0);const C=ho(w,h,p);u[_]=n(r[b],s[C])}return[u,o]}}const mhe=Kn((n,t)=>n<0?t*n:n);function rB(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t;ze([r,s],"prelu");const i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,[a,l]=mhe(r.shape,s.shape,i,o,"float32");return e.makeTensorInfo(l,"float32",a)}const ghe={kernelName:Ny,backendName:"cpu",kernelFunc:rB},sB=qt(pf,n=>Math.max(0,n)),yhe={kernelName:pf,backendName:"cpu",kernelFunc:sB},iB=qt(mf,n=>Math.min(Math.max(0,n),6)),_he={kernelName:mf,backendName:"cpu",kernelFunc:iB};function Wa(n){return(t,e,r)=>{const s=Sr(e,t.length);for(let i=0;i<t.length;++i)s[i]=n(t[i],r);return s}}const vhe=Wa(n=>1/(1+Math.exp(-n))),oB=qt(wf,n=>1/(1+Math.exp(-n))),bhe={kernelName:wf,backendName:"cpu",kernelFunc:oB};function JE(n,t,e,r,s){if("linear"===e)return Do({inputs:{x:t},backend:n});if("relu"===e)return sB({inputs:{x:t},backend:n});if("elu"===e)return tB({inputs:{x:t},backend:n});if("relu6"===e)return iB({inputs:{x:t},backend:n});if("prelu"===e)return rB({inputs:{x:t,alpha:r},backend:n});if("leakyrelu"===e)return nB({inputs:{x:t},backend:n,attrs:{alpha:s}});if("sigmoid"===e)return oB({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function ws(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",i),imag:e.makeTensorInfo(s.shape,"float32",o)},a}const xhe={kernelName:vC,backendName:"cpu",kernelFunc:ws};function sv(n,t,e="float32"){if("complex64"===e)return ws({inputs:{real:sv(n,t,"float32"),imag:sv(n,t,"float32")},backend:n});const r=Pr(ce(t),e);return n.makeTensorInfo(t,e,r)}function Xl(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.real,i=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,i)}const whe={kernelName:jC,backendName:"cpu",kernelFunc:Xl};function Ga(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return Do({inputs:{x:s},backend:e});const o=sv(e,s.shape,s.dtype),a=Ga({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=ws({inputs:{real:a,imag:o},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const o=Xl({inputs:{input:s},backend:e}),a=Ga({inputs:{x:o},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(o),a}if(!DP(s.dtype,i)){const o=Do({inputs:{x:s},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:i}}if("int32"===i){const o=e.data.get(s.dataId).values,a=Int32Array.from(o);return e.makeTensorInfo(s.shape,"int32",a)}if("bool"===i){const o=e.data.get(s.dataId).values,a=Rl([0],s.dtype),[l,c]=Kn((u,d)=>u!==d?1:0)(s.shape,[],o,a,"bool");return e.makeTensorInfo(c,"bool",l)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}const Che={kernelName:Bh,backendName:"cpu",kernelFunc:Ga};function br(n,t,e,r){return null==e?({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;ze([o,a],n);const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,d="string"===o.dtype?Ul(c):c,h="string"===o.dtype?Ul(u):u,f=r||o.dtype,[p,m]=t(o.shape,a.shape,d,h,f);return l.makeTensorInfo(m,f,p)}:({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;if("complex64"===o.dtype||"complex64"===a.dtype){const c=Ga({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.imag,f=l.data.get(u.complexTensorInfos.real.dataId).values,p=l.data.get(h.dataId).values,m=Ga({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.imag,v=l.data.get(g.complexTensorInfos.real.dataId).values,b=l.data.get(y.dataId).values,[w,C,E]=e(o.shape,a.shape,f,p,v,b),k=l.makeTensorInfo(E,"float32",w),M=l.makeTensorInfo(E,"float32",C),O=ws({inputs:{real:k,imag:M},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(k),l.disposeIntermediateTensorInfo(M),O}{const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,d=r||o.dtype,[h,f]=t(o.shape,a.shape,c,u,d);return l.makeTensorInfo(f,d,h)}}}function eI(n){return(t,e,r,s,i,o)=>{const a=gt(t,e),l=ce(a),c=a.length,u=Je(a),d=Sr("float32",l),h=Sr("float32",l),f=xu(t,a),p=xu(e,a),m=Zo(r,s),g=Zo(i,o),_=t.length,y=Je(t),v=e.length,b=Je(e);if(f.length+p.length===0)for(let w=0;w<d.length;w++){const C=w%m.length,E=w%g.length,k=n(m[2*C],m[2*C+1],g[2*E],g[2*E+1]);d[w]=k.real,h[w]=k.imag}else for(let w=0;w<d.length;w++){const C=Rh(w,c,u),E=C.slice(-_);f.forEach(X=>E[X]=0);const k=ho(E,_,y),M=C.slice(-v);p.forEach(X=>M[X]=0);const O=ho(M,v,b),K=n(m[2*k],m[2*k+1],g[2*O],g[2*O+1]);d[w]=K.real,h[w]=K.imag}return[d,h,a]}}const aB=Kn((n,t)=>n+t),Dhe=eI((n,t,e,r)=>({real:n+e,imag:t+r})),lp=br(hu,aB,Dhe),She={kernelName:hu,backendName:"cpu",kernelFunc:lp};function bn(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:i}=r,o=ce(s.shape),a=CP(i,o),l=ce(a);S(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const c=e.data.get(s.dataId);if(null!=c.complexTensorInfos){const d=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const Ehe={kernelName:Ay,backendName:"cpu",kernelFunc:bn};function lB(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i}=t,{transposeA:o,transposeB:a}=r;ze([s,i],"matMul");const l=s.shape.length,c=i.shape.length,u=o?s.shape[l-2]:s.shape[l-1],d=a?i.shape[c-1]:i.shape[c-2],h=o?s.shape[l-1]:s.shape[l-2],f=a?i.shape[c-2]:i.shape[c-1],p=s.shape.slice(0,-2),m=i.shape.slice(0,-2),g=ce(p),_=ce(m),v=gt(s.shape.slice(0,-2),i.shape.slice(0,-2)).concat([h,f]);S(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const w=a?[_,f,d]:[_,d,f],C=bn({inputs:{x:s},backend:e,attrs:{shape:o?[g,u,h]:[g,h,u]}}),E=bn({inputs:{x:i},backend:e,attrs:{shape:w}}),k=o?C.shape[1]:C.shape[2],M=o?C.shape[2]:C.shape[1],O=a?E.shape[1]:E.shape[2],K=Math.max(g,_),X=e.data.get(C.dataId).values,Q=e.data.get(E.dataId).values,re=Je(C.shape),ne=Je(E.shape),[V,G,W]=o?[re[0],1,re[1]]:[re[0],re[1],1],[J,ue,me]=a?[1,ne[1],ne[0]]:[ne[1],1,ne[0]],De=M*O,be=Nt([K,M,O],C.dtype),Se=be.values,Ie=e.blockSize;for(let $e=0;$e<K;$e++)for(let Ae=0;Ae<M;Ae+=Ie)for(let qe=0;qe<O;qe+=Ie)for(let Ke=0;Ke<k;Ke+=Ie){const ot=Math.min(Ae+Ie,M),vt=Math.min(qe+Ie,O),Kt=Math.min(Ke+Ie,k);for(let cn=Ae;cn<ot;cn++)for(let pn=qe;pn<vt;pn++){let xn=0;for(let Qt=Ke;Qt<Kt;Qt++){const Mn=Math.min($e,g-1)*V,Un=Math.min($e,_-1)*me;xn+=X[Mn+cn*G+Qt*W]*Q[Qt*J+pn*ue+Un]}Se[$e*De+(cn*O+pn)]+=xn}}return e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(E),e.makeTensorInfo(v,be.dtype,be.values)}const Ihe={kernelName:Yg,backendName:"cpu",kernelFunc:lB},khe={kernelName:Wy,backendName:"cpu",kernelFunc:function The(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;let h,f,p;const m=[];h=lB({inputs:{a:s,b:i},attrs:{transposeA:l,transposeB:c},backend:e}),o&&(f=lp({inputs:{a:h,b:o},backend:e}),m.push(h),h=f),u&&(p=JE(e,h,u,a,d),m.push(h),h=p);for(const _ of m)e.disposeIntermediateTensorInfo(_);return h}};function cB(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const Nhe={kernelName:Wg,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;ze(t,"abs");let r=new Float32Array(ce(t.shape));return r=cB(e.data.get(t.dataId).values),e.makeOutput(r,t.shape,t.dtype)}},Ahe=qt(Mh,n=>Math.acos(n)),Rhe={kernelName:Mh,backendName:"cpu",kernelFunc:Ahe},Mhe=qt(Oh,n=>Math.acosh(n)),Ohe={kernelName:Oh,backendName:"cpu",kernelFunc:Mhe},Phe={kernelName:fC,backendName:"cpu",kernelFunc:function Fhe(n){const{inputs:t,backend:e}=n,r=t;ze(t,"addN");const s=r.map(a=>e.data.get(a.dataId).values),i=Nt(r[0].shape,r[0].dtype),o=i.values;for(let a=0;a<r.length;a++){const l=s[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return e.makeTensorInfo(i.shape,i.dtype,i.values)}};function tI(n,t,e,r,s){const i=t.length,o=ce(t),a=Je(t),l=Je(s),c=Sr(e,ce(s));for(let u=0;u<o;++u){const d=Rh(u,i,a),h=new Array(d.length);for(let p=0;p<h.length;p++)h[p]=d[r[p]];c[ho(h,i,l)]=n[u]}return c}function us(n){const{inputs:t,attrs:e,backend:r}=n,{x:s}=t,{perm:i}=e;ze(s,"transpose");const a=new Array(s.shape.length);for(let d=0;d<a.length;d++)a[d]=s.shape[i[d]];const c=tI(r.data.get(s.dataId).values,s.shape,s.dtype,i,a);return{dataId:r.write(c,a,s.dtype),shape:a,dtype:s.dtype}}const $he={kernelName:zy,backendName:"cpu",kernelFunc:us},Vhe={kernelName:"All",backendName:"cpu",kernelFunc:function Lhe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;ze(s,"all");const a=It(i,s.shape);let l=a;const c=Sn(l,s.shape.length);let u=s;null!=c&&(u=us({inputs:{x:s},backend:e,attrs:{perm:c}}),l=An(l.length,s.shape.length)),Ir("all",l,u.shape.length);const[d,h]=yr(u.shape,l),f=ce(h),p=Pr(ce(d),u.dtype),m=e.data.get(u.dataId).values;for(let _=0;_<p.length;++_){const y=_*f;let v=m[y];for(let b=0;b<f;++b){const w=m[y+b];v=v&&w}p[_]=v}null!=c&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(d,u.dtype,p);if(o){const y=bn({inputs:{x:g},backend:e,attrs:{shape:Bn(d,a)}});return e.disposeIntermediateTensorInfo(g),y}return g}},zhe={kernelName:"Any",backendName:"cpu",kernelFunc:function Bhe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;ze(s,"any");const a=It(i,s.shape);let l=a;const c=Sn(l,s.shape.length);let u=s;null!=c&&(u=us({inputs:{x:s},backend:e,attrs:{perm:c}}),l=An(l.length,s.shape.length)),Ir("any",l,u.shape.length);const[d,h]=yr(u.shape,l),f=ce(h),p=Pr(ce(d),u.dtype),m=e.data.get(u.dataId).values;for(let _=0;_<p.length;++_){const y=_*f;let v=m[y];for(let b=0;b<f;++b){const w=m[y+b];v=v||w}p[_]=v}null!=c&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(d,u.dtype,p);if(o){const y=bn({inputs:{x:g},backend:e,attrs:{shape:Bn(d,a)}});return e.disposeIntermediateTensorInfo(g),y}return g}},Hhe={kernelName:Gg,backendName:"cpu",kernelFunc:function Uhe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;ze(s,"argMax");let o=It(i,s.shape);const a=Sn(o,s.shape.length);let l=s;const c=[];null!=a&&(l=us({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=An(o.length,l.shape.length)),o=[o[0]],Ir("argMax",o,l.shape.length);const[u,d]=yr(l.shape,o),f=Pr(ce(u),"int32"),p=ce(d),m=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const _=g*p;let y=m[_],v=0;for(let b=0;b<p;++b){const w=m[_+b];w>y&&(y=w,v=b)}f[g]=v}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(u,"int32",f)}},Whe={kernelName:qg,backendName:"cpu",kernelFunc:function jhe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;ze(s,"argMin");let o=It(i,s.shape);const a=Sn(o,s.shape.length);let l=s;const c=[];null!=a&&(l=us({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=An(o.length,l.shape.length)),o=[o[0]],Ir("argMin",o,l.shape.length);const[u,d]=yr(l.shape,o),f=Pr(ce(u),"int32"),p=ce(d),m=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const _=g*p;let y=m[_],v=0;for(let b=0;b<p;++b){const w=m[_+b];w<y&&(y=w,v=b)}f[g]=v}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(u,"int32",f)}},Ghe=qt(Fh,n=>Math.asin(n)),qhe={kernelName:Fh,backendName:"cpu",kernelFunc:Ghe},Khe=qt(Ph,n=>Math.asinh(n)),Xhe={kernelName:Ph,backendName:"cpu",kernelFunc:Khe},Yhe=qt($h,n=>Math.atan(n)),Zhe={kernelName:$h,backendName:"cpu",kernelFunc:Yhe},Qhe=Kn((n,t)=>Math.atan2(n,t)),Jhe=br(Vh,Qhe),efe={kernelName:Vh,backendName:"cpu",kernelFunc:Jhe},tfe=qt(Lh,n=>Math.atanh(n)),nfe={kernelName:Lh,backendName:"cpu",kernelFunc:tfe};function nI(n,t,e,r,s,i){const o=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,u=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,f=s.padInfo.left,p="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Nt(s.outShape,e),g=m.values,_=s.outShape[1]*s.outShape[2]*s.outShape[3],y=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let b=0;b<s.batchSize;++b){const w=b*_,C=b*r[0];for(let E=0;E<s.inChannels;++E)for(let k=0;k<s.outHeight;++k){const M=k*o-h,O=Math.max(0,M),K=Math.min(s.inHeight,u+M),X=w+k*y;for(let Q=0;Q<s.outWidth;++Q){const re=Q*a-f,ne=Math.max(0,re),V=Math.min(s.inWidth,d+re);let G=p,W=0,J=0;for(let me=O;me<K;me+=l){const De=C+me*r[1];for(let be=ne;be<V;be+=c){const Ie=n[De+be*r[2]+E];"max"===i&&Ie>G?G=Ie:"avg"===i&&(W+=Ie,J++)}if(isNaN(G))break}g[X+Q*v+E]="avg"===i?W/J:G}}}return m}function uB(n,t,e,r,s=!1,i=!1){const o=Nt(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,f=r.padInfo.top,p=r.padInfo.left,m=Nt(t,e,n);for(let g=0;g<r.batchSize;++g)for(let _=0;_<r.inChannels;++_)for(let y=0;y<r.outHeight;++y){const v=y*a-f;let b=v;for(;b<0;)b+=c;const w=Math.min(r.inHeight,d+v);for(let C=0;C<r.outWidth;++C){const E=C*l-p;let k=E;for(;k<0;)k+=u;const M=Math.min(r.inWidth,h+E);let O=Number.NEGATIVE_INFINITY,K=-1;for(let X=b;X<w;X+=c){const Q=X-v;for(let re=k;re<M;re+=u){const ne=re-E,V=m.get(g,X,re,_);V>O&&(O=V,K=s?i?((g*r.inHeight+X)*r.inWidth+re)*r.inChannels+_:(X*r.inWidth+re)*r.inChannels+_:Q*h+ne)}}o.set(K,g,y,C,_)}}return o}function dB(n,t,e,r,s,i){const o=s.strideDepth,a=s.strideHeight,l=s.strideWidth,c=s.dilationDepth,u=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,f=s.effectiveFilterHeight,p=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,_=s.padInfo.left,y="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Nt(s.outShape,e),b=v.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],C=s.outShape[2]*s.outShape[3]*s.outShape[4],E=s.outShape[3]*s.outShape[4],k=s.outShape[4];for(let M=0;M<s.batchSize;++M){const O=M*w,K=M*r[0];for(let X=0;X<s.inChannels;++X)for(let Q=0;Q<s.outDepth;++Q){const re=Q*o-m;let ne=re;for(;ne<0;)ne+=c;const V=Math.min(s.inDepth,h+re),G=O+Q*C;for(let W=0;W<s.outHeight;++W){const J=W*a-g;let ue=J;for(;ue<0;)ue+=u;const me=Math.min(s.inHeight,f+J),De=G+W*E;for(let be=0;be<s.outWidth;++be){const Se=be*l-_;let Ie=Se;for(;Ie<0;)Ie+=d;const $e=Math.min(s.inWidth,p+Se),Ae=De+be*k;let qe=y,Ke=0,ot=0;for(let Kt=ne;Kt<V;Kt+=c){const cn=K+Kt*r[1];for(let pn=ue;pn<me;pn+=u){const xn=cn+pn*r[2];for(let Qt=Ie;Qt<$e;Qt+=d){const Un=n[xn+Qt*r[3]+X];if("max"===i&&Un>qe?qe=Un:"avg"===i&&(Ke+=Un,ot++),isNaN(qe))break}if(isNaN(qe))break}if(isNaN(qe))break}b[Ae+X]="avg"===i?Ke/ot:qe}}}}return v}const ife={kernelName:Kg,backendName:"cpu",kernelFunc:function sfe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;ze(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Er(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=ui(s.shape,i,o,1,a,l);let d;if(1===u.filterWidth&&1===u.filterHeight&&Ut(u.inShape,u.outShape))d=Do({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Je(s.shape),p=nI(h,0,s.dtype,f,u,"avg");d=e.makeTensorInfo(u.outShape,s.dtype,p.values)}return d}},afe={kernelName:Xg,backendName:"cpu",kernelFunc:function ofe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;ze(s,"avgPool3d");const u=Go(s.shape,i,o,1,a,l,c),h=dB(e.data.get(s.dataId).values,0,s.dtype,Je(s.shape),u,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},cfe={kernelName:yC,backendName:"cpu",kernelFunc:function lfe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;ze([s,i],"avgPool3DGrad");const u=Go(i.shape,o,a,1,l,c),d=u.strideDepth,h=u.strideHeight,f=u.strideWidth,p=u.filterDepth,m=u.filterHeight,g=u.filterWidth,_=u.dilationDepth,y=u.dilationHeight,v=u.dilationWidth,b=u.effectiveFilterDepth,w=u.effectiveFilterHeight,C=u.effectiveFilterWidth,E=b-1-u.padInfo.front,k=C-1-u.padInfo.left,M=w-1-u.padInfo.top,O=Nt(i.shape,"float32"),K=1/(p*m*g),X=e.bufferSync(s);for(let Q=0;Q<u.batchSize;++Q)for(let re=0;re<u.inChannels;++re)for(let ne=0;ne<u.inDepth;++ne)for(let V=0;V<u.inHeight;++V)for(let G=0;G<u.inWidth;++G){const W=ne-E,J=V-M,ue=G-k;let me=0;for(let De=0;De<b;De+=_){const be=(W+De)/d;if(!(be<0||be>=u.outDepth||Math.floor(be)!==be))for(let Se=0;Se<w;Se+=y){const Ie=(J+Se)/h;if(!(Ie<0||Ie>=u.outHeight||Math.floor(Ie)!==Ie))for(let $e=0;$e<C;$e+=v){const Ae=(ue+$e)/f;Ae<0||Ae>=u.outWidth||Math.floor(Ae)!==Ae||(me+=X.get(Q,be,Ie,Ae,re))}}}O.set(me*K,Q,ne,V,G,re)}return e.makeTensorInfo(O.shape,O.dtype,O.values)}},dfe={kernelName:gC,backendName:"cpu",kernelFunc:function ufe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i;ze([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=ui(o.shape,a,l,1,c),d=u.strideHeight,h=u.strideWidth,f=u.filterHeight,p=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,_=u.effectiveFilterHeight,y=u.effectiveFilterWidth,v=y-1-u.padInfo.left,b=_-1-u.padInfo.top,w=Nt(o.shape,"float32"),C=1/(f*p),E=e.data.get(s.dataId).values,k=Nt(s.shape,"float32",E);for(let M=0;M<u.batchSize;++M)for(let O=0;O<u.inChannels;++O)for(let K=0;K<u.inHeight;++K)for(let X=0;X<u.inWidth;++X){const Q=K-b,re=X-v;let ne=0;for(let V=0;V<_;V+=m){const G=(Q+V)/d;if(!(G<0||G>=u.outHeight||Math.floor(G)!==G))for(let W=0;W<y;W+=g){const J=(re+W)/h;J<0||J>=u.outWidth||Math.floor(J)!==J||(ne+=k.get(M,G,J,O))}}w.set(ne*C,M,K,X,O)}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},ffe={kernelName:ly,backendName:"cpu",kernelFunc:function hfe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,scale:i,offset:o,mean:a,variance:l}=t;S(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ze([s,a,l,i,o],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const u=e.data.get(s.dataId).values,d=e.data.get(a.dataId).values,h=e.data.get(l.dataId).values,f=i?e.data.get(i.dataId).values:new Float32Array([1]),p=o?e.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=p.length,_=f.length,y=h.length,v=d.length;let b=0,w=0,C=0,E=0;for(let k=0;k<u.length;++k)m[k]=p[b++]+(u[k]-d[w++])*f[C++]/Math.sqrt(h[E++]+c),b>=g&&(b=0),w>=v&&(w=0),C>=_&&(C=0),E>=y&&(E=0);return e.makeTensorInfo(s.shape,s.dtype,m)}};function hB(n,t,e,r,s){const i=VD(r,t,e),o=ce(e),a=Je(r);if(i){const d=BD(t,a);return"string"===s?n.slice(d,d+o):n.subarray(d,d+o)}const c=Nt(r,s,"string"===s?Ul(n):n),u=Nt(e,s);for(let d=0;d<u.size;++d){const h=u.indexToLoc(d),f=h.map((p,m)=>p+t[m]);u.set(c.get(...f),...h)}return"string"===s?$$(u.values):u.values}function Yl(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,size:o}=r;ze(s,"slice");const[a,l]=a_(s,i,o);$D(s,a,l);const u=hB(e.data.get(s.dataId).values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,u)}const pfe={kernelName:Py,backendName:"cpu",kernelFunc:Yl},gfe={kernelName:Zg,backendName:"cpu",kernelFunc:function mfe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,crops:o}=r;ze([s],"batchToSpaceND");const a=i.reduce((_,y)=>_*y),l=jf(s.shape,i,a),c=Wf(l.length,i.length),u=Gf(s.shape,i,a),d=NS(o,i.length),h=AS(u,o,i.length),f=bn({inputs:{x:s},backend:e,attrs:{shape:l}}),p=us({inputs:{x:f},backend:e,attrs:{perm:c}}),m=bn({inputs:{x:p},backend:e,attrs:{shape:u}}),g=Yl({inputs:{x:m},backend:e,attrs:{begin:d,size:h}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}};function rI(n,t,e,r,s){const i=ce(r),o=Pr(s,e);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(o[l]+=i>0?t[a]:1)}return o}function fB(n,t,e,r=!1){const s=n.shape[0],i=n.shape[1],o=Nt([s,e],t.dtype);for(let a=0;a<s;a++)for(let l=0;l<i;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=e||o.set(r?1:t.size>0?o.get(a,c)+t.get(a,l):o.get(a,c)+1,a,c)}return o}const _fe={kernelName:_C,backendName:"cpu",kernelFunc:function yfe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o}=r,c=rI(e.data.get(s.dataId).values,e.data.get(i.dataId).values,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}},bfe={kernelName:RP,backendName:"cpu",kernelFunc:function vfe(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,a=gt(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},pB=Wa(n=>Math.ceil(n)),xfe=Lu(zh,pB),wfe={kernelName:zh,backendName:"cpu",kernelFunc:xfe},Cfe=qt(Uh,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),Dfe={kernelName:Uh,backendName:"cpu",kernelFunc:Cfe},Sfe={kernelName:Qg,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,r=new Float32Array(ce(t.shape)),s=e.data.get(t.dataId),o=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(o.dataId).values;for(let c=0;c<a.length;c++)r[c]=Math.hypot(a[c],l[c]);return e.makeOutput(r,t.shape,"float32")}};function mB(n,t,e,r){const s=os(e,ce(t));if(r&&"string"!==e){let i=0;n.forEach(o=>{const a=ce(o.shape);s.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a="string"===e?Ul(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*t[1]+i;for(let d=0;d<o.shape[1];++d)s[u+d]=a[l++]}i+=o.shape[1]})}return s}function Vu(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.imag,i=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,i)}const Efe={kernelName:FC,backendName:"cpu",kernelFunc:Vu};function Bu(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,i=It(s,t[0].shape)[0];let o=yo(t.map(m=>m.shape),i);if(0===ce(o))return e.makeTensorInfo(o,t[0].dtype,[]);const a=t.filter(m=>ce(m.shape)>0);if(1===a.length)return Do({inputs:{x:a[0]},backend:e});if(IS(a.map(m=>m.shape),i),"complex64"===a[0].dtype){const m=a.map(b=>Xl({inputs:{input:b},backend:e})),g=a.map(b=>Vu({inputs:{input:b},backend:e})),_=Bu({inputs:m,backend:e,attrs:{axis:i}}),y=Bu({inputs:g,backend:e,attrs:{axis:i}}),v=ws({inputs:{real:_,imag:y},backend:e});return m.forEach(b=>e.disposeIntermediateTensorInfo(b)),g.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(y),v}const c=a.map(m=>{const g=ce(m.shape.slice(i));return bn({inputs:{x:m},backend:e,attrs:{shape:[-1,g]}})}),u=c.map(m=>({vals:e.data.get(m.dataId).values,shape:m.shape}));o=yo(c.map(m=>m.shape),1);const h=mB(u,o,t[0].dtype,1===c[0].shape[0]),f=yo(a.map(m=>m.shape),i),p=e.makeTensorInfo(f,t[0].dtype,h);return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}const Ife={kernelName:Jg,backendName:"cpu",kernelFunc:Bu};function gB(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r;ze([s,i],"conv2d");const d=qo(l),h=gr(s.shape,i.shape,o,c,a,u,!1,d),f=h.filterHeight,p=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,_=h.padInfo.left,y=h.padInfo.top,v="channelsLast"===h.dataFormat,b=new $r(h.outShape,s.dtype),w=Je(s.shape),C=Je(i.shape),E=w[0],k=v?w[1]:w[2],M=v?w[2]:1,O=v?1:w[1],K=b.strides[0],X=v?b.strides[1]:b.strides[2],Q=v?b.strides[2]:1,re=v?1:b.strides[1],ne=e.data.get(s.dataId).values,V=e.data.get(i.dataId).values,G=b.values;for(let W=0;W<h.batchSize;++W){const J=W*E,ue=W*K;for(let me=0;me<h.outHeight;++me){const De=ue+me*X,be=me*h.strideHeight-y;for(let Se=0;Se<f;++Se){const Ie=be+Se*m;if(Ie<0||Ie>=h.inHeight)continue;const $e=Se*C[0],Ae=J+Ie*k;for(let qe=0;qe<h.outWidth;++qe){const Ke=De+qe*Q,ot=qe*h.strideWidth-_;for(let vt=0;vt<p;++vt){const Kt=ot+vt*g;if(Kt<0||Kt>=h.inWidth)continue;const pn=Ae+Kt*M;let xn=$e+vt*C[1];for(let Qt=0;Qt<h.inChannels;++Qt){const Mn=ne[pn+Qt*O];for(let Un=0;Un<h.outChannels;++Un)G[Ke+Un*re]+=Mn*V[xn+Un];xn+=h.outChannels}}}}}}return e.makeTensorInfo(b.shape,b.dtype,G)}const Tfe={kernelName:ey,backendName:"cpu",kernelFunc:gB},Nfe={kernelName:bC,backendName:"cpu",kernelFunc:function kfe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;ze([s,i],"conv2dBackpropFilter");const d=qo(l),h=gr(s.shape,u,o,1,a,c,!1,d),{strideHeight:f,strideWidth:p,filterHeight:m,filterWidth:g}=h,_="channelsLast"===h.dataFormat,y=new $r(h.filterShape,"float32"),v=h.padInfo.left,b=h.padInfo.top,w=e.data.get(s.dataId).values,C=e.data.get(i.dataId).values,E=new $r(s.shape,s.dtype,w),k=new $r(i.shape,i.dtype,C);for(let M=0;M<m;++M){const O=Math.max(0,Math.ceil((b-M)/f)),K=Math.min(h.outHeight,(h.inHeight+b-M)/f);for(let X=0;X<g;++X){const Q=Math.max(0,Math.ceil((v-X)/p)),re=Math.min(h.outWidth,(h.inWidth+v-X)/p);for(let ne=0;ne<h.inChannels;++ne)for(let V=0;V<h.outChannels;++V){let G=0;for(let W=0;W<h.batchSize;++W)for(let J=O;J<K;++J){const ue=M+J*f-b;for(let me=Q;me<re;++me){const De=X+me*p-v;G+=_?E.get(W,ue,De,ne)*k.get(W,J,me,V):E.get(W,ne,ue,De)*k.get(W,V,J,me)}}y.set(G,M,X,ne,V)}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},Rfe={kernelName:ty,backendName:"cpu",kernelFunc:function Afe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r;ze([s,i],"conv2dBackpropInput");const d=Je(i.shape),h=Je(s.shape);let f=qo(c);const p=gr(o,i.shape,a,1,l,u,!1,f),m=new $r(p.inShape,"float32"),g=m.values,_=e.data.get(s.dataId).values,y=e.data.get(i.dataId).values,[v,b,w]=d,{batchSize:C,filterHeight:E,filterWidth:k,inChannels:M,inHeight:O,inWidth:K,outChannels:X,outHeight:Q,outWidth:re,strideHeight:ne,strideWidth:V}=p;f=p.dataFormat;const G=E-1-p.padInfo.top,W=k-1-p.padInfo.left,J="channelsLast"===f,ue=m.strides[0],me=J?m.strides[1]:m.strides[2],De=J?m.strides[2]:1,be=J?1:m.strides[1],Se=h[0],Ie=J?h[1]:h[2],$e=J?h[2]:1,Ae=J?1:h[1];for(let qe=0;qe<C;++qe)for(let Ke=0;Ke<M;++Ke)for(let ot=0;ot<O;++ot){const vt=ot-G,Kt=Math.max(0,Math.ceil(vt/ne)),cn=Math.min(Q,(E+vt)/ne);for(let pn=0;pn<K;++pn){const xn=pn-W,Qt=Math.max(0,Math.ceil(xn/V)),Mn=Math.min(re,(k+xn)/V);let Un=0;for(let Nr=Kt;Nr<cn;++Nr){const Xa=Nr*ne-vt;for(let Gs=Qt;Gs<Mn;++Gs){const qi=Se*qe+Ie*Nr+$e*Gs,na=v*(E-1-Xa)+b*(k-1-(Gs*V-xn))+w*Ke;for(let Ya=0;Ya<X;++Ya)Un+=_[qi+Ae*Ya]*y[na+Ya]}}g[ue*qe+me*ot+De*pn+be*Ke]=Un}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},Ofe={kernelName:ny,backendName:"cpu",kernelFunc:function Mfe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=r;ze([s,i],"conv3d");const c=Ra(s.shape,i.shape,o,l,a),{filterDepth:u,filterHeight:d,filterWidth:h,dilationDepth:f,dilationHeight:p,dilationWidth:m,padInfo:g}=c,_=g.front,y=g.left,v=g.top,b=new $r(c.outShape,s.dtype),w=e.data.get(s.dataId).values,C=e.data.get(i.dataId).values,E=b.values,k=Je(s.shape),M=Je(i.shape);for(let O=0;O<c.batchSize;++O){const K=O*k[0],X=O*b.strides[0];for(let Q=0;Q<c.outDepth;++Q){const re=X+Q*b.strides[1],ne=Q*c.strideDepth-_;for(let V=0;V<u;++V){const G=ne+V*f;if(G<0||G>=c.inDepth)continue;const W=V*M[0],J=K+G*k[1];for(let ue=0;ue<c.outHeight;++ue){const me=re+ue*b.strides[2],De=ue*c.strideHeight-v;for(let be=0;be<d;++be){const Se=De+be*p;if(Se<0||Se>=c.inHeight)continue;const Ie=W+be*M[1],$e=J+Se*k[2];for(let Ae=0;Ae<c.outWidth;++Ae){const qe=me+Ae*c.outChannels,Ke=Ae*c.strideWidth-y;for(let ot=0;ot<h;++ot){const vt=Ke+ot*m;if(vt<0||vt>=c.inWidth)continue;const cn=$e+vt*c.inChannels;let pn=Ie+ot*M[2];for(let xn=0;xn<c.inChannels;++xn){const Qt=w[cn+xn];for(let Mn=0;Mn<c.outChannels;++Mn)E[qe+Mn]+=Qt*C[pn+Mn];pn+=c.outChannels}}}}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},Pfe={kernelName:xC,backendName:"cpu",kernelFunc:function Ffe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,filterShape:l}=r;ze([s,i],"conv3dBackpropFilterV2");const c=Je(s.shape),u=Je(i.shape),d=Ra(s.shape,l,o,1,a),h=d.strideDepth,f=d.strideHeight,p=d.strideWidth,m=d.filterDepth,g=d.filterHeight,_=d.filterWidth,y=new $r(d.filterShape,"float32"),v=y.values,[b,w,C,E]=y.strides,k=e.data.get(i.dataId).values,[M,O,K,X]=u,Q=e.data.get(s.dataId).values,[re,ne,V,G]=c,W=d.padInfo.front,J=d.padInfo.left,ue=d.padInfo.top;for(let me=0;me<m;++me){const De=Math.max(0,Math.ceil((W-me)/h)),be=Math.min(d.outDepth,(d.inDepth+W-me)/h),Se=me*b;for(let Ie=0;Ie<g;++Ie){const $e=Math.max(0,Math.ceil((ue-Ie)/f)),Ae=Math.min(d.outHeight,(d.inHeight+ue-Ie)/f),qe=Ie*w+Se;for(let Ke=0;Ke<_;++Ke){const ot=Math.max(0,Math.ceil((J-Ke)/p)),vt=Math.min(d.outWidth,(d.inWidth+J-Ke)/p),Kt=Ke*C+qe;for(let cn=0;cn<d.inChannels;++cn){const pn=cn*E+Kt;for(let xn=0;xn<d.outChannels;++xn){let Qt=0;for(let Mn=0;Mn<d.batchSize;++Mn){const Un=Mn*re,ta=Mn*M;for(let Nr=De;Nr<be;++Nr){const Gs=(me+Nr*h-W)*ne+Un,nc=Nr*O+ta;for(let qi=$e;qi<Ae;++qi){const Ya=(Ie+qi*f-ue)*V+Gs,Za=qi*K+nc;for(let Qa=ot;Qa<vt;++Qa)Qt+=Q[(Ke+Qa*p-J)*G+Ya+cn]*k[Qa*X+Za+xn]}}}v[pn+xn]=Qt}}}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},Lfe={kernelName:wC,backendName:"cpu",kernelFunc:function $fe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{pad:o,strides:a,inputShape:l}=r;ze([s],"conv3dBackpropInputV2");const c=Je(s.shape),u=Je(i.shape),d=Ra(l,i.shape,a,1,o),h=new $r(d.inShape,"float32"),f=h.values,[p,m,g,_]=h.strides,y=e.data.get(s.dataId).values,[v,b,w,C]=c,E=e.data.get(i.dataId).values,[k,M,O,K]=u,{batchSize:X,filterDepth:Q,filterHeight:re,filterWidth:ne,inChannels:V,inDepth:G,inHeight:W,inWidth:J,outChannels:ue,outDepth:me,outHeight:De,outWidth:be,strideDepth:Se,strideHeight:Ie,strideWidth:$e}=d,Ae=Q-1-d.padInfo.front,qe=re-1-d.padInfo.top,Ke=ne-1-d.padInfo.left;for(let ot=0;ot<X;++ot)for(let vt=0;vt<V;++vt)for(let Kt=0;Kt<G;++Kt){const cn=Kt-Ae,pn=Math.max(0,Math.ceil(cn/Se)),xn=Math.min(me,(Q+cn)/Se);for(let Qt=0;Qt<W;++Qt){const Mn=Qt-qe,Un=Math.max(0,Math.ceil(Mn/Ie)),ta=Math.min(De,(re+Mn)/Ie);for(let Nr=0;Nr<J;++Nr){const Xa=Nr-Ke,Gs=Math.max(0,Math.ceil(Xa/$e)),nc=Math.min(be,(ne+Xa)/$e);let qi=0;for(let na=pn;na<xn;++na){const Ya=na*Se-cn;for(let Za=Un;Za<ta;++Za){const Qa=Za*Ie-Mn;for(let wp=Gs;wp<nc;++wp){const FI=v*ot+b*na+w*Za+C*wp,RTe=k*(Q-1-Ya)+M*(re-1-Qa)+O*(ne-1-(wp*$e-Xa))+K*vt;for(let Rv=0;Rv<ue;++Rv)qi+=y[FI+Rv]*E[RTe+Rv]}}}f[p*ot+m*Kt+g*Qt+_*Nr+vt]=qi}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},Vfe=qt(Hh,n=>Math.cos(n)),Bfe={kernelName:Hh,backendName:"cpu",kernelFunc:Vfe},zfe=qt(jh,n=>Math.cosh(n)),Ufe={kernelName:jh,backendName:"cpu",kernelFunc:zfe},jfe={kernelName:DC,backendName:"cpu",kernelFunc:function Hfe(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=r,[u,d,h,f]=s.shape,p=i.shape[0],[m,g]=a,_=Nt([p,m,g,f],"float32"),y=e.data.get(i.dataId).values,v=e.data.get(o.dataId).values,b=e.data.get(s.dataId).values,w=Je(s.shape),C=Je(_.shape);for(let E=0;E<p;E++){const k=4*E,M=y[k],O=y[k+1],K=y[k+2],X=y[k+3],Q=v[E];if(Q>=u)continue;const re=m>1?(K-M)*(d-1)/(m-1):0,ne=g>1?(X-O)*(h-1)/(g-1):0;for(let V=0;V<m;V++){const G=m>1?M*(d-1)+V*re:.5*(M+K)*(d-1);if(G<0||G>d-1)for(let W=0;W<g;W++)for(let J=0;J<f;J++)_.values[J+W*C[2]+V*C[1]+E*C[0]]=c;else if("bilinear"===l){const W=Math.floor(G),J=Math.ceil(G),ue=G-W;for(let me=0;me<g;me++){const De=g>1?O*(h-1)+me*ne:.5*(O+X)*(h-1);if(De<0||De>h-1){for(let $e=0;$e<f;$e++)_.values[$e+me*C[2]+V*C[1]+E*C[0]]=c;continue}const be=Math.floor(De),Se=Math.ceil(De),Ie=De-be;for(let $e=0;$e<f;$e++){let Ae=$e+be*w[2]+W*w[1]+Q*w[0];const qe=b[Ae];Ae=$e+Se*w[2]+W*w[1]+Q*w[0];const Ke=b[Ae];Ae=$e+be*w[2]+J*w[1]+Q*w[0];const ot=b[Ae];Ae=$e+Se*w[2]+J*w[1]+Q*w[0];const vt=b[Ae],Kt=qe+(Ke-qe)*Ie;Ae=$e+me*C[2]+V*C[1]+E*C[0],_.values[Ae]=Kt+(ot+(vt-ot)*Ie-Kt)*ue}}}else for(let W=0;W<g;++W){const J=g>1?O*(h-1)+W*ne:.5*(O+X)*(h-1);if(J<0||J>h-1){for(let De=0;De<f;De++)_.values[De+W*C[2]+V*C[1]+E*C[0]]=c;continue}const ue=Math.round(J),me=Math.round(G);for(let De=0;De<f;De++)_.values[De+W*C[2]+V*C[1]+E*C[0]]=b[De+ue*w[2]+me*w[1]+Q*w[0]]}}}return e.makeTensorInfo(_.shape,_.dtype,_.values)}},Gfe={kernelName:CC,backendName:"cpu",kernelFunc:function Wfe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;ze(s,"cumprod");const l=Sn([i],s.shape.length);let c=s;null!=l&&(c=us({inputs:{x:s},backend:e,attrs:{perm:l}}));const u=An(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=_s(c.dtype,"int32"),h=uC(ce(c.shape),d),f=e.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(_,y)=>_+p-y-1:(_,y)=>_+y;for(let _=0;_<f.length;_+=p)for(let y=0;y<p;y++){const v=m(_,y);if(0===y)h[v]=o?1:f[v];else{const b=m(_,y-1);h[v]=o?f[b]*h[b]:f[v]*h[b]}}const g=e.makeTensorInfo(c.shape,d,h);if(null!=l){const y=us({inputs:{x:g},backend:e,attrs:{perm:Fa(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),y}return g}},Kfe={kernelName:ry,backendName:"cpu",kernelFunc:function qfe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;ze(s,"cumsum");const l=Sn([i],s.shape.length);let c=s;null!=l&&(c=us({inputs:{x:s},backend:e,attrs:{perm:l}}));const u=An(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=_s(c.dtype,"int32"),h=Pr(ce(c.shape),d),f=e.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(_,y)=>_+p-y-1:(_,y)=>_+y;for(let _=0;_<f.length;_+=p)for(let y=0;y<p;y++){const v=m(_,y);if(0===y)h[v]=o?0:f[v];else{const b=m(_,y-1);h[v]=o?f[b]+h[b]:f[v]+h[b]}}const g=e.makeTensorInfo(c.shape,d,h);if(null!=l){const y=us({inputs:{x:g},backend:e,attrs:{perm:Fa(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),y}return g}},Yfe={kernelName:MP,backendName:"cpu",kernelFunc:function Xfe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o,binaryOutput:a}=r;if(1===s.shape.length){const u=rI(e.data.get(s.dataId).values,e.data.get(i.dataId).values,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,u)}if(2===s.shape.length){const u=fB(e.bufferSync(s),e.bufferSync(i),o,a);return e.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},Qfe={kernelName:SC,backendName:"cpu",kernelFunc:function Zfe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:i,dataFormat:o}=r;S("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=s.shape[0],l=s.shape[1],c=s.shape[2],u=s.shape[3],d=l*i,h=c*i,f=u/(i*i),p=e.data.get(s.dataId).values,m=new Float32Array(a*d*h*f);let g=0;for(let _=0;_<a;++_)for(let y=0;y<d;++y){const v=Math.floor(y/i),b=y%i;for(let w=0;w<h;++w){const C=Math.floor(w/i),k=(b*i+w%i)*f;for(let M=0;M<f;++M)m[g++]=p[M+k+u*(C+c*(v+l*_))]}}return e.makeTensorInfo([a,d,h,f],s.dtype,m)}};function yB(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;ze([s,i],"depthwiseConv2DNative");const u=Je(s.shape),d=Je(i.shape);let h=l;null==h&&(h=[1,1]),S(Er(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const f=gr(s.shape,i.shape,o,h,a,c,!0),{filterHeight:p,filterWidth:m,dilationHeight:g,dilationWidth:_,padInfo:y}=f,v=y.left,b=y.top,w=f.outChannels/f.inChannels,C=new $r(f.outShape,s.dtype),E=e.data.get(s.dataId).values,k=e.data.get(i.dataId).values,M=C.values;for(let O=0;O<f.batchSize;++O){const K=O*u[0],X=O*C.strides[0];for(let Q=0;Q<f.outHeight;++Q){const re=X+Q*C.strides[1],ne=Q*f.strideHeight-b;for(let V=0;V<p;++V){const G=ne+V*g;if(G<0||G>=f.inHeight)continue;const W=V*d[0],J=K+G*u[1];for(let ue=0;ue<f.outWidth;++ue){const me=re+ue*C.strides[2],De=ue*f.strideWidth-v;for(let be=0;be<m;++be){const Se=De+be*_;if(Se<0||Se>=f.inWidth)continue;const $e=J+Se*f.inChannels;let Ae=me,qe=W+be*d[1];for(let Ke=0;Ke<f.inChannels;++Ke){const ot=E[$e+Ke];for(let vt=0;vt<w;++vt)M[Ae+vt]+=ot*k[qe+vt];Ae+=w,qe+=w}}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const Jfe={kernelName:sy,backendName:"cpu",kernelFunc:yB},tpe={kernelName:EC,backendName:"cpu",kernelFunc:function epe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r;ze([s,i],"depthwiseConv2dNativeBackpropFilter");const d=gr(s.shape,u,o,a,l,c,!0),{strideHeight:h,strideWidth:f,filterHeight:p,filterWidth:m}=d,g=new $r(d.filterShape,"float32"),_=d.padInfo.left,y=d.padInfo.top,v=d.outChannels/d.inChannels,b=e.data.get(s.dataId).values,w=new $r(s.shape,s.dtype,b),C=e.data.get(i.dataId).values,E=new $r(i.shape,i.dtype,C);for(let k=0;k<p;++k){const M=Math.max(0,Math.ceil((y-k)/h)),O=Math.min(d.outHeight,(d.inHeight+y-k)/h);for(let K=0;K<m;++K){const X=Math.max(0,Math.ceil((_-K)/f)),Q=Math.min(d.outWidth,(d.inWidth+_-K)/f);for(let re=0;re<d.outChannels;++re){const ne=Math.trunc(re/v),V=re%v;let G=0;for(let W=0;W<d.batchSize;++W)for(let J=M;J<O;++J){const ue=k+J*h-y;for(let me=X;me<Q;++me)G+=w.get(W,ue,K+me*f-_,ne)*E.get(W,J,me,re)}g.set(G,k,K,ne,V)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},rpe={kernelName:IC,backendName:"cpu",kernelFunc:function npe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r;ze([s,i],"depthwiseConv2DNativeBackpropInput");const d=Je(s.shape),h=Je(i.shape),f=gr(u,i.shape,o,a,l,c,!0),p=new $r(f.inShape,"float32"),m=p.values,[g,_,y]=p.strides,v=e.data.get(s.dataId).values,[b,w,C]=d,E=e.data.get(i.dataId).values,[k,M,O]=h,{batchSize:K,filterHeight:X,filterWidth:Q,inChannels:re,inHeight:ne,inWidth:V,outChannels:G,outHeight:W,outWidth:J,strideHeight:ue,strideWidth:me}=f,De=X-1-f.padInfo.top,be=Q-1-f.padInfo.left,Se=G/re;for(let Ie=0;Ie<K;++Ie)for(let $e=0;$e<re;++$e)for(let Ae=0;Ae<ne;++Ae){const qe=Ae-De,Ke=Math.max(0,Math.ceil(qe/ue)),ot=Math.min(W,(X+qe)/ue);for(let vt=0;vt<V;++vt){const Kt=vt-be,cn=Math.max(0,Math.ceil(Kt/me)),pn=Math.min(J,(Q+Kt)/me);let xn=0;for(let Qt=Ke;Qt<ot;++Qt){const Mn=Qt*ue-qe;for(let Un=cn;Un<pn;++Un){const Nr=b*Ie+w*Qt+C*Un,Xa=k*(X-1-Mn)+M*(Q-1-(Un*me-Kt))+O*$e;for(let Gs=0;Gs<Se;++Gs)xn+=v[Nr+($e*Se+Gs)]*E[Xa+Gs]}}m[g*Ie+_*Ae+y*vt+$e]=xn}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}},ipe={kernelName:"Diag",backendName:"cpu",kernelFunc:function spe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=ce(r.shape),i=e.data.get(r.dataId).values,o=Nt([s,s],r.dtype),a=o.values;for(let c=0;c<i.length;c++)a[c*s+c]=i[c];const l=[...r.shape,...r.shape];return e.makeTensorInfo(l,o.dtype,o.values)}},ope={kernelName:iy,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s}=n,{strides:i,pad:o,dilations:a}=e,l=t,c=l.data.get(r.dataId).values,u=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:f,inHeight:p,inWidth:m,inChannels:g,outHeight:_,outWidth:y,padInfo:v,strideHeight:b,strideWidth:w,filterHeight:C,filterWidth:E,dilationHeight:k,dilationWidth:M,outShape:O}=Lf(r.shape,s.shape,i,o,"NHWC",a),K=ce(O),X=O.length,Q=os(r.dtype,K);for(let ne=0;ne<f;++ne)for(let V=0;V<_;++V){const G=V*b-v.top;for(let W=0;W<y;++W){const J=W*w-v.left;for(let ue=0;ue<g;++ue){let me=Number.MIN_SAFE_INTEGER;for(let be=0;be<C;++be){const Se=G+be*k;if(Se>=0&&Se<p)for(let Ie=0;Ie<E;++Ie){const $e=J+Ie*M;if($e>=0&&$e<m){const Ae=ho([ne,Se,$e,ue],u,Je(r.shape)),qe=ho([be,Ie,ue],h,Je(s.shape)),Ke=c[Ae]+d[qe];Ke>me&&(me=Ke)}}}Q[ho([ne,V,W,ue],X,Je(O))]=me}}}return{dataId:l.write(Rl(Q,r.dtype),O,r.dtype),shape:O,dtype:r.dtype}}},ape={kernelName:kC,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=e,c=t,u=$i(r.shape,c.data.get(r.dataId).values),d=$i(s.shape,c.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:_,padInfo:y,strideHeight:v,strideWidth:b,filterHeight:w,filterWidth:C,dilationHeight:E,dilationWidth:k,outShape:M}=Lf(r.shape,s.shape,o,a,"NHWC",l);S(i.rank===M.length,()=>`Error in ${kC}, dy must have the same rank as output ${M.length}, but got ${i.rank}`);const O=$i(M,c.data.get(i.dataId).values),K=EP(s.shape,s.dtype);for(let Q=0;Q<h;++Q)for(let re=0;re<g;++re){const ne=re*v-y.top;for(let V=0;V<_;++V){const G=V*b-y.left;for(let W=0;W<m;++W){let J=Number.MIN_SAFE_INTEGER,ue=0,me=0;for(let De=0;De<w;++De){const be=ne+De*E;if(be>=0&&be<f)for(let Se=0;Se<C;++Se){const Ie=G+Se*k;if(Ie>=0&&Ie<p){const $e=u[Q][be][Ie][W]+d[De][Se][W];$e>J&&(J=$e,ue=De,me=Se)}}}K[ue][me][W]+=O[Q][re][V][W]}}}return{dataId:c.write(Rl(K,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},lpe={kernelName:TC,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=e,c=t,u=$i(r.shape,c.data.get(r.dataId).values),d=$i(s.shape,c.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:_,padInfo:y,strideHeight:v,strideWidth:b,filterHeight:w,filterWidth:C,dilationHeight:E,dilationWidth:k,outShape:M}=Lf(r.shape,s.shape,o,a,"NHWC",l);S(i.rank===M.length,()=>`Error in ${TC}, dy must have the same rank as output ${M.length}, but got ${i.rank}`);const O=$i(M,c.data.get(i.dataId).values),K=EP(r.shape,r.dtype);for(let Q=0;Q<h;++Q)for(let re=0;re<g;++re){const ne=re*v-y.top;for(let V=0;V<_;++V){const G=V*b-y.left;for(let W=0;W<m;++W){let J=Number.MIN_SAFE_INTEGER,ue=ne<0?0:ne,me=G<0?0:G;for(let De=0;De<w;++De){const be=ne+De*E;if(be>=0&&be<f)for(let Se=0;Se<C;++Se){const Ie=G+Se*k;if(Ie>=0&&Ie<p){const $e=u[Q][be][Ie][W]+d[De][Se][W];$e>J&&(J=$e,ue=be,me=Ie)}}}K[Q][ue][me][W]+=O[Q][re][V][W]}}}return{dataId:c.write(Rl(K,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},sI=Kn((n,t)=>n*t),cpe=eI((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),iv=br(df,sI,cpe),upe={kernelName:df,backendName:"cpu",kernelFunc:iv};function cp(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;let a;ze(s,"sum"),a="bool"===s.dtype?Ga({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):Do({inputs:{x:s},backend:e});const l=a.shape.length,c=It(i,a.shape),u=Sn(c,l);let d=c,h=a;null!=u&&(h=us({inputs:{x:a},backend:e,attrs:{perm:u}}),d=An(d.length,l)),Ir("sum",d,h.shape.length);const[f,p]=yr(h.shape,d);let g=sv(e,f,_s(h.dtype,"int32"));const _=ce(p),y=e.data.get(g.dataId).values,v=e.data.get(h.dataId).values;for(let b=0;b<y.length;++b){const w=b*_;let C=0;for(let E=0;E<_;++E)C+=v[w+E];y[b]=C}if(o){const w=g;g=bn({inputs:{x:g},backend:e,attrs:{shape:Bn(g.shape,c)}}),e.disposeIntermediateTensorInfo(w)}return e.disposeIntermediateTensorInfo(a),null!=u&&e.disposeIntermediateTensorInfo(h),g}const dpe={kernelName:$y,backendName:"cpu",kernelFunc:cp},fpe={kernelName:"Einsum",backendName:"cpu",kernelFunc:function hpe(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,i=t,{allDims:o,summedDims:a,idDims:l}=zS(s,i.length);HS(o.length,l,i);const{path:c,steps:u}=jS(a,l),d=u.length;let h=null,f=o.length;const p=[];for(let m=0;m<d;++m){for(const g of u[m]){const{permutationIndices:_,expandDims:y}=US(f,l[g]);let v;WS(_)?v=i[g]:(v=us({inputs:{x:i[g]},backend:e,attrs:{perm:_}}),p.push(v));const b=v.shape.slice();for(let w=0;w<y.length;++w)b.splice(y[w],0,1);Ut(v.shape,b)||(v=bn({inputs:{x:v},backend:e,attrs:{shape:b}}),p.push(v)),null===h?h=v:(h=iv({inputs:{a:v,b:h},backend:e}),p.push(h))}m<d-1&&(c[m]>=0&&(h=cp({inputs:{x:h},backend:e,attrs:{axis:c[m]-(o.length-f),keepDims:!1}}),p.push(h)),f--)}for(const m of p)m!==h&&e.disposeIntermediateTensorInfo(m);return h}},mpe={kernelName:NC,backendName:"cpu",kernelFunc:function ppe(n){const{inputs:t,backend:e}=n,{dy:r,y:s}=t;ze([r,s],"eluGrad");const i=new Float32Array(ce(s.shape)),o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];i[l]=c>=1?a[l]:a[l]*(c+1)}return e.makeTensorInfo(s.shape,"float32",i)}},_B=Kn((n,t)=>n===t?1:0),vB=br(oy,_B,null,"bool"),gpe={kernelName:oy,backendName:"cpu",kernelFunc:vB},ype=MS,_pe=OS,vpe=FS,bpe=PS,xpe=$S,wpe=LS,Cpe=qt(qh,n=>{const t=Math.sign(n),e=Math.abs(n),r=1/(1+ype*e);return t*(1-((((wpe*r+xpe)*r+bpe)*r+vpe)*r+_pe)*r*Math.exp(-e*e))}),Dpe={kernelName:qh,backendName:"cpu",kernelFunc:Cpe},bB=Wa(n=>Math.exp(n)),xB=Lu(Kh,bB,"float32"),Spe={kernelName:Kh,backendName:"cpu",kernelFunc:xB};function ov(n){const{inputs:t,backend:e,attrs:r}=n,{input:s}=t,{dim:i}=r,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(S(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),bn({inputs:{x:s},backend:e,attrs:{shape:a}})}const Epe={kernelName:ay,backendName:"cpu",kernelFunc:ov},wB=Wa(n=>Math.expm1(n)),Ipe=Lu(Xh,wB),Tpe={kernelName:Xh,backendName:"cpu",kernelFunc:Ipe},kpe=Kn((n,t)=>n/t),iI=br(Wh,kpe),oI={kernelName:Wh,backendName:"cpu",kernelFunc:iI},CB=Kn((n,t)=>n-t),Npe=eI((n,t,e,r)=>({real:n-e,imag:t-r})),aI=br(Ef,CB,Npe),Ape={kernelName:Ef,backendName:"cpu",kernelFunc:aI};function DB(n,t,e){const r=n.shape,s=r[0],i=r[1],o=e.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[s,i],u=ce(c),d=Sr("float32",u),h=Sr("float32",u);for(let g=0;g<s;g++){const _=Yl({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,i]}}),y=Yl({inputs:{x:l},backend:e,attrs:{begin:[g,0],size:[1,i]}}),v=ws({inputs:{real:_,imag:y},backend:e}),{real:b,imag:w}=Rpe(v,t,e),C=Zo(b,w);for(let E=0;E<i;E++){const k=VS(C,E);d[g*i+E]=k.real,h[g*i+E]=k.imag}e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(v)}const f=e.makeTensorInfo(c,"float32",d),p=e.makeTensorInfo(c,"float32",h),m=ws({inputs:{real:f,imag:p},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),m}function Rpe(n,t,e){const r=ce(n.shape),s=e.data.get(n.dataId),i=e.data.get(s.complexTensorInfos.real.dataId).values,o=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function Mpe(n){return 0==(n&n-1)}(r)){const a=lI(i,o,r,t,e),l=[n.shape[0],n.shape[1]];if(t){const c=e.makeTensorInfo(l,"float32",a.real),u=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",Ia(r,"float32")),h=Do({inputs:{x:d},backend:e}),f=oI.kernelFunc({inputs:{a:c,b:d},backend:e}),p=oI.kernelFunc({inputs:{a:u,b:h},backend:e}),m=e.data.get(f.dataId).values,g=e.data.get(p.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),{real:m,imag:g}}return a}{const l=function Ope(n,t,e){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let i=0,o=0;for(let a=0;a<t;a++){const l=x$(s*a,t,e),c=VS(n,a);i+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}e&&(i/=t,o/=t),v$(r,i,o,s)}return r}(Zo(i,o),r,t);return g$(l)}}function lI(n,t,e,r,s){if(1===e)return{real:n,imag:t};const i=Zo(n,t),o=e/2,a=y$(i),l=a.real,c=a.imag,u=[l.length],d=s.makeTensorInfo(u,"float32",l),h=s.makeTensorInfo(u,"float32",c),f=ws({inputs:{real:d,imag:h},backend:s}),p=_$(i),m=p.real,g=p.imag,_=[m.length],y=s.makeTensorInfo(_,"float32",m),v=s.makeTensorInfo(_,"float32",g),b=ws({inputs:{real:y,imag:v},backend:s}),w=lI(l,c,o,r,s),C=w.real,E=w.imag,k=[C.length],M=s.makeTensorInfo(k,"float32",C),O=s.makeTensorInfo(k,"float32",E),K=ws({inputs:{real:M,imag:O},backend:s}),X=lI(m,g,o,r,s),Q=X.real,re=X.imag,ne=[Q.length],V=s.makeTensorInfo(ne,"float32",Q),G=s.makeTensorInfo(ne,"float32",re),W=ws({inputs:{real:V,imag:G},backend:s}),J=b$(e,r),ue=[J.real.length],me=s.makeTensorInfo(ue,"float32",J.real),De=s.makeTensorInfo(ue,"float32",J.imag),be=ws({inputs:{real:me,imag:De},backend:s}),Se=iv({inputs:{a:be,b:W},backend:s}),Ie=lp({inputs:{a:K,b:Se},backend:s}),$e=aI({inputs:{a:K,b:Se},backend:s}),Ae=Xl({inputs:{input:Ie},backend:s}),qe=Xl({inputs:{input:$e},backend:s}),Ke=Vu({inputs:{input:Ie},backend:s}),ot=Vu({inputs:{input:$e},backend:s}),vt=Bu({inputs:[Ae,qe],backend:s,attrs:{axis:0}}),Kt=Bu({inputs:[Ke,ot],backend:s,attrs:{axis:0}}),cn=s.data.get(vt.dataId).values,pn=s.data.get(Kt.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(me),s.disposeIntermediateTensorInfo(De),s.disposeIntermediateTensorInfo(be),s.disposeIntermediateTensorInfo(Se),s.disposeIntermediateTensorInfo(Ie),s.disposeIntermediateTensorInfo($e),s.disposeIntermediateTensorInfo(Ae),s.disposeIntermediateTensorInfo(Ke),s.disposeIntermediateTensorInfo(qe),s.disposeIntermediateTensorInfo(ot),s.disposeIntermediateTensorInfo(vt),s.disposeIntermediateTensorInfo(Kt),{real:cn,imag:pn}}const Ppe={kernelName:"FFT",backendName:"cpu",kernelFunc:function Fpe(n){const{inputs:t,backend:e}=n,{input:r}=t,s=ce(r.shape),i=r.shape[r.shape.length-1],a=bn({inputs:{x:r},backend:e,attrs:{shape:[s/i,i]}}),l=DB(a,!1,e),c=bn({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}};function cI(n){const{backend:t,attrs:e}=n,{shape:r,value:s,dtype:i}=e,o=i||Ah(s),a=os(o,ce(r));return function Lpe(n,t,e){n.fill(t)}(a,s),t.makeTensorInfo(r,o,a)}const $pe={kernelName:RC,backendName:"cpu",kernelFunc:cI},Vpe={kernelName:MC,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:r}=n,s=e,i=Sr(r.dtype,ce(r.shape)),[o,a,l,c]=r.shape,u=s.data.get(r.dataId).values;for(let h=0;h<o;h++){const f=h*l*a*c;for(let p=0;p<a;p++){const m=p*(l*c);for(let g=0;g<l;g++){const _=g*c;for(let y=0;y<c;y++){const v=Math.round(l-g-1),b=f+m+_+y;let w=u[b];v>=0&&v<l&&(w=u[f+m+v*c+y]),i[b]=w}}}}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},SB=Wa(n=>Math.floor(n)),Bpe=Lu(Yh,SB),zpe={kernelName:Yh,backendName:"cpu",kernelFunc:Bpe},Upe=Kn((n,t)=>Math.floor(n/t)),Hpe=br(Zh,Upe,null,"int32"),jpe={kernelName:Zh,backendName:"cpu",kernelFunc:Hpe},Gpe={kernelName:Gy,backendName:"cpu",kernelFunc:function Wpe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=gB({inputs:{x:s,filter:i},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h}});if(o){const g=m;m=lp({inputs:{a:m,b:o},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){const g=m;m=JE(e,m,f,a,p),e.disposeIntermediateTensorInfo(g)}return m}},Kpe={kernelName:qy,backendName:"cpu",kernelFunc:function qpe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=yB({inputs:{x:s,filter:i},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h}});if(o){const g=m;m=lp({inputs:{a:m,b:o},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){const g=m;m=JE(e,m,f,a,p),e.disposeIntermediateTensorInfo(g)}return m}};function EB(n,t,e,r,s,i,o,a,l){const c=Nt([r,i],e);for(let u=0;u<r;u++){const d=[];let h=0;for(let f=0;f<s;f++){const p=n[u*s+f];h+=p*o[f],d.push(p)}if(h<0||h>=l/i)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let f=0;f<i;f++)c.values[u*i+f]=t.get(...t.indexToLoc(h*i+f))}return c}const Ype={kernelName:PP,backendName:"cpu",kernelFunc:function Xpe(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,i=ce(r.shape),o=s.shape,a=o[o.length-1],[l,c,u,d]=RS(r,s);if(0===c)return e.makeTensorInfo(l,r.dtype,[]);const p=EB(e.data.get(s.dataId).values,e.bufferSync(r),r.dtype,c,a,u,d,r.shape,i);return e.makeTensorInfo(l,r.dtype,p.values)}};function IB(n,t,e){const r=Nt(e,n.dtype);for(let s=0;s<r.size;++s){const o=r.indexToLoc(s).slice(),c=t.locToIndex([o[0],o[2]]);o[2]=t.values[c];const u=n.locToIndex(o);0<=u&&u<n.values.length&&(r.values[s]=n.values[u])}return r}const Qpe={kernelName:cy,backendName:"cpu",kernelFunc:function Zpe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:i}=t,{axis:o,batchDims:a}=r;ze([s,i],"gatherV2");const l=It(o,s.shape)[0],c=e.data.get(i.dataId).values,u=s.shape[l];for(let b=0;b<c.length;++b){const w=c[b];S(w<=u-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${u-1}]`)}let d=a;null==a&&(d=0);const h=ce(i.shape),f=KS(s,i,l,d),p=bn({inputs:{x:s},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),m=bn({inputs:{x:i},backend:e,attrs:{shape:[f.batchSize,h/f.batchSize]}}),g=[f.batchSize,f.outerSize,h/f.batchSize,f.sliceSize],_=e.bufferSync(m),v=IB(e.bufferSync(p),_,g);return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.makeTensorInfo(f.outputShape,v.dtype,v.values)}},TB=Kn((n,t)=>n>t?1:0),Jpe=br(uy,TB,null,"bool"),eme={kernelName:uy,backendName:"cpu",kernelFunc:Jpe},kB=Kn((n,t)=>n>=t?1:0),tme=br(Qh,kB,null,"bool"),nme={kernelName:Qh,backendName:"cpu",kernelFunc:tme},sme={kernelName:OC,backendName:"cpu",kernelFunc:function rme(n){const{inputs:t,backend:e}=n,{input:r}=t,s=ce(r.shape),i=r.shape[r.shape.length-1],a=bn({inputs:{x:r},backend:e,attrs:{shape:[s/i,i]}}),l=DB(a,!0,e),c=bn({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}},ime=qt(ef,n=>Number.isFinite(n)?1:0,"bool"),ome={kernelName:ef,backendName:"cpu",kernelFunc:ime},ame=qt(nf,n=>Math.abs(n)===1/0?1:0,"bool"),lme={kernelName:nf,backendName:"cpu",kernelFunc:ame},cme=qt(rf,n=>Number.isNaN(n)?1:0,"bool"),ume={kernelName:rf,backendName:"cpu",kernelFunc:cme},NB=Kn((n,t)=>n<t?1:0),dme=br(hy,NB,null,"bool"),hme={kernelName:hy,backendName:"cpu",kernelFunc:dme},AB=Kn((n,t)=>n<=t?1:0),fme=br(fy,AB,null,"bool"),pme={kernelName:fy,backendName:"cpu",kernelFunc:fme};function RB(n,t,e){const r=(t-n)/(e-1),s=Pr(e,"float32");s[0]=n;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return s}const gme={kernelName:$P,backendName:"cpu",kernelFunc:function mme(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:i}=e,o=RB(r,s,i);return t.makeTensorInfo([o.length],"float32",o)}},MB=Wa(n=>Math.log(n)),yme=Lu(sf,MB),_me={kernelName:sf,backendName:"cpu",kernelFunc:yme},vme=qt(af,n=>Math.log1p(n)),bme={kernelName:af,backendName:"cpu",kernelFunc:vme},xme=Kn((n,t)=>n&&t),wme=br(py,xme,null,"bool"),Cme={kernelName:py,backendName:"cpu",kernelFunc:wme},Dme=qt(my,n=>n?0:1,"bool"),Sme={kernelName:my,backendName:"cpu",kernelFunc:Dme},Eme=Kn((n,t)=>n||t),Ime=br(gy,Eme,null,"bool"),Tme={kernelName:gy,backendName:"cpu",kernelFunc:Ime},Nme={kernelName:yy,backendName:"cpu",kernelFunc:function kme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=r;ze(s,"LRN");const c=s.shape[3],u=c-1,d=e.data.get(s.dataId).values,h=ce(s.shape),f=new Float32Array(h);function p(m){const g=m%c;let _=m-g+Math.max(0,g-i);const y=m-g+Math.min(g+i,u);let v=0;for(;_<=y;_++){const b=d[_];v+=b*b}return v}for(let m=0;m<h;m++){const g=p(m),_=d[m]*Math.pow(o+a*g,-l);f[m]=_}return e.makeTensorInfo(s.shape,s.dtype,f)}},Rme={kernelName:PC,backendName:"cpu",kernelFunc:function Ame(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:u}=r;ze(o,"LRNGrad");const d=ce(o.shape),h=o.shape[3],f=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,m=e.data.get(i.dataId).values,g=new Float32Array(d),_=d;for(let y=0;y<_;y++){const v=y%h,b=y-v+Math.max(0,v-a),w=y-v+Math.min(h,v+a+1);let C=0;for(let E=b;E<w;E++)C+=Math.pow(p[E],2);C=c*C+l;for(let E=b;E<w;E++){let k=-2*c*u*p[E]*m[y]/C;y===E&&(k+=Math.pow(C,-u)),k*=f[y],g[E]+=k}}return e.makeTensorInfo(o.shape,s.dtype,g)}};function OB(n,t,e,r){const s=Sr(r,ce(e));for(let i=0;i<s.length;++i){const o=i*t;let a=n[o];for(let l=0;l<t;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}s[i]=a}return s}function FB(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:i,keepDims:o}=r,a=e;let l=s.shape;const c=l.length,u=It(i,l);let d=u;const h=Sn(d,c);let f=a.data.get(s.dataId).values;if(null!=h){const b=new Array(c);for(let w=0;w<b.length;w++)b[w]=l[h[w]];f=tI(f,l,s.dtype,h,b),d=An(d.length,c),l=b}ze(s,"max"),Ir("max",d,c);const[p,m]=yr(l,d),_=OB(f,ce(m),p,s.dtype),y=a.write(_,p,s.dtype);let v=p;return o&&(v=Bn(p,u)),{dataId:y,shape:v,dtype:s.dtype}}const Mme={kernelName:_y,backendName:"cpu",kernelFunc:FB},PB=Kn((n,t)=>Math.max(n,t)),Ome=br(lf,PB),Fme={kernelName:lf,backendName:"cpu",kernelFunc:Ome},$me={kernelName:vy,backendName:"cpu",kernelFunc:function Pme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;ze(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Er(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=ui(s.shape,i,o,1,a,l);let d;if(1===u.filterWidth&&1===u.filterHeight&&Ut(u.inShape,u.outShape))d=Do({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Je(s.shape),p=nI(h,0,s.dtype,f,u,"max");d=e.makeTensorInfo(u.outShape,s.dtype,p.values)}return d}},Vme={kernelName:by,backendName:"cpu",kernelFunc:function Lme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;ze(s,"maxPool3d");const u=Go(s.shape,i,o,1,a,l,c),h=dB(e.data.get(s.dataId).values,0,s.dtype,Je(s.shape),u,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},zme={kernelName:LC,backendName:"cpu",kernelFunc:function Bme(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;ze([s,i],"maxPool3DGrad");const u=Go(i.shape,o,a,1,l,c),h=function rfe(n,t){const e=Nt(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,f=t.padInfo.top,p=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let _=0;_<t.outDepth;++_){const y=_*r-h;let v=y;for(;v<0;)v+=o;const b=Math.min(t.inDepth,c+y);for(let w=0;w<t.outHeight;++w){const C=w*s-f;let E=C;for(;E<0;)E+=a;const k=Math.min(t.inHeight,u+C);for(let M=0;M<t.outWidth;++M){const O=M*i-p;let K=O;for(;K<0;)K+=l;const X=Math.min(t.inWidth,d+O);let Q=Number.NEGATIVE_INFINITY,re=-1;for(let ne=v;ne<b;ne+=o){const V=ne-y;for(let G=E;G<k;G+=a){const W=G-C;for(let J=K;J<X;J+=l){const ue=J-O,me=n.get(m,ne,G,J,g);me>=Q&&(Q=me,re=V*u*d+W*u+ue)}}}e.set(re,m,_,w,M,g)}}}return e}(e.bufferSync(i),u),f=u.strideDepth,p=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,_=u.dilationHeight,y=u.dilationWidth,v=u.effectiveFilterDepth,b=u.effectiveFilterHeight,w=u.effectiveFilterWidth,C=v-1-u.padInfo.front,E=w-1-u.padInfo.left,k=b-1-u.padInfo.top,M=Nt(i.shape,"float32"),O=e.bufferSync(s);for(let K=0;K<u.batchSize;++K)for(let X=0;X<u.inChannels;++X)for(let Q=0;Q<u.inDepth;++Q)for(let re=0;re<u.inHeight;++re)for(let ne=0;ne<u.inWidth;++ne){const V=Q-C,G=re-k,W=ne-E;let J=0;for(let ue=0;ue<v;ue+=g){const me=(V+ue)/f;if(!(me<0||me>=u.outDepth||Math.floor(me)!==me))for(let De=0;De<b;De+=_){const be=(G+De)/p;if(!(be<0||be>=u.outHeight||Math.floor(be)!==be))for(let Se=0;Se<w;Se+=y){const Ie=(W+Se)/m;if(Ie<0||Ie>=u.outWidth||Math.floor(Ie)!==Ie)continue;const qe=v*b*w-1-h.get(K,me,be,Ie,X)===ue*b*w+De*w+Se?1:0;0!==qe&&(J+=O.get(K,me,be,Ie,X)*qe)}}}M.set(J,K,Q,re,ne,X)}return e.makeTensorInfo(M.shape,M.dtype,M.values)}},Hme={kernelName:$C,backendName:"cpu",kernelFunc:function Ume(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i,output:o}=t,a=i;ze([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,h=ui(a.shape,l,c,1,u,d),f=e.data.get(a.dataId).values,p=Nt(h.outShape,a.dtype,uB(f,a.shape,a.dtype,h).values),m=h.strideHeight,g=h.strideWidth,_=h.dilationHeight,y=h.dilationWidth,v=h.effectiveFilterHeight,b=h.effectiveFilterWidth,w=b-1-h.padInfo.left,C=v-1-h.padInfo.top,E=Nt(a.shape,"float32"),k=e.data.get(s.dataId).values,M=Nt(s.shape,"float32",k);for(let O=0;O<h.batchSize;++O)for(let K=0;K<h.inChannels;++K)for(let X=0;X<h.inHeight;++X)for(let Q=0;Q<h.inWidth;++Q){const re=X-C,ne=Q-w;let V=0;for(let G=0;G<v;G+=_){const W=(re+G)/m;if(!(W<0||W>=h.outHeight||Math.floor(W)!==W))for(let J=0;J<b;J+=y){const ue=(ne+J)/g;if(ue<0||ue>=h.outWidth||Math.floor(ue)!==ue)continue;const be=v*b-1-p.get(O,W,ue,K)===G*b+J?1:0;0!==be&&(V+=M.get(O,W,ue,K)*be)}}E.set(V,O,X,Q,K)}return e.makeTensorInfo(E.shape,E.dtype,E.values)}},Wme={kernelName:LP,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;ze(r,"MaxPoolWithArgmax");const c=l.data.get(r.dataId).values,u=ui(r.shape,s,i,[1,1],o),[d,h]=function jme(n,t,e,r,s){const o=nI(n,0,e,Je(t),s,"max"),a=uB(n,t,e,s,!0,r);return[o.values,a.values]}(c,r.shape,r.dtype,a,u),f=l.write(d,u.outShape,r.dtype),p=l.write(h,u.outShape,r.dtype);return[{dataId:f,shape:u.outShape,dtype:r.dtype},{dataId:p,shape:u.outShape,dtype:"int32"}]}},qme={kernelName:xy,backendName:"cpu",kernelFunc:function Gme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=It(i,s.shape),u=ce(yr(s.shape,a)[1]),d=[],h=e.makeTensorInfo([],"float32",new Float32Array([u]));d.push(h);const f=Ga({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});d.push(f);const p=iI({inputs:{a:f,b:h},backend:e});d.push(p);const m=cp({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:o}});return d.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}},Xme={kernelName:wy,backendName:"cpu",kernelFunc:function Kme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;ze(s,"min");const a=It(i,s.shape);let l=a;const c=Sn(l,s.shape.length);let u=s;null!=c&&(u=us({inputs:{x:s},backend:e,attrs:{perm:c}}),l=An(l.length,s.shape.length)),Ir("min",l,u.shape.length);const[d,h]=yr(u.shape,l),f=ce(h),p=Pr(ce(d),u.dtype),m=e.data.get(u.dataId).values;for(let _=0;_<p.length;++_){const y=_*f;let v=m[y];for(let b=0;b<f;++b){const w=m[y+b];(Number.isNaN(w)||w<v)&&(v=w)}p[_]=v}null!=c&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(d,u.dtype,p);if(o){const y=bn({inputs:{x:g},backend:e,attrs:{shape:Bn(d,a)}});return e.disposeIntermediateTensorInfo(g),y}return g}},$B=Kn((n,t)=>Math.min(n,t)),Yme=br(cf,$B),Zme={kernelName:cf,backendName:"cpu",kernelFunc:Yme},Jme={kernelName:Cy,backendName:"cpu",kernelFunc:function Qme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,mode:o}=r;ze(s,"mirrorPad");const a=i.map((v,b)=>v[0]+s.shape[b]+v[1]),l=i.map(v=>v[0]),c=i.map((v,b)=>v[0]+s.shape[b]),u="reflect"===o?0:1,d=e.data.get(s.dataId).values,h=s.shape.length,f=Je(s.shape),p=ce(a),m=a.length,g=Je(a),_=Sr(s.dtype,p);for(let v=0;v<p;v++){let b=Rh(v,m,g);for(let C=0;C<m;C++)b[C]<l[C]?b[C]=2*l[C]-b[C]-u:b[C]>=c[C]&&(b[C]=2*(c[C]-1)-b[C]+u);b=b.map((C,E)=>C-l[E]);const w=ho(b,h,f);_[v]=d[w]}return{dataId:e.write(_,a,s.dtype),shape:a,dtype:s.dtype}}},ege=Kn((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),tge=br(uf,ege),nge={kernelName:uf,backendName:"cpu",kernelFunc:tge};var rge=U(537);function LB(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:i}=r,o=s.shape.length;let a=i;if(-1===a&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=It([a],s.shape),c=FB({inputs:{x:s},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),u=Bn(c.shape,l),d=bn({inputs:{x:c},backend:e,attrs:{shape:u}}),h=aI({inputs:{a:s,b:d},backend:e}),f=xB({inputs:{x:h},backend:e}),p=cp({inputs:{x:f},backend:e,attrs:{axis:l,keepDims:!1}}),m=bn({inputs:{x:p},backend:e,attrs:{shape:u}}),g=iI({inputs:{a:f,b:m},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}const sge={kernelName:By,backendName:"cpu",kernelFunc:LB},oge={kernelName:VP,backendName:"cpu",kernelFunc:function ige(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:i,seed:o,normalized:a}=r;ze(s,"multinomial");const l=a?s:LB({inputs:{logits:s},backend:e,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],d=e.data.get(l.dataId).values,h=[c,i],f=Pr(ce(h),"int32");for(let p=0;p<c;++p){const m=p*u,g=new Float32Array(u-1);g[0]=d[m];for(let v=1;v<g.length;++v)g[v]=g[v-1]+d[m+v];const _=rge.alea(o.toString()),y=p*i;for(let v=0;v<i;++v){const b=_();f[y+v]=g.length;for(let w=0;w<g.length;w++)if(b<g[w]){f[y+v]=w;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",f)}};function VB(n,t,e){const r=Ia(-1,e);return sI([],t,r,n,e)}const lge={kernelName:Dy,backendName:"cpu",kernelFunc:function age(n){const{inputs:t,backend:e}=n,{x:r}=t;ze(r,"neg");const s=e.data.get(r.dataId).values,[i,o]=VB(s,r.shape,r.dtype);return e.makeTensorInfo(o,r.dtype,i)}},cge=hS,dge={kernelName:VC,backendName:"cpu",kernelFunc:function uge(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r;ze(s,"NonMaxSuppression");const c=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values,{selectedIndices:d}=cge(c,u,o,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},hge=fS,pge={kernelName:BC,backendName:"cpu",kernelFunc:function fge(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r;ze(s,"NonMaxSuppressionPadded");const u=e.data.get(s.dataId).values,d=e.data.get(i.dataId).values,{selectedIndices:h,validOutputs:f}=hge(u,d,o,a,l,c);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},mge=pS,yge={kernelName:zC,backendName:"cpu",kernelFunc:function gge(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r;ze(s,"NonMaxSuppressionWithScore");const u=e.data.get(s.dataId).values,d=e.data.get(i.dataId).values,h=o,f=a,p=l,m=c,{selectedIndices:g,selectedScores:_}=mge(u,d,h,f,p,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([_.length],"float32",new Float32Array(_))]}},BB=Kn((n,t)=>n!==t?1:0),_ge=br(Sy,BB,null,"bool"),vge={kernelName:Sy,backendName:"cpu",kernelFunc:_ge},xge={kernelName:Iy,backendName:"cpu",kernelFunc:function bge(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{depth:i,onValue:o,offValue:a}=r;ze(s,"oneHot");const l=ce(s.shape),c=new Float32Array(l*i);c.fill(a);const u=e.data.get(s.dataId).values;for(let d=0;d<l;++d)u[d]>=0&&u[d]<i&&(c[d*i+u[d]]=o);return e.makeTensorInfo([...s.shape,i],"int32",c)}};function av(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=Xl({inputs:{input:r},backend:e}),i=av({inputs:{x:s},backend:e}),o=Vu({inputs:{input:r},backend:e}),a=av({inputs:{x:o},backend:e}),l=ws({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return cI({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const wge={kernelName:jy,backendName:"cpu",kernelFunc:av},Cge={kernelName:Ey,backendName:"cpu",kernelFunc:function zB(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=Xl({inputs:{input:r},backend:e}),i=zB({inputs:{x:s},backend:e}),o=Vu({inputs:{input:r},backend:e}),a=av({inputs:{x:o},backend:e}),l=ws({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return cI({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function UB(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return ov({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const i=t[0].shape,o=t[0].dtype;t.forEach(u=>{ai(i,u.shape,"All tensors passed to stack must have matching shapes"),S(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=Bu({inputs:t.map(u=>{const d=ov({inputs:{input:u},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}const Dge={kernelName:Ty,backendName:"cpu",kernelFunc:UB},HB={kernelName:ky,backendName:"cpu",kernelFunc:function Sge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,constantValue:o}=r;ze(s,"pad");const a=i.map((y,v)=>y[0]+s.shape[v]+y[1]),l=i.map(y=>y[0]),c=e.data.get(s.dataId).values,u=ce(s.shape),d=s.shape.length,h=Je(s.shape),f=ce(a),p=a.length,m=Je(a),g=Sr(s.dtype,f);0!==o&&g.fill(o);for(let y=0;y<u;y++)g[ho(Rh(y,d,h).map((C,E)=>C+l[E]),p,m)]=c[y];return{dataId:e.write(g,a,s.dtype),shape:a,dtype:s.dtype}}},Ege=Kn((n,t)=>Math.pow(n,t)),Ige=br(hf,Ege),Tge={kernelName:hf,backendName:"cpu",kernelFunc:Ige};function jB(n,t,e,r){const[s,i]=yr(n,r),o=_s(t,"int32"),a=Pr(ce(s),o),l=ce(i);for(let c=0;c<a.length;++c){const u=c*l;let d=1;for(let h=0;h<l;++h)d*=e[u+h];a[c]=d}return{outVals:a,outShape:s,outDtype:o}}const Nge={kernelName:UC,backendName:"cpu",kernelFunc:function kge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;ze(s,"prod");const a=s.shape.length,l=It(i,s.shape),c=Sn(l,a);let u=l,d=s;const h=[];null!=c&&(d=us({inputs:{x:s},backend:e,attrs:{perm:c}}),h.push(d),u=An(u.length,a));const f=e.data.get(d.dataId).values,{outVals:p,outShape:m,outDtype:g}=jB(d.shape,d.dtype,f,u);let _=m;return o&&(_=Bn(m,l)),h.forEach(y=>e.disposeIntermediateTensorInfo(y)),e.makeTensorInfo(_,g,p)}};function WB(n,t,e,r){if(n===t||n<t&&e<0||t<n&&e>1)return Pr(0,r);const l=Pr(Math.abs(Math.ceil((t-n)/e)),r);t<n&&1===e&&(e=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+e;return l}const Rge={kernelName:HC,backendName:"cpu",kernelFunc:function Age(n){const{backend:t,attrs:e}=n,{start:r,stop:s,dtype:i,step:o}=e,a=WB(r,s,o,i);return t.makeTensorInfo([a.length],i,a)}},Mge=qt(ff,n=>1/n),Oge={kernelName:ff,backendName:"cpu",kernelFunc:Mge},Pge={kernelName:My,backendName:"cpu",kernelFunc:function Fge(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r;ze(s,"resizeBilinear");const l=Je(s.shape),[c,u]=a,[d,h,f,p]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(ce([d,c,u,p])),_=[i&&c>1?h-1:h,i&&u>1?f-1:f],y=[i&&c>1?c-1:c,i&&u>1?u-1:u];let v=0;const b=_[0]/y[0],w=_[1]/y[1];for(let C=0;C<d;C++)for(let E=0;E<c;E++){let k;k=o?b*(E+.5)-.5:b*E;const M=Math.max(0,Math.floor(k)),O=k-M,K=Math.min(h-1,Math.ceil(k)),X=C*l[0]+M*l[1],Q=C*l[0]+K*l[1];for(let re=0;re<u;re++){let ne;ne=o?w*(re+.5)-.5:w*re;const V=Math.max(0,Math.floor(ne)),G=ne-V,W=Math.min(f-1,Math.ceil(ne)),J=X+V*l[2],ue=Q+V*l[2],me=X+W*l[2],De=Q+W*l[2];for(let be=0;be<p;be++){const Se=m[J+be],Ie=m[ue+be],qe=Se+(m[me+be]-Se)*G;g[v++]=qe+(Ie+(m[De+be]-Ie)*G-qe)*O}}}return e.makeTensorInfo([d,c,u,p],"float32",g)}},Lge={kernelName:GC,backendName:"cpu",kernelFunc:function $ge(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r;ze([i,s],"resizeBilinearGrad");const a=Je(s.shape),[l,c,u,d]=s.shape,[,h,f]=i.shape,p=new Float32Array(l*c*u*d),m=[o&&h>1?c-1:c,o&&f>1?u-1:u],g=[o&&h>1?h-1:h,o&&f>1?f-1:f],_=m[0]/g[0],y=m[1]/g[1],v=e.data.get(i.dataId).values;let b=0;for(let w=0;w<l;w++){const C=w*a[0];for(let E=0;E<h;E++){const k=E*_,M=Math.floor(k),O=Math.min(Math.ceil(k),c-1),K=C+M*a[1],X=C+O*a[1],Q=k-M,re=1-Q;for(let ne=0;ne<f;ne++){const V=ne*y,G=Math.floor(V),W=Math.min(Math.ceil(V),u-1),J=V-G,ue=1-J,me=K+G*a[2],De=K+W*a[2],be=X+G*a[2],Se=X+W*a[2],Ie=re*ue,$e=re*J,Ae=Q*ue,qe=Q*J;for(let Ke=0;Ke<d;Ke++){const ot=v[b++];p[me+Ke]+=ot*Ie,p[De+Ke]+=ot*$e,p[be+Ke]+=ot*Ae,p[Se+Ke]+=ot*qe}}}}return e.makeTensorInfo([l,u,c,d],"float32",p)}},Bge={kernelName:Ry,backendName:"cpu",kernelFunc:function Vge(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r;ze(s,"resizeNearestNeighbor");const l=Je(s.shape),[c,u]=a,[d,h,f,p]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(d*c*u*p),_=[i&&c>1?h-1:h,i&&u>1?f-1:f],y=[i&&c>1?c-1:c,i&&u>1?u-1:u],v=_[0]/y[0],b=_[1]/y[1];let w=0;for(let C=0;C<d;C++){const E=C*l[0];for(let k=0;k<c;k++){const M=o?v*(k+.5):v*k;let O=Math.min(h-1,i?Math.round(M):Math.floor(M));o&&(O=Math.max(0,O));const K=E+O*l[1];for(let X=0;X<u;X++){const Q=o?b*(X+.5):b*X;let re=Math.min(f-1,i?Math.round(Q):Math.floor(Q));o&&(re=Math.max(0,re));const ne=K+re*l[2];for(let V=0;V<p;V++)g[w++]=m[ne+V]}}}return e.makeTensorInfo([d,c,u,p],s.dtype,g)}},Uge={kernelName:WC,backendName:"cpu",kernelFunc:function zge(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r;ze([i,s],"resizeNearestNeighborGrad");const a=Je(s.shape),l=Je(i.shape),[c,u,d,h]=s.shape,[,f,p]=i.shape,m=new Float32Array(c*u*d*h),g=e.data.get(i.dataId).values,_=[o&&f>1?u-1:u,o&&p>1?d-1:d],y=[o&&f>1?f-1:f,o&&p>1?p-1:p],v=_[0]/y[0],b=_[1]/y[1],w=1/v,C=1/b,E=2*Math.ceil(w)+2,k=2*Math.ceil(C)+2;for(let M=0;M<c;M++){const O=M*a[0];for(let K=0;K<u;K++){const X=O+K*a[1],Q=Math.floor(K*w),re=Math.floor(Q-E/2);for(let ne=0;ne<d;ne++){const V=X+ne*a[2],G=Math.floor(ne*C),W=Math.floor(G-k/2);for(let J=0;J<h;J++){let ue=0;for(let me=0;me<E;me++){const De=me+re;if(De<0||De>=f)continue;const be=O+De*l[1],Se=De*v;if(K===Math.min(u-1,o?Math.round(Se):Math.floor(Se)))for(let $e=0;$e<k;$e++){const Ae=$e+W;if(Ae<0||Ae>=p)continue;const qe=be+Ae*l[2],Ke=Ae*b;ne===Math.min(d-1,o?Math.round(Ke):Math.floor(Ke))&&(ue+=g[qe+J])}}m[V+J]=ue}}}}return e.makeTensorInfo(s.shape,s.dtype,m)}},jge={kernelName:Oy,backendName:"cpu",kernelFunc:function Hge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:i}=r;ze(s,"reverse");const o=s.shape.length,a=It(i,s.shape);if(0===o)return Do({inputs:{x:s},backend:e});const l=new $r(s.shape,s.dtype),c=e.bufferSync(s);for(let u=0;u<l.size;u++){const d=l.indexToLoc(u),h=d.slice();a.forEach(f=>h[f]=s.shape[f]-1-h[f]),l.set(c.get(...h),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},Wge={kernelName:oD,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=t,a=e,l=Sr(r.dtype,ce(r.shape)),[c,u,d,h]=r.shape,[f,p]=kS(o,u,d),g=Math.sin(s),_=Math.cos(s),y=a.data.get(r.dataId).values;for(let b=0;b<c;b++){const w=b*d*u*h;for(let C=0;C<u;C++){const E=C*(d*h);for(let k=0;k<d;k++){const M=k*h;for(let O=0;O<h;O++){const K=[c,C,k,O],X=K[2],Q=K[1];let re=(X-f)*_-(Q-p)*g,ne=(X-f)*g+(Q-p)*_;re=Math.round(re+f),ne=Math.round(ne+p);let V=i;"number"!=typeof i&&(V=3===O?255:i[O]),re>=0&&re<d&&ne>=0&&ne<u&&(V=y[w+ne*(d*h)+re*h+O]),l[w+E+M+O]=V}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Gge=qt(gf,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),qge={kernelName:gf,backendName:"cpu",kernelFunc:Gge},GB=Wa(n=>1/Math.sqrt(n)),Kge=Lu(yf,GB),Xge={kernelName:yf,backendName:"cpu",kernelFunc:Kge};function qB(n,t,e,r,s,i,o,a,l,c){const u=[r/s,s],d=n.values,h=t.values;if(0===r)return Nt(e,t.dtype);const f=Nt(u,t.dtype);f.values.fill(l);for(let p=0;p<i;p++){const m=[];let g=0;for(let _=0;_<o;_++){const y=d[p*o+_];m.push(y),g+=y*a[_]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${e}`);for(let _=0;_<s;_++)c?f.values[g*s+_]+=h[p*s+_]:f.values[g*s+_]=0===t.rank?h[0]:h[p*s+_]}return f}const Zge={kernelName:BP,backendName:"cpu",kernelFunc:function Yge(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:i}=t,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=qf(0,s,o),m=qB(e.bufferSync(s),e.bufferSync(i),o,d,c,l,a,u,0,!0);return e.makeTensorInfo(o,m.dtype,m.values)}},Jge={kernelName:Fy,backendName:"cpu",kernelFunc:function Qge(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:i}=t;ze([r,s,i],"select");const o=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values,u=_s(s.dtype,i.dtype),d=Pr(ce(s.shape),u);let h=0;const f=0===o||o>1||1===s.shape.length?1:ce(s.shape.slice(1));for(let p=0;p<a.length;p++)for(let m=0;m<f;m++)d[h++]=1===a[p]?l[p]:c[p];return e.makeTensorInfo(s.shape,u,d)}},eye=T_,tye=k_,nye=qt(_f,n=>n>=0?tye*n:eye*(Math.exp(n)-1)),rye={kernelName:_f,backendName:"cpu",kernelFunc:nye},sye=qt(xf,n=>n<0?-1:n>0?1:0),iye={kernelName:xf,backendName:"cpu",kernelFunc:sye},oye=qt(vf,n=>Math.sin(n)),aye={kernelName:vf,backendName:"cpu",kernelFunc:oye},lye=qt(bf,n=>Math.sinh(n)),cye={kernelName:bf,backendName:"cpu",kernelFunc:lye},KB=Math.log(1.1920928955078125e-7)+2,uye=qt(Cf,n=>{const t=n>-KB,e=n<KB,r=Math.exp(n);let s;return s=e?r:t?n:Math.log(1+r),s}),dye={kernelName:Cf,backendName:"cpu",kernelFunc:uye},fye={kernelName:Ly,backendName:"cpu",kernelFunc:function hye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,paddings:o}=r;ze([s],"spaceToBatchND");const a=ce(i),l=[[0,0]];l.push(...o);for(let C=1+i.length;C<s.shape.length;++C)l.push([0,0]);const c=HB.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),u=jf(c.shape,i,a,!1),d=Wf(u.length,i.length,!1),h=Gf(c.shape,i,a,!1),m=bn({inputs:{x:c},backend:e,attrs:{shape:u}}),y=us({inputs:{x:m},backend:e,attrs:{perm:d}}),w=bn({inputs:{x:y},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),w}};function XB(n,t,e,r,s,i,o){const a=t[0],l=i[0],c=new Array(l),u=new Array(a),d=t[1];if(0===l){if(0!==a)throw new Error(D$(a));return[os(e,0),[0,d],os(s,0),c,u]}let h=!0,f=0;const p=new Array(l).fill(0);for(let g=0;g<a;++g){const _=n[g*d];if(_<0)throw new Error(S$(g,_));if(_>=l)throw new Error(E$(g,_,l));++p[_],h=h&&_>=f,f=_}let m=!0;for(let g=0;g<l;++g){const _=0===p[g];c[g]=_,m=m&&!_,p[g]=Math.max(p[g],1),g>0&&(p[g]+=p[g-1])}if(m&&h){const g=n,_=r;for(let y=0;y<a;++y)u[y]=y;return[g,[a,d],_,c,u]}{const g=p[l-1],_=os(e,g*d),y=os(s,g),v=new Array(l).fill(0);for(let b=0;b<a;++b){const w=n[b*d],E=(0===w?0:p[w-1])+v[w];v[w]++;for(let k=0;k<d;++k)_[E*d+k]=n[b*d+k];y[E]=r[b],u[b]=E}for(let b=0;b<l;++b)if(0===v[b]){const C=0===b?0:p[b-1];_[C*d+0]=b;for(let E=1;E<d;++E)_[C*d+E]=0;y[C]=o}return[_,[g,d],y,c,u]}}const mye={kernelName:qC,backendName:"cpu",kernelFunc:function pye(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values[0],[d,h,f,p,m]=XB(a,r.shape,r.dtype,l,s.dtype,c,u);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,f),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),e.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function YB(n,t,e,r,s){const i=ce(r),o=t[0],a=s.length,l=[];let c=1,u=-1;for(let g=0;g<a;++g){const _=s[g];if(-1===_){if(-1!==u)throw new Error(I$(u,g));u=g,l.push(1)}else{if(_<0)throw new Error(T$(g,_));c*=_,l.push(_)}}if(-1!==u){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const g=Math.trunc(i/c);if(c*g!==i)throw new Error(N$(r,l));l[u]=g}if(ce(l)!==i)throw new Error(A$(r,l));const h=r.length,f=[];if(h>0){f[h-1]=1;for(let g=h-2;g>=0;--g)f[g]=f[g+1]*r[g+1]}const p=[];if(a>0){p[a-1]=1;for(let g=a-2;g>=0;--g)p[g]=p[g+1]*l[g+1]}const m=os(e,o*a);for(let g=0;g<o;++g){let _=0;for(let y=0;y<h;++y)_+=n[g*h+y]*f[y];for(let y=0;y<a;++y)m[g*a+y]=Math.trunc(_/p[y]),_%=p[y]}return[m,[o,a],l]}const yye={kernelName:KC,backendName:"cpu",kernelFunc:function gye(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.data.get(s.dataId).values),a=e.data.get(r.dataId).values,l=Array.from(e.data.get(i.dataId).values),[c,u,d]=YB(a,r.shape,r.dtype,o,l);return[e.makeTensorInfo(u,r.dtype,c),e.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}};function uI(n,t,e,r,s,i=!1,o=0){const a=r.length,l=[t[0],n.length/t[0]],c=l[1],d=a>0?s[a-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=d;const p=os(e,h.reduce((v,b)=>v*b,1));if(0===a)return d>0&&p.fill(o),[p,h];if(d<=0)throw new Error("segment ids must be >= 0");let m=0,g=1,_=0,y=s[m];for(;;){let v=0;if(g<a){if(v=s[g],y===v){++g;continue}if(y>=v)throw new Error("segment ids are not increasing")}if(y<0||y>=d)throw new Error(M$(y,d));y>_&&p.fill(o,_*c,y*c);for(let b=m;b<g;++b){const w=r[b];if(w<0||w>=l[0])throw new Error(O$(b,r[b],l[0]));for(let C=0;C<c;C++)p[y*c+C]+=n[w*c+C]}if(i)for(let b=0;b<c;b++)p[y*c+b]/=g-m;if(m=g,++g,_=y+1,y=v,g>a)break}return _<d&&p.fill(o,_*c,d*c),[p,h]}const vye={kernelName:XC,backendName:"cpu",kernelFunc:function _ye(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,[c,u]=uI(o,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(u,r.dtype,c)}},xye={kernelName:YC,backendName:"cpu",kernelFunc:function bye(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,[c,u]=uI(o,r.shape,r.dtype,a,l);return e.makeTensorInfo(u,r.dtype,c)}},Cye={kernelName:zP,backendName:"cpu",kernelFunc:function wye(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=qf(0,s,a),_=qB(e.bufferSync(s),e.bufferSync(i),a,h,u,c,l,d,e.data.get(o.dataId).values[0],!1);return e.makeTensorInfo(a,_.dtype,_.values)}},Sye={kernelName:Vy,backendName:"cpu",kernelFunc:function Dye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:i,axis:o}=r,a=It(o,s.shape)[0],l=GS(s,i,a),c=new Array(s.shape.length).fill(0),u=s.shape.slice();return l.map(d=>{const h=[...u];h[a]=d;const f=Yl({inputs:{x:s},backend:e,attrs:{begin:c,size:h}});return c[a]+=d,f})}},Eye=Wa(n=>Math.sqrt(n)),Iye=qt(Df,n=>Math.sqrt(n)),Tye={kernelName:Df,backendName:"cpu",kernelFunc:Iye},kye={kernelName:ZC,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,r=t;ze(e,"square");const s=r.data.get(e.dataId).values,i=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];i[a]=l*l}return{dataId:r.write(i,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},ZB=Kn((n,t)=>{const e=n-t;return e*e}),Nye=br(Sf,ZB),Aye={kernelName:Sf,backendName:"cpu",kernelFunc:Nye},Rye=qt(Nf,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),Mye={kernelName:Nf,backendName:"cpu",kernelFunc:Rye};function QB(n,t,e,r){const s=Nt(n,t.dtype);for(let i=0;i<s.size;i++){const o=s.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*e[l]+r[l];s.set(t.get(...a),...o)}return s}const Fye={kernelName:QC,backendName:"cpu",kernelFunc:function Oye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r;ze(s,"stridedSlice");const{finalShapeSparse:f,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:_,begin:y,end:v,strides:b}=zD(s.shape,i,o,a,l,c,u,d,h);let w;if(m)w=bn({inputs:{x:s},backend:e,attrs:{shape:p}});else if(g||_){S(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=LD(y,v,b),E=Yl({inputs:{x:s},backend:e,attrs:{begin:y,size:C}});w=bn({inputs:{x:E},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(E)}else{const E=QB(f,e.bufferSync(s),b,y);w=e.makeTensorInfo(p,E.dtype,E.values)}return w}};class Pye{constructor(t,e,r,s,i,o){this.separator=Ta(t),this.nGramWidths=e,this.leftPad=Ta(r),this.rightPad=Ta(s),this.padWidth=i,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,s,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(i-(a+1))),d=o-(c+u),h=e+(c>0?0:a-l);let f=0;f+=c*this.leftPad.length;for(let y=0;y<d;++y)f+=t[h+y].length;f+=u*this.rightPad.length,f+=(c+u+d-1)*this.separator.length,r[s+a]=new Uint8Array(f);const m=r[s+a];let g=0;const _=y=>y.forEach(v=>m[g++]=v);for(let y=0;y<c;++y)_(this.leftPad),_(this.separator);for(let y=0;y<d-1;++y)_(t[h+y]),_(this.separator);if(d>0){_(t[h+d-1]);for(let y=0;y<u;++y)_(this.separator),_(this.rightPad)}else{for(let y=0;y<u-1;++y)_(this.rightPad),_(this.separator);_(this.rightPad)}}}compute(t,e){const r=t.length,s=e.length;if(s>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<s;++c){let u=e[c]>=l;if(u=u&&e[c]<=r,!u)throw new Error(`Invalid split value ${e[c]}, must be in [${l}, ${r}]`);l=e[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const i=s-1,o=os("int32",s);if(0===r||0===s){const l=new Array(r);for(let c=0;c<=i;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const c=e[l]-e[l-1];let u=0;this.nGramWidths.forEach(d=>{u+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&0===u&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[i]);for(let l=0;l<i;++l){const c=e[l];let u=o[l];if(this.nGramWidths.forEach(d=>{const f=this.getNumNGrams(e[l+1]-e[l],d);this.createNGrams(t,c,a,u,f,d),u+=f}),this.preserveShort&&u===o[l]){const d=e[l+1]-e[l];if(0===d)continue;this.createNGrams(t,c,a,u,1,d+2*this.padWidth)}}return[a,o]}}function JB(n,t,e,r,s,i,o,a){return new Pye(e,r,s,i,o,a).compute(n,t)}const Lye={kernelName:JC,backendName:"cpu",kernelFunc:function $ye(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=t,h=e.data.get(u.dataId).values,f=e.data.get(d.dataId).values,[p,m]=JB(h,f,s,i,o,a,l,c);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(d.shape,"int32",m)]}};function Vye(n,t,e,r){if(!n.length)return;if(0===t.length){for(let i=0;i<n.length;++i)r.push(n.subarray(i,i+1));return}if(1===t.length){const i=t[0];let o=n.indexOf(i);for(;-1!==o;){const a=n.subarray(0,o);(!e||0!==a.length)&&r.push(a),o=(n=n.subarray(o+1)).indexOf(i)}return void((!e||0!==n.length)&&r.push(n))}let s=0;for(let i=0;i<n.length+1;i++)if(i===n.length||-1!==t.indexOf(n[i])){const o=n.subarray(s,i);(!e||0!==o.length)&&r.push(o),s=i+1}}function e3(n,t,e){const r=n.length,s=[];let i=0,o=0;const a=new Array(r);for(let h=0;h<r;++h){const f=s.length;Vye(n[h],t,e,s);const p=s.length-f;a[h]=p,i+=p,o=Math.max(o,p)}const l=os("int32",2*i),c=new Array(i),u=[r,o];let d=0;for(let h=0;h<r;++h)for(let f=0;f<a[h];++f)l[2*d]=h,l[2*d+1]=f,c[d]=s[d],++d;return[l,c,u]}const zye={kernelName:eD,backendName:"cpu",kernelFunc:function Bye(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values[0],[c,u,d]=e3(a,l,s),h=u.length;return[e.makeTensorInfo([h,2],"int32",c),e.makeTensorInfo([h],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(d))]}};function t3(n,t){const e=os("int32",n.length);for(let r=0;r<n.length;++r)e[r]=Uee(n[r]).modulo(t).getLowBitsUnsigned();return e}const Hye={kernelName:tD,backendName:"cpu",kernelFunc:function Uye(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=t3(e.data.get(i.dataId).values,s);return e.makeTensorInfo(i.shape,"int32",a)}},jye=qt(If,n=>Math.tan(n)),Wye={kernelName:If,backendName:"cpu",kernelFunc:jye},Gye=qt(Tf,n=>Math.tanh(n));function n3(n,t){const e=new Array(n.rank);for(let s=0;s<e.length;s++)e[s]=n.shape[s]*t[s];const r=Nt(e,n.dtype);for(let s=0;s<r.values.length;++s){const i=r.indexToLoc(s),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);r.values[s]=n.values[a]}return r}const up=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function r3(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,l=t-e+1,c=Math.log(a),u=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2);r3(n,t,Math.max(e,Math.floor(t-l*u/a+d)),Math.min(r,Math.floor(t+(a-l)*u/a+d)))}const s=n[t];let i=e,o=r;for(Da(n,e,t),up(n[r],s)>0&&Da(n,e,r);i<o;){for(Da(n,i,o),i++,o--;up(n[i],s)<0;)i+=1;for(;up(n[o],s)>0;)o-=1}0===up(n[e],s)?Da(n,e,o):(o+=1,Da(n,o,r)),o<=t&&(e=o+1),t<=o&&(r=o-1)}}function s3(n,t,e,r,s){const i=t[t.length-1],[o,a]=[n.length/i,i],l=Sr(e,o*r),c=Sr("int32",o*r);for(let d=0;d<o;d++){const h=d*a,f=n.subarray(h,h+a);let p=new Array(f.length);f.forEach((y,v)=>p[v]={value:y,index:v}),r<p.length&&(r3(p,r),p=p.slice(0,r)),s&&p.sort(up);const m=d*r,g=l.subarray(m,m+r),_=c.subarray(m,m+r);for(let y=0;y<r;y++)g[y]=p[y].value,_[y]=p[y].index}const u=t.slice();return u[u.length-1]=r,[Nt(u,e,l),Nt(u,"int32",c)]}function o3(n,t,e){switch(e){case"reflect":return function e_e(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{const r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return kl(0,e,t-1)}(n,t);case"wrap":return function t_e(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),kl(0,e,t-1)}(n,t);case"nearest":return function r_e(n,t){return kl(0,n,t-1)}(n,t);default:return function n_e(n,t){return n}(n)}}function dp(n,t,e,r,s,i,o,a,l,c,u){return 0<=a&&a<t&&0<=l&&l<e?n[o*r+a*s+l*i+c]:u}function s_e(n,t,e,r,s,i,o,a,l,c,u){return dp(n,t,e,r,s,i,o,Math.round(a),Math.round(l),c,u)}function i_e(n,t,e,r,s,i,o,a,l,c,u){const d=Math.floor(a),h=Math.floor(l),f=d+1,p=h+1;return(f-a)*((p-l)*dp(n,t,e,r,s,i,o,d,h,c,u)+(l-h)*dp(n,t,e,r,s,i,o,d,p,c,u))+(a-d)*((p-l)*dp(n,t,e,r,s,i,o,f,h,c,u)+(l-h)*dp(n,t,e,r,s,i,o,f,p,c,u))}function a3(n,t,e,r){const s=It(t,e)[0],i=[1,e[0],1];for(let p=0;p<s;p++)i[0]*=e[p];i[1]=e[s];for(let p=s+1;p<e.length;p++)i[2]*=e[p];const o={},a=new Int32Array(e[s]),l=new $r(i,r,n),c=[],u=1===i[0]&&1===i[2];for(let p=0;p<e[s];p++){let m;if(u)m=n[p].toString();else{const g=[];for(let _=0;_<i[0];_++)for(let y=0;y<i[2];y++)g.push(l.get(_,p,y));m=g.join(",")}if(void 0!==o[m])a[p]=o[m];else{const g=Object.keys(o).length;o[m]=g,a[p]=g,c.push(p)}}const d=i.slice();d[1]=Object.keys(o).length;const h=new $r(d,r);c.forEach((p,m)=>{for(let g=0;g<i[0];g++)for(let _=0;_<i[2];_++)h.set(l.get(g,p,_),g,m,_)});const f=e.slice();return f[s]=d[1],{outputValues:h.values,outputShape:f,indices:a}}const h_e=[khe,Nhe,Rhe,Ohe,She,Phe,Vhe,zhe,Hhe,Whe,qhe,Xhe,Zhe,efe,nfe,ife,afe,cfe,dfe,Ihe,ffe,gfe,_fe,bfe,Che,wfe,Dfe,xhe,Sfe,Ife,Tfe,Nfe,Rfe,Ofe,Pfe,Lfe,Bfe,Ufe,jfe,Gfe,Kfe,Yfe,Qfe,Jfe,tpe,rpe,ipe,ope,ape,lpe,fpe,hhe,mpe,gpe,Dpe,Spe,Epe,Tpe,Ppe,$pe,Vpe,zpe,jpe,Gpe,Kpe,Ype,Qpe,eme,nme,fhe,sme,Efe,ome,lme,ume,phe,hme,pme,gme,_me,bme,Cme,Sme,Tme,Nme,Rme,Mme,Fme,$me,Vme,zme,Hme,Wme,qme,Xme,Zme,Jme,nge,oge,upe,lge,dge,pge,yge,vge,xge,Cge,Dge,HB,Tge,ghe,Nge,Rge,whe,oI,Oge,yhe,_he,Ehe,Pge,Lge,Bge,Uge,jge,Wge,qge,Xge,Zge,Jge,rye,bhe,iye,aye,cye,pfe,sge,dye,fye,mye,yye,vye,xye,Cye,Sye,Tye,kye,Aye,Mye,Fye,Lye,zye,Hye,Ape,dpe,Wye,{kernelName:Tf,backendName:"cpu",kernelFunc:Gye},{kernelName:kf,backendName:"cpu",kernelFunc:function Kye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:i}=r;ze(s,"tile");const o=n3(e.bufferSync(s),i);return e.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:nD,backendName:"cpu",kernelFunc:function Yye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:i,sorted:o}=r;ze(s,"topk");const a=e.data.get(s.dataId).values,[l,c]=s3(a,s.shape,s.dtype,i,o);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}},{kernelName:rD,backendName:"cpu",kernelFunc:function Qye(n){const{inputs:t,attrs:e,backend:r}=n,{image:s,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=e,[u,d,h,f]=s.shape,[p,m]=null!=c?c:[d,h],g=[u,p,m,f],_=Je(s.shape),y=_[0],v=_[1],b=_[2],w=Sr(s.dtype,ce(g));w.fill(l);const C=r.data.get(s.dataId).values,E=r.data.get(i.dataId).values;for(let M=0;M<u;++M){const O=1===i.shape[0]?E:E.subarray(8*M,8*M+8);for(let K=0;K<p;++K)for(let X=0;X<m;++X)for(let Q=0;Q<f;++Q){let re;const ne=O[6]*X+O[7]*K+1;if(0===ne)continue;const G=(O[3]*X+O[4]*K+O[5])/ne,W=o3((O[0]*X+O[1]*K+O[2])/ne,h,a),J=o3(G,d,a);switch(o){case"nearest":re=s_e(C,d,h,y,v,b,M,J,W,Q,l);break;case"bilinear":re=i_e(C,d,h,y,v,b,M,J,W,Q,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}w[M*y+K*v+X*b+Q]=re}return r.makeTensorInfo(g,s.dtype,w)}return{dataId:r.write(w,g,s.dtype),shape:s.shape,dtype:s.dtype}}},$he,{kernelName:sD,backendName:"cpu",kernelFunc:function o_e(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:i}=t;ze(i,"unique");const o=r.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:c}=a3(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},{kernelName:Uy,backendName:"cpu",kernelFunc:function l_e(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s.shape.length,a=s.shape[i],l=new Array(o-1);let c=0;for(let f=0;f<o;f++)f!==i&&(l[c++]=s.shape[f]);const u=new Array(o).fill(0),d=s.shape.slice();d[i]=1;const h=new Array(a);for(let f=0;f<h.length;f++){u[i]=f;const p=Yl({inputs:{x:s},backend:e,attrs:{begin:u,size:d}});h[f]=bn({inputs:{x:p},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(p)}return h}},{kernelName:Hy,backendName:"cpu",kernelFunc:function u_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:i}=t,{numSegments:o}=r;ze(s,"unsortedSegmentSum");const c=[],u=[],d=s.shape.length-i.shape.length;let h=i;for(let p=0;p<d;++p){const m=ov({inputs:{input:h},backend:e,attrs:{dim:p+1}});h=m,u.push(m)}for(let p=0;p<o;++p){const m=Ia(p,"int32"),g=e.makeTensorInfo([],"int32",m),_=vB({inputs:{a:g,b:h},backend:e}),y=Ga({inputs:{x:_},backend:e,attrs:{dtype:"float32"}}),v=iv({inputs:{a:y,b:s},backend:e}),b=cp({inputs:{x:v},backend:e,attrs:{axis:0,keepDims:!1}});c.push(b),u.push(g),u.push(_),u.push(y),u.push(v),u.push(b)}const f=UB({inputs:c,backend:e,attrs:{axis:0}});return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},wge];for(const n of h_e)cD(n);const qa={},dI={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Gi(n,t){if(!(n in qa)||null!=t){const r=function m_e(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=null==t?function p_e(n){if("undefined"!=typeof OffscreenCanvas&&2===n)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n):t;return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete qa[n]},!1),1===n?e.getContext("webgl",dI)||e.getContext("experimental-webgl",dI):e.getContext("webgl2",dI)}(n,t);if(null===r)return console.log("Could not get context for WebGL version",n),null;qa[n]=r}const e=qa[n];return null==e||e.isContextLost()?(delete qa[n],Gi(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),qa[n])}var zu=(()=>{return(n=zu||(zu={}))[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",zu;var n})(),Cs=(()=>{return(n=Cs||(Cs={}))[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",Cs;var n})(),xr=(()=>{return(n=xr||(xr={}))[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",xr;var n})();function hp(n,t){return[t,n]}function lv(n){const t=ce(n);return iC(Math.ceil(t/4))}function Uu(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function hI(n,t){const e=n;let r,s,i,o,a,l,c,u,d,h;return 2===ae().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,i=e.RGBA16F,o=e.RGBA32F,a=e.RED,c=4,u=1,d=e.HALF_FLOAT,h=e.FLOAT,l=e.RGBA8):(r=n.RGBA,s=n.RGBA,i=n.RGBA,o=e.RGBA,a=n.RGBA,c=4,u=4,d=null!=t?t.HALF_FLOAT_OES:null,h=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:h}}function Le(n,t){const e=t();return ae().getBool("DEBUG")&&function __e(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function w_e(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function x_e(n){return!!(ae().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function cv(n,t){return Jo(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const S_e=/ERROR: [0-9]+:([0-9]+):/g;function l3(n,t){const e=S_e.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const r=+e[1],s=n.split("\n"),i=s.length.toString().length+2,o=s.map((d,h)=>du((h+1).toString(),i)+d);let a=0;for(let d=0;d<o.length;d++)a=Math.max(o[d].length,a);const l=o.slice(0,r-1),c=o.slice(r-1,r),u=o.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${du(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function fI(n,t){if(Le(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function c3(n,t,e,r,s,i,o){const a=n.getAttribLocation(t,e);return-1!==a&&(Le(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),Le(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,i,o)),Le(n,()=>n.enableVertexAttribArray(a)),!0)}function P_e(n,t,e,r){Le(n,()=>function M_e(n,t,e){(function d3(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),Le(n,()=>n.activeTexture(n.TEXTURE0+e)),Le(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,r)),Le(n,()=>n.uniform1i(e,r))}function pI(n,t,e){Le(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Le(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function u3(n,t){Le(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Le(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function uv(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function $_e(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function Jo(n,t,e){const r=Le(n,()=>t());if(null==r)throw new Error(e);return r}function Hu(n,t=2){return ce(n.slice(0,n.length-t))}function ju(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function mI(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[Hu(n),...ju(n)]),t}function dv(n){return n%2==0}function hv(n,t){if(Ut(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n.slice(-1)[0],r=t.slice(-1)[0];if(e===r||dv(e)&&dv(r)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&dv(n[0])&&dv(t[0])}let fv,pv;function vi(n,t){return null!=n.getExtension(t)}function h3(n){try{if(null!=Gi(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function gI(n){const t=hI(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(i),o}function fp(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const et=ae();function Xr(){let n,t,e,r,s,i,o,a,l,c;return 2===ae().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",a="\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",r="varying",s="texture2D",i="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}function Zl(n,t,e="index"){const r=Je(t);return r.map((s,i)=>`int ${n[i]} = ${e} / ${s}; ${i===r.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${s}`:`index -= ${n[i]} * ${s}`};`).join("")}function mv(n,t,e="index"){const r=Je(t);return r.map((s,i)=>`int ${n[i]} = ${e} / outShapeStrides[${i}]; ${i===r.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`};`).join("")}function yI(n){const t=Je(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}et.registerFlag("HAS_WEBGL",()=>et.getNumber("WEBGL_VERSION")>0),et.registerFlag("WEBGL_VERSION",()=>h3(2)?2:h3(1)?1:0),et.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),et.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===et.get("WEBGL_VERSION")),et.registerFlag("WEBGL_CPU_FORWARD",()=>!0),et.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),et.registerFlag("WEBGL_PACK",()=>et.getBool("HAS_WEBGL")),et.registerFlag("WEBGL_PACK_NORMALIZATION",()=>et.getBool("WEBGL_PACK")),et.registerFlag("WEBGL_PACK_CLIP",()=>et.getBool("WEBGL_PACK")),et.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>et.getBool("WEBGL_PACK")),et.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>et.getBool("WEBGL_PACK")),et.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>et.getBool("WEBGL_PACK")),et.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>et.getBool("WEBGL_PACK")),et.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>et.getBool("WEBGL_PACK")),et.registerFlag("WEBGL_PACK_REDUCE",()=>et.getBool("WEBGL_PACK")),et.registerFlag("WEBGL_LAZILY_UNPACK",()=>et.getBool("WEBGL_PACK")),et.registerFlag("WEBGL_CONV_IM2COL",()=>et.getBool("WEBGL_PACK")),et.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function V_e(n){if(null==fv){const t=Gi(n);fv=t.getParameter(t.MAX_TEXTURE_SIZE)}return fv}(et.getNumber("WEBGL_VERSION"))),et.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function B_e(n){if(null==pv){const t=Gi(n);pv=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,pv)}(et.getNumber("WEBGL_VERSION"))),et.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=et.getNumber("WEBGL_VERSION");return 0===n?0:function z_e(n){if(0===n)return 0;let t;const e=Gi(n);return t=vi(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:vi(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),et.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>et.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!e2()),et.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function U_e(n){if(0===n)return!1;const t=Gi(n);if(1===n){if(!vi(t,"OES_texture_float"))return!1}else if(!vi(t,"EXT_color_buffer_float"))return!1;return gI(t)}(et.getNumber("WEBGL_VERSION"))),et.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!et.getBool("WEBGL_FORCE_F16_TEXTURES")&&et.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),et.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function H_e(n){if(0===n)return!1;const t=Gi(n);if(1!==n){if(vi(t,"EXT_color_buffer_float"))return gI(t);const r="EXT_color_buffer_half_float";if(vi(t,r)){const s=t.getExtension(r);return function j_e(n,t){const e=hI(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),a}(t,s)}return!1}return!(!vi(t,"OES_texture_float")||!vi(t,"WEBGL_color_buffer_float"))&&gI(t)}(et.getNumber("WEBGL_VERSION"))),et.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function W_e(n){return 2===n&&null!=Gi(n).fenceSync}(et.getNumber("WEBGL_VERSION"))),et.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>et.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),et.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),et.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>e2()?1:-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),et.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),et.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),et.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),et.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);const f3="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:p3}=se;function K_e(n,t,e){const r=[];if(n.forEach(f=>{const p=ce(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?r.push(`uniform float ${f.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${f.name};`),r.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){const{uniformShape:m}=vI(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${f.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${f.name}Shape;`)}r.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{r.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const s=r.join("\n"),i=n.map(f=>function X_e(n,t,e=!1,r){let s="";return s+=e?m3(n,r):Wu(n,r),n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(s+=e?function Tve(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,a=p3(n.shapeInfo.logicalShape,t.logicalShape),l=Zt(o),c=o-i;let u;const d=["x","y","z","w","u","v"];u=0===i?"":o<2&&a.length>=1?"coords = 0;":a.map(y=>`coords.${d[y+c]} = 0;`).join("\n");let h="";h=o<2&&i>0?"coords":n.shapeInfo.logicalShape.map((y,v)=>`coords.${d[v+c]}`).join(", ");let f="return outputValue;";const m=1===ce(n.shapeInfo.logicalShape),_=1===ce(t.logicalShape);if(1!==i||m||_){if(m&&!_)f=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const y=i-2,v=i-1;a.indexOf(y)>-1&&a.indexOf(v)>-1?f="return vec4(outputValue.x);":a.indexOf(y)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(v)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${u}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}(n,t):function kve(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&null==n.shapeInfo.flatOffset&&Ut(n.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const c=Zt(l),u=p3(n.shapeInfo.logicalShape,t.logicalShape),d=l-a;let h;const f=["x","y","z","w","u","v"];h=0===a?"":l<2&&u.length>=1?"coords = 0;":u.map(m=>`coords.${f[m+d]} = 0;`).join("\n");let p="";return p=l<2&&a>0?"coords":n.shapeInfo.logicalShape.map((m,g)=>`coords.${f[g+d]}`).join(", "),`\n    float ${s}() {\n      ${c} coords = getOutputCoords();\n      ${h}\n      return get${r}(${p});\n    }\n  `}(n,t)),s}(f,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),o=t.texShape,a=Xr(),l=function Q_e(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let c,u,d=function tve(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${nve}\n    ${rve}\n    ${sve}\n  `}(a);return t.isPacked?(c=function Y_e(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function ove(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function pve(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Ut(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function lve(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[2]/2),i=s*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function uve(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[n.length-1]/2),i=s*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`\n      int b${c} = index / ${o};\n      index -= b${c} * ${o};\n    `+a,l=`b${c}, `+l;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${n.length}(${l});\n    }\n  `}(n,t,e)}}(t.logicalShape,o,e.enableShapeUniforms),u=function eve(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(a)):(c=function Z_e(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function ave(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function mve(n,t,e){return Ut(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function cve(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${mv(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const r=Zl(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function dve(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${mv(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Zl(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function hve(n,t){const e=Zl(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function fve(n,t){const e=Zl(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,o,e.enableShapeUniforms),u=function J_e(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(d+=ive),[d,l,u,s,c,i,e.userCode].join("\n")}function Wu(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function yve(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[s,i]=n.shapeInfo.texShape;if(1===s&&1===i)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=Ql(e);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,l]=n.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function vve(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Gu(n)}\n      }\n    `;const s=n.shapeInfo.texShape,i=s[0],o=s[1];if(1===o&&1===i)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=Ql(e);return 1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function xve(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape;if(null!=i&&Ut(e,i))return t?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${i[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:o,keptDims:a}=Sa(e);if(o.length<e.length){const f=["row","col"];return`\n      ${Wu(qu(n,o),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${Ku(f,a)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Gu(n)}\n      }\n    `;const c=i[0],u=i[1],d=Ql(r);return 1===u?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${c}, ${u}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(n,t);case 3:return function Cve(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e[1]*e[2],o=e[2],{newShape:a,keptDims:l}=Sa(e);if(a.length<e.length){const g=["row","col","depth"];return`\n        ${Wu(qu(n,a),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${Ku(g,l)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${o}, 1)));\n        ${Gu(n)}\n      }\n    `;const u=n.shapeInfo.texShape,d=u[0],h=u[1],f=n.shapeInfo.flatOffset;if(h===i&&null==f)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===o&&null==f)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const p=Ql(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${i} + col * ${o} + depth + ${p};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${o} + depth + ${p};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(n,t);case 4:return function Sve(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e[3],o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:c}=Sa(e);if(l.length<e.length){const v=["row","col","depth","depth2"];return`\n      ${Wu(qu(n,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${Ku(v,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${o}, ${i}, 1)));\n        ${Gu(n)}\n      }\n    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1],p=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===a&&null==u)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${p}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===i&&null==u)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const _=Ql(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${p}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${_});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${f}, index + ${_});\n      return sampleTexture(${r}, uv);\n    }\n  `}(n,t);case 5:return function Eve(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[4],i=t[3]*s,o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:c}=Sa(t);if(l.length<t.length){const g=["row","col","depth","depth2","depth3"];return`\n      ${Wu(qu(n,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Ku(g,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${o}, ${i}, ${s})) +\n          depth3;\n        ${Gu(n)}\n      }\n    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1];if(f===a&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===s&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} + depth * ${i} +\n          depth2 * ${s} + depth3 + ${Ql(e)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function Ive(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:i}=Sa(t);if(s.length<t.length){const _=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Wu(qu(n,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Ku(_,i)});\n      }\n    `}const o=t[5],a=t[4]*o,l=t[3]*a,c=t[2]*l,u=t[1]*c;if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${c}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Gu(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],p=h[1];if(p===u&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${a}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===o&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${c} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${o} + depth4 + ${Ql(e)};\n      vec2 uv = uvFromFlat(${f}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function m3(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function gve(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${Xr().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function _ve(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n.shapeInfo.texShape,i=Xr();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `;const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function bve(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=Xr();if(null!=i&&Ut(e,i))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(n,t);case 3:return function wve(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===e[0]){const f=[1,2],m=["b","row","col"];return`\n        ${m3(qu(n,e.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${Ku(m,f)});\n        }\n      `}const a=Xr();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const l=o[0],c=o[1],u=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${c}, ${u*Math.ceil(e[1]/2)}, ${u}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(n,t);default:return function Dve(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Xr();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${e}, uv);\n    }\n  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],d=Math.ceil(i[o-1]/2);let h=d*Math.ceil(i[o-2]/2),f="int b, int row, int col",p=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<o-1;m++)f=`int b${m}, `+f,h*=i[o-m-1],p=`b${m} * ${h} + `+p;return`\n    vec4 ${r}(${f}) {\n      int index = ${p};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const nve="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",rve="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",sve="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ive="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Ql(n){return`offset${n}`}function Gu(n){const t=n.name,e=ce(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Zt(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function vI(n,t,e){const{newShape:r,keptDims:s}=Sa(t),i=t.length,o=n&&3===i&&1===t[0],a=o?t.slice(1):r,l=!n&&i>1&&!Ut(t,e)&&r.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:s}}function qu(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Ku(n,t){return t.map(e=>n[e]).join(", ")}function y3(n,t,e){const r={},s={},i={},o=[];let a,l,c,u=null,d=null;d=n.getUniformLocation(e,"NAN",!1),1===ae().getNumber("WEBGL_VERSION")&&(u=n.getUniformLocation(e,"INFINITY",!1));const h=!1;for(let f=0;f<t.variableNames.length;f++){const p=t.variableNames[f];r[p]=n.getUniformLocation(e,p,h),r[`offset${p}`]=n.getUniformLocation(e,`offset${p}`,h),t.enableShapeUniforms&&(s[`${p}Shape`]=n.getUniformLocation(e,`${p}Shape`,h),i[`${p}TexShape`]=n.getUniformLocation(e,`${p}TexShape`,h))}return t.enableShapeUniforms&&(a=n.getUniformLocation(e,"outShape",h),c=n.getUniformLocation(e,"outShapeStrides",h),l=n.getUniformLocation(e,"outTexShape",h)),t.customUniforms&&t.customUniforms.forEach((f,p)=>{o[p]=n.getUniformLocation(e,f.name,h)}),{uniformLocations:r,customUniformLocations:o,infLoc:u,nanLoc:d,inShapesLocations:s,inTexShapesLocations:i,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:l}}function _3(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{const s=e.logicalShape,i=t[r],o=i.shape;if(!Ut(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(e.isUniform&&i.isUniform)return;const a=e.texShape,l=i.isUniform?null:i.texData.texShape;if(!Ut(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function ds(n){return ae().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class Mve{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=zu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Xr();this.outputShape=t,this.enableShapeUniforms=ds(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?mv(["r","c","d"],t):Zl(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class Ove{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=zu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Xr();this.outputShape=t,this.enableShapeUniforms=ds(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?mv(["r","c","d"],t):Zl(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class Fve{constructor(t){this.variableNames=["A"],this.outTexUsage=Cs.DOWNLOAD;const e=Xr();this.outputShape=t,this.userCode=`\n      ${f3}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class Pve{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Cs.DOWNLOAD;const e=Xr();this.outputShape=t,this.userCode=`\n      ${f3}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class $ve{constructor(t,e=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Xr();this.outputShape=t,this.enableShapeUniforms=ds(this.outputShape.length);let s="result";e&&(s="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":yI(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class Lve{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Xr();this.outputShape=t,this.enableShapeUniforms=ds(this.outputShape.length);let s="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=2*o+a;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${o};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":yI(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${i};\n        }\n    `}}function pp(n,t,e,r,s,i){!function A_e(n,t){const e=ae().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const o=function N_e(n){return Jo(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),a=n.TEXTURE_2D;return Le(n,()=>n.bindTexture(a,o)),Le(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Le(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Le(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),Le(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===ae().getNumber("WEBGL_VERSION")?Le(n,()=>n.texImage2D(a,0,r,t,e,0,s,i,null)):Le(n,()=>n.texStorage2D(a,1,r,t,e)),Le(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function v3(n){return n.internalFormatFloat}function b3(n){return n.internalFormatHalfFloat}function x3(n){return n.downloadTextureFormat}function w3(n){return n.internalFormatPackedFloat}function C3(n){return n.internalFormatPackedHalfFloat}class bI{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=ae().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function f_e(n,t){qa[n]=t}(e,t)):this.gl=Gi(e);let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===ae().getNumber("WEBGL_VERSION")){const o="OES_texture_half_float";if(this.textureFloatExtension=cv(this.gl,"OES_texture_float"),vi(this.gl,o))this.textureHalfFloatExtension=cv(this.gl,o);else if(ae().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),vi(this.gl,s))this.colorBufferHalfFloatExtension=cv(this.gl,s);else if(ae().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",vi(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!vi(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function Bve(n){return function T_e(n,t){const e=Jo(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Le(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),Le(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function zve(n){return function k_e(n,t){const e=Jo(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Le(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),Le(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function R_e(n){return Jo(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=hI(this.gl,this.textureHalfFloatExtension)}get debug(){return ae().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;Le(t,()=>t.finish()),Le(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Le(t,()=>t.deleteFramebuffer(this.framebuffer)),Le(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Le(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Le(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function Uve(n,t,e,r){const[s,i]=hp(t,e);return pp(n,s,i,v3(r),r.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function Hve(n,t,e,r){const[s,i]=hp(t,e);return pp(n,s,i,b3(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function jve(n,t,e,r){const[s,i]=hp(t,e);return pp(n,s,i,x3(r),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function Xve(n,t,e){Le(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===ae().getNumber("WEBGL_VERSION")?Le(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):Le(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===ae().getNumber("WEBGL_VERSION")?Le(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):Le(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),Le(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,s){this.throwIfDisposed(),function Kve(n,t,e,r,s,i){let o,a,l;Le(n,()=>n.bindTexture(n.TEXTURE_2D,t)),s instanceof Uint8Array?(o=new Uint8Array(e*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(e*r*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(s),2===ae().getNumber("WEBGL_VERSION")?Le(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,a,o)):Le(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,r,0,n.RGBA,a,o)),Le(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function Gve(n,t,e,r){const[s,i]=Uu(t,e);return pp(n,s,i,C3(r),n.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function Wve(n,t,e,r){const[s,i]=Uu(t,e);return pp(n,s,i,w3(r),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(u3(this.gl,this.framebuffer),this.outputTexture=null),Le(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function Qve(n,t,e,r){const[s,i]=hp(t,e),a=new Uint8Array(function g_e(n,t){return n*t}(t*e,4));return Le(n,()=>n.readPixels(0,0,s,i,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,s,i,o){return function Jve(n,t,e,r,s,i,o,a){const l=n,c=new Float32Array(function y_e(n,t){const[e,r]=Uu(n,t);return e*r*4}(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}(this.gl,t,0,0,0,i,o)}downloadFloat32MatrixFromBuffer(t,e){return function Zve(n,t,e){const r=n,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);const s=function Yve(n,t,e,r){const s=n.createBuffer();Le(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=16*t*e;return Le(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),Le(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),Le(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(ae().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const o=s.clientWaitSync(i,0,0);return o===s.ALREADY_SIGNALED||o===s.CONDITION_SATISFIED},e=i}else ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function ebe(n,t,e){const r=new Float32Array(t*e*4);return Le(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}(this.gl,e,r))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function Vve(n){const t=Xr();return function C_e(n,t){const e=Jo(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Le(n,()=>n.shaderSource(e,t)),Le(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function E_e(n){return Jo(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);return Le(e,()=>e.attachShader(r,this.vertexShader)),Le(e,()=>e.attachShader(r,t)),function I_e(n,t){if(Le(n,()=>n.linkProgram(t)),!ae().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,r),this.debug&&fI(e,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=function qve(n,t,e){return Le(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),c3(n,t,"clipSpacePos",e,3,20,0)&&c3(n,t,"uv",e,2,20,12)}(e,this.program,this.vertexBuffer)),r}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&Le(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&fI(this.gl,this.program),Le(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?function O_e(n,t,e){return Jo(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function F_e(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Le(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),P_e(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[s,i]=Uu(e,r);this.setOutputMatrixTextureDriver(t,s,i)}setOutputMatrixWriteRegion(t,e,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&fI(this.gl,this.program),uv(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),Le(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Le(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=cv(this.gl,2===ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return he(function*(){return yield wP(()=>e.disposed||e.isQueryAvailable(t,ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function tbe(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),!(this.itemsToPoll.length>1)&&wP(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),pI(this.gl,t,this.framebuffer),this.debug&&uv(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(pI(this.gl,this.outputTexture,this.framebuffer),this.debug&&uv(this.gl)):u3(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const s=this.gl;pI(s,t,this.framebuffer),this.debug&&uv(s),this.outputTexture=t,Le(s,()=>s.viewport(0,0,e,r)),Le(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,s){this.throwIfDisposed(),Le(this.gl,()=>this.gl.scissor(t,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:nbe,bincountImpl:D3,bincountReduceImpl:rbe,ceilImpl:sbe,concatImpl:ibe,equalImpl:obe,expImpl:abe,expm1Impl:lbe,floorImpl:cbe,gatherNdImpl:ube,gatherV2Impl:dbe,greaterImpl:hbe,greaterEqualImpl:fbe,lessImpl:pbe,lessEqualImpl:mbe,linSpaceImpl:gbe,logImpl:ybe,maxImpl:_be,maximumImpl:vbe,minimumImpl:bbe,multiplyImpl:xbe,negImpl:wbe,notEqualImpl:Cbe,prodImpl:Dbe,rangeImpl:Sbe,rsqrtImpl:Ebe,sigmoidImpl:Ibe,simpleAbsImpl:S3,sliceImpl:Tbe,sparseFillEmptyRowsImpl:kbe,sparseReshapeImpl:Nbe,sparseSegmentReductionImpl:E3,sqrtImpl:Abe,stridedSliceImpl:Rbe,stringNGramsImpl:Mbe,stringSplitImpl:Obe,stringToHashBucketFastImpl:Fbe,subImpl:Pbe,tileImpl:$be,topKImpl:Lbe,transposeImpl:xI,uniqueImpl:Vbe}=tt;function I3(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function Yr(n,t){return 1===t?[n]:I3(n,t)}class zbe{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=ds(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Yr("rc",this.rank),r=Zt(this.rank),s=this.getOutOfBoundsCondition(e),i=this.getSetup(e),o=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${t[t.length-1-o]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class T3{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=ds(this.outputShape.length);let r="";for(let s=0;s<4;s++){let i="thisRC = rc;";s%2==1&&(i+="thisRC.z += 1;"),s>1&&(i+="thisRC.y += 1;"),r+=`\n        ${i}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function Ube(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function q_e(n,t,e="index"){const s=function G_e(n,t){const e=n.length,r=n.map(i=>`${t}[${i}]`),s=new Array(e-1);s[e-2]=r[e-1];for(let i=e-3;i>=0;--i)s[i]=`(${s[i+1]} * ${r[i+1]})`;return s}(n.map((i,o)=>o),t);return s.map((i,o)=>`int ${n[o]} = ${e} / ${s[o]}; ${o===s.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${s[o]}`:`index -= ${n[o]} * ${s[o]}`};`).join("")}(["r","c","d"],"inputShape"):Zl(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":yI(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class Hbe{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,r){const s=N3(e,r),i=A3(t,s,r);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=k3(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].shift();return this.usedTextures[i].push(l),l}let a;return s===xr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===xr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===xr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===xr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===xr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(t,e,r,s){if(null==this.freeTextures)return;const i=N3(r,s),o=A3(e,i,s);o in this.freeTextures||(this.freeTextures[o]=[]);const a=k3(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=ae().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(u,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function k3(n,t,e,r,s){const i=function Wbe(n,t){switch(n){case xr.PACKED_2X2_FLOAT32:return w3(t);case xr.PACKED_2X2_FLOAT16:return C3(t);case xr.UNPACKED_FLOAT32:return v3(t);case xr.UNPACKED_FLOAT16:return b3(t);case xr.PACKED_4X1_UNSIGNED_BYTE:return x3(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,r);let o;if(s){const[l,c]=Uu(n[0],n[1]);o=l*c}else{const[l,c]=hp(n[0],n[1]);o=l*c}const a=function jbe(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,i);return o*a}function N3(n,t){if(n===Cs.UPLOAD)return xr.PACKED_2X2_FLOAT32;if(n===Cs.RENDER||null==n)return function Gbe(n){return ae().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?xr.PACKED_2X2_FLOAT32:xr.UNPACKED_FLOAT32:n?xr.PACKED_2X2_FLOAT16:xr.UNPACKED_FLOAT16}(t);if(n===Cs.DOWNLOAD||n===Cs.PIXELS)return xr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function A3(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class ea{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=ds(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const R3="return abs(x);",Xu="return x;";class Jl{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=ds(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class r0e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=ds(this.outputShape.length);const e=t.length,r=Yr("rc",e),s=Zt(e),i=function Bbe(n,t){if(1===n)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}(e,r),o=r.slice(-2),a=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${i});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const s0e=L$,yv={},l0e=ae().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let d0e=(()=>{class n extends rC{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ae().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof bI)r=e;else{const s=Gi(ae().getNumber("WEBGL_VERSION"),e);r=new bI(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Gi(ae().getNumber("WEBGL_VERSION"));r=new bI(s),this.binaryCache=function a0e(n){return n in yv||(yv[n]={}),yv[n]}(ae().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Hbe(this.gpgpu),this.numMBBeforeWarning=function u0e(){return null==ae().global.screen?1024:ae().global.screen.height*ae().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new vP(this,Na())}nextDataId(){return n.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,r,s){if((ae().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ae().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:r,dtype:s,values:e,usage:Cs.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,i,o){if(ae().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:i,values:r,usage:Cs.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:i,complexTensorInfos:o,slice:a,shape:l,isPacked:c}=r;if(null!=a){let f;f=c?new Jl(l,Xu):new ea(l,Xu);const p=this.runWebGLProgram(f,[{dataId:e,shape:l,dtype:i}],i),m=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),m}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===i)return s;const u=null!=this.activeTimers;let d,h;return u&&(d=as()),h="complex64"===i?Zo(this.readSync(o.real.dataId),this.readSync(o.imag.dataId)):this.getValuesFromTexture(e),u&&(this.downloadWaitMs+=as()-d),this.convertAndCacheOnCPU(e,h)}read(e){var r=this;return he(function*(){if(r.pendingRead.has(e)){const g=r.pendingRead.get(e);return new Promise(_=>g.push(_))}const s=r.texData.get(e),{values:i,shape:o,slice:a,dtype:l,complexTensorInfos:c,isPacked:u}=s;if(null!=a){let g;g=u?new Jl(o,Xu):new ea(o,Xu);const _=r.runWebGLProgram(g,[{dataId:e,shape:o,dtype:l}],l),y=r.read(_.dataId);return r.disposeIntermediateTensorInfo(_),y}if(null!=i)return r.convertAndCacheOnCPU(e);if(ae().getBool("DEBUG")&&!ae().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===ae().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,f,d=null;if("complex64"!==l&&ae().get("WEBGL_BUFFER_SUPPORTED")){h=r.decode(e);const g=r.texData.get(h.dataId);d=r.gpgpu.createBufferFromTexture(g.texture.texture,...lv(o))}if(r.pendingRead.set(e,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const g=yield Promise.all([r.read(c.real.dataId),r.read(c.imag.dataId)]);f=Zo(g[0],g[1])}else if(null==d)f=r.getValuesFromTexture(e);else{const g=ce(o);f=r.gpgpu.downloadFloat32MatrixFromBuffer(d,g)}if(null!=h&&r.disposeIntermediateTensorInfo(h),null!=d){const g=r.gpgpu.gl;Le(g,()=>g.deleteBuffer(d))}const p=r.convertAndCacheOnCPU(e,f),m=r.pendingRead.get(e);return r.pendingRead.delete(e),m.forEach(g=>g(p)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&Na().removeDataId(e,r),r.pendingDeletes--),p})()}readToGPU(e,r={}){const s=this.texData.get(e),{values:i,shape:o,slice:a,dtype:l,isPacked:c,texture:u}=s;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let p;p=c?new Jl(o,Xu):new ea(o,Xu);const m=this.runWebGLProgram(p,[{dataId:e,shape:o,dtype:l}],l),g=this.readToGPU(m,r);return this.disposeIntermediateTensorInfo(m),g}if(null==u)throw null!=i?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,r.customTexShape),h=Na().makeTensorFromDataId(d.dataId,d.shape,d.dtype),f=this.texData.get(d.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const r=this.readSync(e.dataId);let s=r;if("string"===e.dtype)try{s=r.map(i=>pu(i))}catch(i){throw new Error("Failed to decode encoded string bytes into utf-8")}return Nt(e.shape,e.dtype,s)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!x_e(s))throw ae().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:i}=this.texData.get(e),o=ce(r);if(ae().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),p=this.texData.get(f.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...lv(r)).subarray(0,o);return this.disposeIntermediateTensorInfo(f),m}const a=ae().getBool("WEBGL_PACK")&&!0===i,l=a?mI(r):r,c=a?new Pve(l):new Fve(l),u=this.runWebGLProgram(c,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const s=this.activeTimers,i=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=i,o=!0):this.activeTimers.push(i),this.activeTimers=i,e();const a=cu(this.activeTimers.map(u=>u.query)).filter(u=>null!=u),l=cu(this.activeTimers.map(u=>u.name)).filter(u=>null!=u);this.activeTimers=s,o&&(this.programTimersStack=null);const c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return he(function*(){if(ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=yield Promise.all(a);c.kernelMs=function wee(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}(u),c.getExtraProfileInfo=()=>u.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:as(),endMs:null}}endTimer(e){return ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=as(),e)}getQueryTime(e){var r=this;return he(function*(){return ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:i,usage:o,isPacked:a,slice:l}=this.texData.get(e),c=l&&l.origDataId||e,u=this.dataRefCount.get(c);u>1?this.dataRefCount.set(c,u-1):(this.dataRefCount.delete(c),null!=r&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(r,i,o,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=l0e){return ae().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>null==this.texData.get(s.dataId).texture&&ce(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){Vs("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return s0e(e.shape,r)}packedUnaryOp(e,r,s){const i=new Jl(e.shape,r),o=this.compileAndRun(i,[e],s);return Na().makeTensorFromDataId(o.dataId,o.shape,o.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const i=S3(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(ae().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,R3,e.dtype);const r=new ea(e.shape,R3),s=this.compileAndRun(r,[e]);return Na().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}makeTensorInfo(e,r,s){let i;if("string"===r&&null!=s&&s.length>0&&Nh(s[0])){const o=s.map(a=>Ta(a));i=this.write(o,e,r)}else i=this.write(s,e,r);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:r}}makeOutput(e,r,s){const{dataId:i}=this.makeTensorInfo(e,r,s);return Na().makeTensorFromDataId(i,e,r,this)}unpackTensor(e){const r=new r0e(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new zbe(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[Hu(e.shape),...ju(e.shape)],i={dtype:e.dtype,shape:s,dataId:e.dataId},o=[Hu(r),...ju(r)],a=new T3(o,s),u=this.runWebGLProgram(a,[i],e.dtype,[s],!0);return{dataId:u.dataId,shape:r,dtype:u.dtype}}decode(e,r){const s=this.texData.get(e),{isPacked:i,shape:o,dtype:a}=s;null!=r&&S(ce(o)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=mI(o);let c;c=i?new Ove(l):new Mve(l);const d=[null!=r?r:lv(l)];return{dtype:a,shape:o,dataId:this.runWebGLProgram(c,[{shape:l,dtype:a,dataId:e}],a,d,!0,r).dataId}}runWebGLProgram(e,r,s,i,o=!1,a){const l=this.makeTensorInfo(e.outputShape,s),c=this.texData.get(l.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===zu.DENSE){const y=null!=a?a:lv(e.outputShape);c.texShape=y.map(v=>2*v)}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===ce(l.shape))return c.values=Sr(l.dtype,0),l;const u=[],d=r.map(y=>{if("complex64"===y.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let v=this.texData.get(y.dataId);if(null==v.texture){if(!e.packedInputs&&ce(y.shape)<=ae().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:v.values};e.packedInputs&&(v.isPacked=!0,v.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!v.isPacked!=!!e.packedInputs)y=v.isPacked?this.unpackTensor(y):this.packTensor(y),u.push(y),v=this.texData.get(y.dataId);else if(v.isPacked&&!hv(v.shape,y.shape)){const b=y,w=y.shape;y.shape=v.shape,y=this.packedReshape(y,w),u.push(y),v=this.texData.get(y.dataId),b.shape=w}return{shape:y.shape,texData:v,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:c,isUniform:!1},f=function Rve(n,t,e){let r="";t.concat(e).forEach(o=>{const a=null!=o.texData&&null!=o.texData.slice&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:d}=vI(n.packedInputs,o.shape,l);let h="",f="",p="";if(1===u.length&&n.packedInputs){const w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${w[0]>1}_${w[1]>1}`}else if(2!==u.length||n.packedInputs){if(u.length>2&&!n.packedInputs){const w=Je(u);p=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}}else f=`${u[0]>1}_${u[1]>1}`;const m=o.shape.length,g=2===u.length&&Ut(o.shape,l),_=1===ce(o.shape),y=xu(o.shape,e.shape),v=!n.packedInputs&&m===e.shape.length&&Ut(l,e.texData.texShape);r+=`${m}_${v}_${c?d:""}_${u.length}_${_}_${y}_${g}_${h}_${f}_${p}_${n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`}_${a}`}else r+=`${o.shape}_${o.isUniform?"uniform":o.texData.texShape}_${a}`});let i=n.constructor.name;return i+="_"+r+"_"+n.userCode+`${ae().getNumber("WEBGL_VERSION")}`,i}(e,d,h),p=this.getAndSaveBinary(f,()=>function Nve(n,t,e,r){const s=e.map((u,d)=>{const h={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:!u.isUniform&&u.texData.isPacked,flatOffset:null};return null!=u.texData&&null!=u.texData.slice&&u.texData.slice.flatOffset>0&&(h.flatOffset=u.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),i=s.map(u=>u.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=K_e(s,o,t),l=function D_e(n,t){const e=Jo(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Le(n,()=>n.shaderSource(e,t)),Le(n,()=>n.compileShader(e)),ae().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw l3(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,a),c=n.createProgram(l);return ae().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},y3(n,t,c))}(this.gpgpu,e,d,h)),m=null!=this.activeTimers;let g;m&&(g=this.startTimer()),ae().get("ENGINE_COMPILE_ONLY")||function Ave(n,t,e,r,s){t.program.enableShapeUniforms||(_3(t.inShapeInfos,e),_3([t.outShapeInfo],[r]));const i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(t.webGLProgram),1===ae().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN),e.forEach((l,c)=>{const u=t.program.variableNames[c],d=t.uniformLocations[u],h=t.uniformLocations[`offset${u}`],f=t.inShapesLocations[`${u}Shape`],p=t.inTexShapesLocations[`${u}TexShape`];if(f){const{uniformShape:m}=vI(t.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(f,new Int32Array(m));break;case 2:n.gl.uniform2iv(f,new Int32Array(m));break;case 3:n.gl.uniform3iv(f,new Int32Array(m));break;case 4:n.gl.uniform4iv(f,new Int32Array(m))}}if(p&&n.gl.uniform2i(p,l.texData.texShape[0],l.texData.texShape[1]),null!=d){if(l.isUniform){if(ce(l.shape)<2)n.gl.uniform1f(d,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(d,m)}return}null!=l.texData.slice&&null!=h&&n.gl.uniform1i(h,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,d,c)}});const a=t.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const l=Je(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l))}}t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s&&t.program.customUniforms.forEach((l,c)=>{const u=t.customUniformLocations[c],d=s[c];if("float"===l.type)n.gl.uniform1fv(u,d);else if("vec2"===l.type)n.gl.uniform2fv(u,d);else if("vec3"===l.type)n.gl.uniform3fv(u,d);else if("vec4"===l.type)n.gl.uniform4fv(u,d);else if("int"===l.type)n.gl.uniform1iv(u,d);else if("ivec2"===l.type)n.gl.uniform2iv(u,d);else if("ivec3"===l.type)n.gl.uniform3iv(u,d);else{if("ivec4"!==l.type)throw Error(`uniform type ${l.type} is not supported yet.`);n.gl.uniform4iv(u,d)}}),n.executeProgram()}(this.gpgpu,p,d,h,i),u.forEach(y=>this.disposeIntermediateTensorInfo(y)),m&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const _=ae().get("WEBGL_FLUSH_THRESHOLD");if(_>0){const y=as();y-this.lastGlFlushTime>_&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!ae().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===o){const y=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),y}return l}compileAndRun(e,r,s,i,o=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,i,o)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ae().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=te(()=>{if(!ae().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ae().getBool("DEBUG");ae().set("DEBUG",!1);const r=this.abs(lt(1e-8)).dataSync()[0];if(ae().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:i,values:o,texture:a,usage:l,isPacked:c}=r;if(null!=a)return;const u=null!=this.activeTimers;let d;u&&(d=as());let h=r.texShape;if(null==h&&(h=function L_e(n,t=!1){let e=ae().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(e*=2,1===(n=n.map((s,i)=>i>=n.length-2?xP(n[i]):n[i])).length&&(n=[2,n[0]])),2!==n.length&&(n=Sa(n).newShape);let r=ce(n);if(n.length<=1&&r<=e)return[1,r];if(2===n.length&&n[0]<=e&&n[1]<=e)return n;if(3===n.length&&n[0]*n[1]<=e&&n[2]<=e)return[n[0]*n[1],n[2]];if(3===n.length&&n[0]<=e&&n[1]*n[2]<=e)return[n[0],n[1]*n[2]];if(4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e)return[n[0]*n[1]*n[2],n[3]];if(4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e)return[n[0],n[1]*n[2]*n[3]];if(t){const s=Hu(n);let i=2,o=2;return n.length&&([i,o]=ju(n)),r=s*(i/2)*(o/2),iC(r).map(a=>2*a)}return iC(r)}(s,c),r.texShape=h),null!=o){const f=mI(s);let p,m=h[1],g=h[0];const _=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(c||!_)&&([m,g]=Uu(h[0],h[1])),p=c?new Lve(f,_):new $ve(f,_);const y=_?[g,m]:h,v=this.makeTensorInfo(y,i),b=this.texData.get(v.dataId);b.usage=_?Cs.PIXELS:Cs.UPLOAD,b.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),m,g,o);const E=this.runWebGLProgram(p,[v],i,[[g,m]],!0),k=this.texData.get(E.dataId);r.texShape=k.texShape,r.isPacked=k.isPacked,r.usage=k.usage,ae().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(r.texture=k.texture,r.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(v),u&&(this.uploadWaitMs+=as()-d)}else{const f=this.acquireTexture(h,l,i,c);r.texture=f}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:i}=s;return this.releaseGPUData(e),null!=r&&(s.values=function h0e(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}throw new Error(`Unknown dtype ${t}`)}(r,i)),s.values}acquireTexture(e,r,s,i){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,i)}computeBytes(e,r){return e[0]*e[1]*oC(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return he(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(e.binaryCache)){const i=new Promise(o=>{try{e.checkCompletion_(s),o(!0)}catch(a){throw a}});r.push(i)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return he(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield p$(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(l3(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:r,customUniformLocations:s,infLoc:i,nanLoc:o,inShapesLocations:a,inTexShapesLocations:l,outShapeLocation:c,outShapeStridesLocation:u,outTexShapeLocation:d}=y3(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=r,e.customUniformLocations=s,e.infLoc=i,e.nanLoc=o,e.inShapesLocations=a,e.inTexShapesLocations=l,e.outShapeLocation=c,e.outShapeStridesLocation=u,e.outTexShapeLocation=d}}}return n.nextDataId=0,n})();t2()&&P2("webgl",()=>new d0e,2);class Yu{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=gt(e,r),this.enableShapeUniforms=ds(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class mp{constructor(t,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=gt(e,r);const i=this.outputShape.length;this.enableShapeUniforms=ds(i);let o="";if(s)if(0===i||1===ce(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${Zt(i)} coords = getOutputCoords();\n        `,1===i)o+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=Yr("coords",i);o+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[i-2]} + 1) >= outShape[${i} - 2];\n            bool nextColOutOfBounds =\n              (${l[i-1]} + 1) >= outShape[${i} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function hs(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const m0e={kernelName:Jh,backendName:"webgl",kernelFunc:hs};function Ka(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,i=e.makeTensorInfo(r.shape,"complex64"),o=e.texData.get(i.dataId),a=hs({inputs:{x:r},backend:e}),l=hs({inputs:{x:s},backend:e});return o.complexTensorInfos={real:a,imag:l},i}const g0e={kernelName:vC,backendName:"webgl",kernelFunc:Ka},O3="return (a < 0.) ? b * a : a;",F3="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",_0e={kernelName:dy,backendName:"webgl",kernelFunc:function y0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:i}=r,o=e.makeTensorInfo([],"float32",Ia(i,"float32")),a=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mp(F3,s.shape,o.shape):new Yu(O3,s.shape,o.shape),l=e.runWebGLProgram(a,[s,o],"float32");return e.disposeIntermediateTensorInfo(o),l}},P3="return (a < 0.) ? b * a : a;",$3="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",b0e={kernelName:Ny,backendName:"webgl",kernelFunc:function v0e(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t,i=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mp($3,r.shape,s.shape):new Yu(P3,r.shape,s.shape);return e.runWebGLProgram(i,[r,s],"float32")}};function $t({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:i})=>{const{x:o}=s,a=i,l=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&null!=e){const d=a.texData.get(o.dataId),h=e(d.values,l);return a.makeTensorInfo(o.shape,l,h)}let u;return u=ae().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Jl(o.shape,t):new ea(o.shape,n),a.runWebGLProgram(u,[o],l)}}function Tr({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(r&&"complex64"===l.dtype){const p=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[g,_]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(v=>{const[b,w]=v,C={dataId:b.dataId,dtype:b.dtype,shape:l.shape},E={dataId:w.dataId,dtype:w.dtype,shape:c.shape},k=new Yu(n,l.shape,c.shape);return u.runWebGLProgram(k,[C,E],_s(b.dtype,w.dtype))}),y=Ka({inputs:{real:g,imag:_},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(_),y}const d=i||_s(l.dtype,c.dtype);if(("string"===l.dtype||"string"===c.dtype||u.shouldExecuteOnCPU([l,c]))&&null!=s){const p=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,g="string"===l.dtype?Ul(p):p,_="string"===l.dtype?Ul(m):m,[y,v]=s(l.shape,c.shape,g,_,d),b=u.makeTensorInfo(v,d);return u.texData.get(b.dataId).values=y,b}let f;return f=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new mp(t,l.shape,c.shape,e):new Yu(n,l.shape,c.shape),u.runWebGLProgram(f,[l,c],d)}}function vv(n,t=!1){if("linear"===n)return"return x;";if("relu"===n)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===n)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===n)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===n)return t?$3:P3;if("leakyrelu"===n)return t?F3:O3;if("sigmoid"===n)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class L3{constructor(t,e,r,s=!1,i=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=ds(this.outputShape.length);const d=Math.ceil((s?t[1]:t[2])/2),h=s?"i * 2, rc.y":"rc.y, i * 2",f=i?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",_="";a&&(g=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,_="result = activation(result);");const y=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let v="rc.x",b="rc.x";t[0]<e[0]?v=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(b=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${g}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${d}; i++) {\n          int batchA = ${v};\n          int batchB = ${b};\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${f});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${m[0]});\n          result += (${p[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${_}\n\n        setOutput(result);\n      }\n    `}}class B3{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=gt(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const z3="return a * b;";function wI(n){const{inputs:t,backend:e}=n,{a:r,b:s}=t,i=_s(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),c=new B3("return areal * breal - aimag * bimag;",r.shape,s.shape),u=new B3("return areal * bimag + aimag * breal;",r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=e.runWebGLProgram(c,d,"float32"),f=e.runWebGLProgram(u,d,"float32"),p=Ka({inputs:{real:h,imag:f},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),[c,u]=xbe(r.shape,s.shape,a.values,l.values,i),d=e.makeTensorInfo(u,i);return e.texData.get(d.dataId).values=c,d}let o;return o=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mp(z3,r.shape,s.shape):new Yu(z3,r.shape,s.shape),e.runWebGLProgram(o,[r,s],i)}const C0e={kernelName:df,backendName:"webgl",kernelFunc:wI};function Oe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:i}=r,o=e,a=ce(s.shape),l=CP(i,a),c=ce(l);S(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(s.dataId);return!u.isPacked||hv(s.shape,l)||null!==u.texture&&hv(u.shape,l)?(o.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function D0e(n,t,e){const r=[Hu(n.shape),...ju(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},i=[Hu(t),...ju(t)],o=new T3(i,r),c=e.runWebGLProgram(o,[s],n.dtype,[r],!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(s,l,o)}const S0e={kernelName:Ay,backendName:"webgl",kernelFunc:Oe};class U3{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=t;this.outputShape=[s,o];const a=4*Math.floor(r/4),l=r%4;let c="sumValue += dot(values, ones);";if(null!=e){const d=1/e;c=`sumValue += dot(values * ${uu(d)?d.toPrecision(2):d}, ones);`}let u="";i%r>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class E0e{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=t;this.outputShape=[s,o];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?c="sumValue":"prod"===e?c="prodValue":"all"===e?c="allValue":"any"===e&&(c="anyValue");const u=4*Math.floor(r/4),d=r%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,f="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");let p="";i%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${c});\n      }\n    `}}function ec(n,t,e,r){const s=function I0e(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],r=I_(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}(n.shape);let i=n;for(let o=0;o<s.length;o++){const{inSize:a,windowSize:l,outSize:c}=s[o];let u,d;u="mean"===e?0===o?new U3({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new U3({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):new E0e({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},e),d=i,i=r.runWebGLProgram(u,[i],t),d.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(d)}return i}class T0e{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let o=0;o<r.length;o++)r[o]=t[e[o]];this.outputShape=r,this.rank=r.length;const s=Zt(this.rank),i=function k0e(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<n.length;s++)r[n[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}class N0e{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let u=0;u<r.length;u++)r[u]=t[e[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Zt(this.rank),i=I3("rc",this.rank),o=new Array(this.rank);for(let u=0;u<e.length;u++)o[e[u]]=i[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${l}) {\n        result[1] = ${c};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${c};\n        if(${l}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function bv(n,t,e){const r=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new N0e(n.shape,t):new T0e(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function xv(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;return function A0e(n,t,e,r){const i=n.shape.length,o=It(t,n.shape);let a=o;const l=Sn(a,i),c=null!=l;let u=n;c&&(u=bv(n,l,r),a=An(a.length,i)),Ir("sum",a,i);const[d,h]=yr(u.shape,a);let f=d;e&&(f=Bn(d,o));const p=ce(h),_=Oe({inputs:{x:u},attrs:{shape:[ce(n.shape)/p,p]},backend:r}),v=ec(_,fD(n.dtype),"sum",r),b=Oe({inputs:{x:v},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(v),c&&r.disposeIntermediateTensorInfo(u),b}(s,i,o,e)}const R0e={kernelName:$y,backendName:"webgl",kernelFunc:xv};function kr(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{perm:i}=r,o=e,l=new Array(s.shape.length);for(let u=0;u<l.length;u++)l[u]=s.shape[i[u]];let c;if(o.shouldExecuteOnCPU([s])){const d=o.texData.get(s.dataId).values,h=xI(d,s.shape,s.dtype,i,l);c=o.makeTensorInfo(l,s.dtype),o.texData.get(c.dataId).values=h}else c=bv(s,i,o);return c}const M0e={kernelName:zy,backendName:"webgl",kernelFunc:kr};function wv({a:n,b:t,transposeA:e,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=t.shape.length,d=e?n.shape[c-2]:n.shape[c-1],h=r?t.shape[u-1]:t.shape[u-2],f=e?n.shape[c-1]:n.shape[c-2],p=r?t.shape[u-2]:t.shape[u-1],m=n.shape.slice(0,-2),g=t.shape.slice(0,-2),_=ce(m),y=ce(g),b=gt(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,p]);S(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);const w=e?[_,d,f]:[_,f,d],C=r?[y,p,h]:[y,h,p],E=Oe({inputs:{x:n},backend:s,attrs:{shape:w}}),k=Oe({inputs:{x:t},backend:s,attrs:{shape:C}}),M=[E,k],O=Math.max(_,y),K=e?E.shape[1]:E.shape[2],X=null!=i,Q=null!=o,re="leakyrelu"===l,ne=null!=l?vv(l,!0):null;let G;if((1===f||1===p)&&K>1e3&&!1===(X||Q||re||null!=ne)){let J=E,ue=k;e&&(J=kr({inputs:{x:E},backend:s,attrs:{perm:[0,2,1]}}),M.push(J)),r&&(ue=kr({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),M.push(ue));const De=1===p;let be=J;1!==p&&(be=Oe({inputs:{x:J},backend:s,attrs:{shape:[O,K,1]}}),M.push(be));const Se=1===p?2:1;let Ie=ue;De&&(Ie=Oe({inputs:{x:ue},backend:s,attrs:{shape:[O,1,K]}}),M.push(Ie));const $e=wI({inputs:{a:be,b:Ie},backend:s});G=xv({inputs:{x:$e},backend:s,attrs:{axis:Se,keepDims:!0}}),M.push($e)}else{const J=_s(n.dtype,t.dtype),ue=new L3(w,C,[O,f,p],e,r,X,ne,Q,re),me=[E,k];if(null!=i&&me.push(i),Q&&me.push(o),re){const De=s.makeTensorInfo([],"float32",Ia(a,"float32"));me.push(De),M.push(De)}G=s.runWebGLProgram(ue,me,J)}const W=Oe({inputs:{x:G},backend:s,attrs:{shape:b}});M.push(G);for(const J of M)s.disposeIntermediateTensorInfo(J);return W}const F0e={kernelName:Wy,backendName:"webgl",kernelFunc:function O0e(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;return wv({a:s,b:i,transposeA:l,transposeB:c,backend:e,bias:o,preluActivationWeights:a,leakyreluAlpha:d,activation:u})}},j3="return abs(x);",$0e={kernelName:Wg,backendName:"webgl",kernelFunc:function P0e(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const i=e.texData.get(r.dataId),o=S3(i.values);return e.makeTensorInfo(r.shape,r.dtype,o)}let s;return s=ae().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Jl(r.shape,j3):new ea(r.shape,j3),e.runWebGLProgram(s,[r],r.dtype)}},V0e=$t({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),B0e={kernelName:Mh,backendName:"webgl",kernelFunc:V0e},U0e=$t({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),H0e={kernelName:Oh,backendName:"webgl",kernelFunc:U0e},W3="return a + b;",j0e=Tr({opSnippet:W3,packedOpSnippet:W3,supportsComplex:!0,cpuKernelImpl:nbe}),W0e={kernelName:hu,backendName:"webgl",kernelFunc:j0e};class G0e{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`float v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class q0e{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`vec4 v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const K0e={kernelName:fC,backendName:"webgl",kernelFunc:function Cv(n){const{inputs:t,backend:e}=n,r=t;if(1===r.length)return hs({inputs:{x:r[0]},backend:e});if(r.length>ae().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=Cv({inputs:r.slice(0,l),backend:e}),u=Cv({inputs:r.slice(l),backend:e});return Cv({inputs:[c,u],backend:e})}const s=r.map(l=>l.dtype).reduce((l,c)=>_s(l,c)),i=r.map(l=>l.shape),a=ae().getBool("WEBGL_PACK")?new q0e(r[0].shape,i):new G0e(r[0].shape,i);return e.runWebGLProgram(a,r,s)}},Y0e={kernelName:"All",backendName:"webgl",kernelFunc:function X0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=It(i,s.shape);let c=l;const u=Sn(c,a);let d=s;null!=u&&(d=kr({inputs:{x:s},backend:e,attrs:{perm:u}}),c=An(c.length,a)),Ir("all",c,a);const[h,f]=yr(d.shape,c),m=Oe({inputs:{x:d},backend:e,attrs:{shape:[-1,ce(f)]}}),g=ec(m,m.dtype,"all",e);let _;return _=Oe(o?{inputs:{x:g},backend:e,attrs:{shape:Bn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=u&&e.disposeIntermediateTensorInfo(d),_}},Q0e={kernelName:"Any",backendName:"webgl",kernelFunc:function Z0e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=It(i,s.shape);let c=l;const u=Sn(c,a);let d=s;null!=u&&(d=kr({inputs:{x:s},backend:e,attrs:{perm:u}}),c=An(c.length,a)),Ir("any",c,a);const[h,f]=yr(d.shape,c),m=Oe({inputs:{x:d},backend:e,attrs:{shape:[-1,ce(f)]}}),g=ec(m,m.dtype,"any",e);let _;return _=Oe(o?{inputs:{x:g},backend:e,attrs:{shape:Bn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=u&&e.disposeIntermediateTensorInfo(d),_}};class J0e{constructor(t,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:i,outSize:o}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class exe{constructor(t,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,S(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Zt(l),u=Yr("coords",l);let d,h;if(1===o){h=l+1;const k=Zt(h);d=`\n        ${k} sourceLocR = ${k}(${u.join()}, 0);\n        ++${u[l-1]};\n        ${k} sourceLocG = ${k}(${u.join()}, 0);\n        ++${u[l-2]};\n        ${k} sourceLocA = ${k}(${u.join()}, 0);\n        --${u[l-1]};\n        ${k} sourceLocB = ${k}(${u.join()}, 0);\n        --${u[l-2]};`}else h=l,d=`\n        ${c} sourceLocR = coords;\n        ++${u[l-1]};\n        ${c} sourceLocG = coords;\n        ++${u[l-2]};\n        ${c} sourceLocA = coords;\n        --${u[l-1]};\n        ${c} sourceLocB = coords;\n        --${u[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,h),p="."+f[h-1],m=f.map(k=>"int "+k),g=Yr("sourceLocR",h-1).concat("inIdx.r"),_=Yr("sourceLocG",h-1).concat("inIdx.g"),y=Yr("sourceLocB",h-1).concat("inIdx.b"),v=Yr("sourceLocA",h-1).concat("inIdx.a"),b="max"===r?"greaterThan":"lessThan",w=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${_.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,C=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${_.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,E=s?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${f.join()}),\n                                          vec2(${f.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${f.join()}),\n                               vec2(${f.slice(-2).join()}));\n      }\n      ${E}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${C};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${C};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function G3(n,t,e,r=null){let s=t.shape[0],i=t.shape[1];null!=r&&(s=r.shape[0],i=r.shape[1]);const o=I_(i),a={windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},l=new J0e(a,e,null==r),c=[t];null!=r&&c.push(r);const u=n.runWebGLProgram(l,c,"int32");if(1===u.shape[1])return u;const d=G3(n,t,e,u);return n.disposeIntermediateTensorInfo(u),d}function q3(n,t,e,r=null){const s=null!=r?r.shape:t.shape,o=I_(s[s.length-1]),a=new exe(s,o,e,null==r),c=n.runWebGLProgram(a,null==r?[t]:[t,r],"int32");if(c.shape.length===t.shape.length){const u=q3(n,t,e,c);return n.disposeIntermediateTensorInfo(c),u}return c}function K3(n,t,e,r){const s=[e];if(Ir("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!ae().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],o=n.texData.get(t.dataId);let l=t;null!==o&&o.isPacked&&(l=n.unpackTensor(t),i.push(l));const[c,u]=yr(l.shape,s),d=ce(u),h=Oe({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});i.push(h);const f=G3(n,h,r);i.push(f);const p=Oe({inputs:{x:f},backend:n,attrs:{shape:c}});return i.forEach(m=>n.disposeIntermediateTensorInfo(m)),p}return q3(n,t,r)}const nxe={kernelName:Gg,backendName:"webgl",kernelFunc:function txe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;let o=It(i,s.shape);const a=Sn(o,s.shape.length);let l=s;const c=[];null!=a&&(l=kr({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=An(o.length,l.shape.length)),Ir("argMax",[o[0]],l.shape.length);const u=K3(e,l,o[0],"max");return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),u}},sxe={kernelName:qg,backendName:"webgl",kernelFunc:function rxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;let o=It(i,s.shape);const a=Sn(o,s.shape.length);let l=s;const c=[];null!=a&&(l=kr({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=An(o.length,l.shape.length)),Ir("argMin",[o[0]],l.shape.length);const u=K3(e,l,o[0],"min");return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),u}},oxe=$t({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),axe={kernelName:Fh,backendName:"webgl",kernelFunc:oxe},cxe=$t({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),uxe={kernelName:Ph,backendName:"webgl",kernelFunc:cxe},hxe=$t({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),fxe={kernelName:$h,backendName:"webgl",kernelFunc:hxe},gxe=Tr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),yxe={kernelName:Vh,backendName:"webgl",kernelFunc:gxe},vxe=$t({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),bxe={kernelName:Lh,backendName:"webgl",kernelFunc:vxe};class gp{constructor(t,e,r,s=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,u=t.dilationWidth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,f=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const m="avg"===e;let y="0.0";if(m||(y="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${f}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?i?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let b=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(b="avgValue / count");const w=4*Math.floor(o/4),C=o%4,E=`\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${f}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${E}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${E}\n          } else if (${2===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${E}\n          } else if (${3===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${E}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class CI{constructor(t,e,r,s=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideDepth,l=t.strideHeight,c=t.strideWidth,u=t.dilationDepth,d=t.dilationHeight,h=t.dilationWidth,f=t.effectiveFilterDepth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,_=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const v="avg"===e;let b="0.0";if(v||(b="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${c});\n        const ivec3 pads = ivec3(${g}, ${_}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${f};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let C=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(C="avgValue / count");const E=4*Math.floor(o/4),k=o%4,M=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${c});\n      const ivec3 pads = ivec3(${g}, ${_}, ${y});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${f};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${E}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${M}\n            }\n\n            int xC = xCCorner + ${E};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${M}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${M}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${M}\n            }\n          }\n          setOutput(${C});\n        }\n      }\n    `}}const wxe={kernelName:Kg,backendName:"webgl",kernelFunc:function xxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;fp(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Er(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=ui(s.shape,i,o,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&Ut(u.inShape,u.outShape))return hs({inputs:{x:s},backend:e});const d=new gp(u,"avg",!1);return e.runWebGLProgram(d,[s],"float32")}},Dxe={kernelName:Xg,backendName:"webgl",kernelFunc:function Cxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r,d=Go(s.shape,i,o,[1,1,1],a,l,c),h=new CI(d,"avg",!1);return e.runWebGLProgram(h,[s],"float32")}};class Sxe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const l=t.effectiveFilterHeight,c=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-t.padInfo.top}, ${c-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Exe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-t.padInfo.front}, ${h-1-t.padInfo.top}, ${f-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Txe={kernelName:yC,backendName:"webgl",kernelFunc:function Ixe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=Go(o.shape,a,l,[1,1,1],c,u),f=new Exe(h);return e.runWebGLProgram(f,[s],o.dtype)}},Nxe={kernelName:gC,backendName:"webgl",kernelFunc:function kxe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i;fp([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=ui(o.shape,a,l,1,c),d=new Sxe(u);return e.runWebGLProgram(d,[s],o.dtype)}},Rxe={kernelName:Yg,backendName:"webgl",kernelFunc:function Axe(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i}=t,{transposeA:o,transposeB:a}=r;return wv({a:s,b:i,transposeA:o,transposeB:a,backend:e})}};class Mxe{constructor(t,e,r,s,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],gt(t,e),gt(t,r);let a="0.0";null!=s&&(gt(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=i&&(gt(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${o}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Oxe{constructor(t,e,r,s,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],gt(t,e),gt(t,r);let a="vec4(0.0)";null!=s&&(gt(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=i&&(gt(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${o}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Fxe={kernelName:ly,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,mean:s,variance:i,offset:o,scale:a}=n;S(s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==o||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const c=[r,s,i];let u=null;null!=o&&(u=o.shape,c.push(o));let d=null;null!=a&&(d=a.shape,c.push(a));const h=ae().getBool("WEBGL_PACK_NORMALIZATION")?new Oxe(r.shape,s.shape,i.shape,u,d,l):new Mxe(r.shape,s.shape,i.shape,u,d,l);return t.runWebGLProgram(h,c,c[0].dtype)}};class Pxe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Zt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function $xe(n){if(1===n)return"sourceLoc";if(n<=6)return DI.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((o,a)=>`sourceLoc.${DI[a]} = start[${a}] + coords.${DI[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const DI=["x","y","z","w","u","v"];class Lxe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Zt(this.rank),r=Yr("coords",this.rank),s=Yr("sourceLoc",this.rank),i=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,o=`getChannel(getSource(${s.join()}), ${i})`,a=`\n      result.x = ${o};\n      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${o};\n        --${s[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${o};\n        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((u,d)=>`start[${d}]`).join()});`:t.map((u,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}}function Qu(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,size:o}=r,[a,l]=a_(s,i,o);if($D(s,a,l),0===ce(l))return e.makeTensorInfo(l,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const d=e.texData.get(s.dataId),h=Tbe(d.values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,h)}const{isPacked:c}=e.texData.get(s.dataId),u=VD(s.shape,a,l);if(c||!u){const d=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Lxe(l):new Pxe(l);return e.runWebGLProgram(d,[s],s.dtype,[a])}return e.uploadToGPU(s.dataId),function Vxe(n,t,e,r){const s=r.texData.get(n.dataId),i=r.makeTensorInfo(e,n.dtype),o=r.texData.get(i.dataId);Object.assign(o,s),o.refCount=1,o.shape=e,o.dtype=n.dtype;let a=BD(t,Je(n.shape));s.slice&&(a+=s.slice.flatOffset),o.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),i}(s,a,l,e)}const Bxe={kernelName:Py,backendName:"webgl",kernelFunc:Qu},zxe={kernelName:Zg,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,crops:o}=r;S(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((y,v)=>y*v),l=jf(s.shape,i,a),c=Wf(l.length,i.length),u=Gf(s.shape,i,a),d=NS(o,i.length),h=AS(u,o,i.length),f=[],p=Oe({inputs:{x:s},backend:e,attrs:{shape:l}}),m=kr({inputs:{x:p},backend:e,attrs:{perm:c}}),g=Oe({inputs:{x:m},backend:e,attrs:{shape:u}}),_=Qu({inputs:{x:g},backend:e,attrs:{begin:d,size:h}});return f.push(p),f.push(m),f.push(g),f.forEach(y=>e.disposeIntermediateTensorInfo(y)),_}},Hxe={kernelName:_C,backendName:"webgl",kernelFunc:function Uxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o}=r,a=e.readSync(s.dataId),l=e.readSync(i.dataId),c=D3(a,l,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}},Wxe={kernelName:RP,backendName:"webgl",kernelFunc:function jxe(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,i=e.readSync(r.dataId),o=e.readSync(s.dataId),a=gt(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},X3=Tr({opSnippet:"return float(a != b);",cpuKernelImpl:Cbe,dtype:"bool"}),Gxe={kernelName:Sy,backendName:"webgl",kernelFunc:X3};function yp(n){const{inputs:t,backend:e}=n,{input:r}=t;return hs({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const qxe={kernelName:jC,backendName:"webgl",kernelFunc:yp},Yxe={kernelName:Bh,backendName:"webgl",kernelFunc:function SI(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return hs({inputs:{x:s},backend:e});const o=_r(s.shape),a=SI({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=Ka({inputs:{real:a,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const o=yp({inputs:{input:s},backend:e}),a=SI({inputs:{x:o},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(o),a}if(!DP(s.dtype,i)){const o=hs({inputs:{x:s},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:i}}if("int32"===i)return function Xxe(n,t){const e=new ea(n.shape,"return float(int(x));"),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===i){const o=e.makeTensorInfo([],"bool",Sr("bool",1)),l=X3({inputs:{a:s,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},Y3="return ceil(x);",Zxe=$t({opSnippet:Y3,packedOpSnippet:Y3,cpuKernelImpl:sbe}),Qxe={kernelName:zh,backendName:"webgl",kernelFunc:Zxe};class Jxe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class ewe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const nwe={kernelName:Uh,backendName:"webgl",kernelFunc:function twe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{clipValueMin:i,clipValueMax:o}=r;let a;return a=ae().getBool("WEBGL_PACK_CLIP")?new ewe(s.shape):new Jxe(s.shape),e.runWebGLProgram(a,[s],s.dtype,[[i],[o]])}};class rwe{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Z3(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const iwe={kernelName:Qg,backendName:"webgl",kernelFunc:function swe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=e.texData.get(r.dataId),i=new rwe(r.shape),o=[Z3(r,s.complexTensorInfos.real),Z3(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(i,o,o[0].dtype)}};class owe{constructor(t){this.outputShape=[],this.outputShape=yo(t,1),this.variableNames=t.map((o,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++)r.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${e[o-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class awe{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=yo(t,e);const r=this.outputShape,s=r.length,i=Zt(s),o=Yr("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((m,g)=>`T${g}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let m=1;m<l.length;m++)l[m]=l[m-1]+t[m][e];const c=a[e],u=a.slice(-2),d=a.join();let h=`if (${c} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${u.join()}));\n        }`;for(let m=1;m<l.length;m++){const g=l[m-1];h+=`\n        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {\n          return getChannel(\n            getT${m}(${Dv(a,c,g)}),\n            vec2(${Dv(u,c,g)}));\n        }`}const p=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${Dv(a,c,p)}),\n          vec2(${Dv(u,c,p)}));`,this.userCode=`\n      float getValue(${a.map(m=>"int "+m)}) {\n        ${h}\n      }\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${o}), 0., 0., 0.);\n\n        ${o[s-1]} = ${o[s-1]} + 1;\n        if (${o[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${o});\n        }\n\n        ${o[s-2]} = ${o[s-2]} + 1;\n        if (${o[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${o});\n        }\n\n        ${o[s-1]} = ${o[s-1]} - 1;\n        if (${o[s-2]} < ${r[s-2]} &&\n            ${o[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${o});\n        }\n        setOutput(result);\n      }\n    `}}function Dv(n,t,e){const r=n.indexOf(t);return n.map((i,o)=>o===r?`${i} - ${e}`:i).join()}function Sv(n){const{inputs:t,backend:e}=n,{input:r}=t;return hs({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const lwe={kernelName:FC,backendName:"webgl",kernelFunc:Sv};function Ju(n,t,e){const r=n[0].dtype;if("complex64"===r){const u=n.map(m=>yp({inputs:{input:m},backend:e})),d=n.map(m=>Sv({inputs:{input:m},backend:e})),h=Ju(u,t,e),f=Ju(d,t,e),p=Ka({inputs:{real:h,imag:f},backend:e});return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),d.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}let s=e.shouldExecuteOnCPU(n);if("string"===r&&(s=!0),s){const u=n.map(_=>{const y=ce(_.shape.slice(t));return Oe({inputs:{x:_},backend:e,attrs:{shape:[-1,y]}})}),d=u.map(_=>({vals:e.readSync(_.dataId),shape:_.shape})),h=yo(u.map(_=>_.shape),1),p=ibe(d,h,r,1===u[0].shape[0]),m=yo(n.map(_=>_.shape),t),g=e.makeTensorInfo(m,r,p);return u.forEach(_=>e.disposeIntermediateTensorInfo(_)),g}if(n.length>ae().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(n.length/2),d=Ju(n.slice(0,u),t,e),h=Ju(n.slice(u),t,e),f=Ju([d,h],t,e);return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),f}if(ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&n[0].shape.length>1){const u=new awe(n.map(d=>d.shape),t);return e.runWebGLProgram(u,n,r)}const{tensors2D:i,outShape:o}=function cwe(n,t,e){const r=yo(n.map(i=>i.shape),t);return{tensors2D:n.map(i=>Oe({inputs:{x:i},attrs:{shape:[-1,ce(i.shape.slice(t))]},backend:e})),outShape:r}}(n,t,e),a=new owe(i.map(u=>u.shape)),l=e.runWebGLProgram(a,i,r);i.forEach(u=>e.disposeIntermediateTensorInfo(u));const c=Oe({inputs:{x:l},attrs:{shape:o},backend:e});return e.disposeIntermediateTensorInfo(l),c}function Q3(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,i=It(s,t[0].shape)[0],o=yo(t.map(c=>c.shape),i);if(0===ce(o))return e.makeTensorInfo(o,t[0].dtype,[]);const a=t.filter(c=>ce(c.shape)>0);return 1===a.length?hs({inputs:{x:a[0]},backend:e}):(IS(a.map(c=>c.shape),i),Ju(a,i,e))}const uwe={kernelName:Jg,backendName:"webgl",kernelFunc:Q3};class J3{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,u=t.dilationHeight,d=t.dilationWidth,h=t.filterHeight,f=t.filterWidth,p=4*Math.floor(t.inChannels/4),m=t.inChannels%4,g="channelsLast"===t.dataFormat,_=g?1:2,y=g?2:3,v=g?3:1;let b="",w="";r&&(b=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,w="result = activation(result);");const C=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${v}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${_}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===m}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===m}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===m}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${C}\n        ${w}\n        setOutput(result);\n      }\n    `}}class dwe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,u=t.dilationWidth,d=t.filterDepth,h=t.filterHeight,f=t.filterWidth,p=4*Math.floor(t.inChannels/4),m=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${i}, ${o}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===m}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class hwe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=ds(this.outputShape.length);const{dataFormat:r}=e,s=Xr(),i="channelsLast"===r,o=i?0:1,a=i?1:2,l=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${t[1]} && pos < ${t[0]}) {`;let c="";for(let u=0;u<=1;u++)for(let d=0;d<=1;d++)c+=`\n          blockIndex = rc.y + ${d};\n          pos = rc.x + ${u};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${o}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${i}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+d}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+d}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${s.output} = result;\n      }\n    `}}function ez({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=r.texData.get(n.dataId),f="channelsLast"===e.dataFormat;let g;const _=[];if((1!=l[0]*l[1]*l[2]&&1!==e.outChannels||!(e.inChannels>1e3))&&c.isPacked&&f&&null!=c.texture&&l[2]%2!=0&&Ut(c.shape.slice(-3),l.slice(-3))){const w={dataId:n.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:n.dtype},C=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,S(hv(c.shape,w.shape),()=>`packed reshape ${c.shape} to ${w.shape} isn't free`);const E=Oe({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});_.push(E);const k=wv({a:w,b:E,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),M=r.texData.get(k.dataId);S(M.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=C,M.shape=e.outShape,g=hs({inputs:{x:k},backend:r}),g.shape=e.outShape,_.push(k)}else{const w=Oe({inputs:{x:n},backend:r,attrs:{shape:[1,f?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],e.inChannels]}}),C=Oe({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),E=wv({a:w,b:C,transposeA:!1,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});g=Oe({inputs:{x:E},backend:r,attrs:{shape:e.outShape}}),_.push(w),_.push(C),_.push(E)}for(const b of _)r.disposeIntermediateTensorInfo(b);return g}function tz({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:d,outHeight:h,dataFormat:f}=e,p="channelsLast"===f,m=l*c*u,g=h*d,_=[m,g],b=[],w=Oe({inputs:{x:n},backend:r,attrs:{shape:n.shape.slice(1)}}),C=Oe({inputs:{x:t},backend:r,attrs:{shape:[1,m,ce(t.shape)/m]}});b.push(w),b.push(C);const E=new hwe(_,e),M=r.runWebGLProgram(E,[w],"float32",[w.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),O=Oe({inputs:{x:M},backend:r,attrs:{shape:[1,_[0],_[1]]}});b.push(M),b.push(O);const K=null!=s,X=null!=i,Q="leakyrelu"===a,re=a?vv(a,!0):null,ne=new L3(O.shape,C.shape,[1,g,e.outChannels],!0,!1,K,re,X,Q),V=[O,C];if(s&&V.push(s),X&&V.push(i),Q){const ue=r.makeTensorInfo([],"float32",Ia(o,"float32"));V.push(ue),b.push(ue)}const G=r.runWebGLProgram(ne,V,"float32"),J=Oe({inputs:{x:G},backend:r,attrs:{shape:p?[1,h,d,e.outChannels]:[1,e.outChannels,h,d]}});b.push(G);for(const ue of b)r.disposeIntermediateTensorInfo(ue);return J}const pwe={kernelName:ey,backendName:"webgl",kernelFunc:function fwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,d=qo(l),h=gr(s.shape,i.shape,o,c,a,u,!1,d);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(ae().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])f=tz({x:s,filter:i,convInfo:h,backend:e});else{const m=new J3(h);f=e.runWebGLProgram(m,[s,i],"float32")}else f=ez({x:s,filter:i,convInfo:h,backend:e});const p=Oe({inputs:{x:f},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(f),p}};class mwe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class gwe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,o="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${o?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${o?1:2}], coords[${o?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ywe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _we{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${r-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const bwe={kernelName:bC,backendName:"webgl",kernelFunc:function vwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,d=qo(l),h=gr(s.shape,u,o,1,a,c,!1,d),f=new mwe(h);return e.runWebGLProgram(f,[s,i],"float32")}},wwe={kernelName:ty,backendName:"webgl",kernelFunc:function xwe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,d=qo(c),h=gr(o,i.shape,a,1,l,u,!1,d),f=new gwe(h);return e.runWebGLProgram(f,[s,i],"float32")}},Dwe={kernelName:ny,backendName:"webgl",kernelFunc:function Cwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=r,c=Ra(s.shape,i.shape,o,l,a),u=new dwe(c);return e.runWebGLProgram(u,[s,i],"float32")}},Ewe={kernelName:xC,backendName:"webgl",kernelFunc:function Swe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,filterShape:l}=r,c=Ra(s.shape,l,o,1,a),u=new ywe(c);return e.runWebGLProgram(u,[s,i],"float32")}},Twe={kernelName:wC,backendName:"webgl",kernelFunc:function Iwe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{pad:o,strides:a,inputShape:l}=r,c=Ra(l,i.shape,a,1,o),u=new _we(c);return e.runWebGLProgram(u,[s,i],"float32")}},Nwe=$t({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),Awe={kernelName:Hh,backendName:"webgl",kernelFunc:Nwe},Rwe=$t({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Mwe={kernelName:jh,backendName:"webgl",kernelFunc:Rwe};class Owe{constructor(t,e,r,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=t,[u]=e,[d,h]=r;this.outputShape=[u,d,h,c];const f="bilinear"===s?1:0,[p,m]=[a-1+".0",l-1+".0"],[g,_,y]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[v,b,w]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${v});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${_};\n        float width_scale = ${b};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${i}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${i}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${f} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const Fwe={kernelName:DC,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=r,u=new Owe(s.shape,i.shape,a,l,c);return e.runWebGLProgram(u,[s,i,o],"float32")}};class nz{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=t;const s=t.length,i=e?"1.0":`getX(${rz(s,"coords")})`,o=t[t.length-1];let a="",l="";e?(a=r?"end != "+(o-1):"end != 0",l=r?"end + 1":"end - 1"):(a=r?`end + pow2 < ${o}`:"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Zt(s)} coords = getOutputCoords();\n        int end = ${sz(s,"coords")};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${a}) {\n          int idx = ${l};\n          ${sz(s,"coords")} = idx;\n          val *= getX(${rz(s,"coords")});\n        }\n        setOutput(val);\n      }\n    `}}function rz(n,t){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative product for rank ${n} is not yet supported`)}function sz(n,t){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw Error(`Cumulative product for rank ${n} is not yet supported`)}const $we={kernelName:CC,backendName:"webgl",kernelFunc:function Pwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r,l=s.shape.length,c=Sn([i],l);let u=s;null!=c&&(u=kr({inputs:{x:s},backend:e,attrs:{perm:c}}));const d=An(1,l)[0];if(d!==l-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${s.shape.length-1} but got axis=${i}`);const h=u.shape[d];let f=hs({inputs:{x:u},backend:e});for(let p=0;p<=Math.ceil(Math.log2(h))-1;p++){const m=new nz(u.shape,!1,a),_=f;f=e.runWebGLProgram(m,[f],f.dtype,[[p]]),e.disposeIntermediateTensorInfo(_)}if(o){const p=new nz(u.shape,o,a),m=f;f=e.runWebGLProgram(p,[f],f.dtype),e.disposeIntermediateTensorInfo(m)}if(null!=c){const m=kr({inputs:{x:f},backend:e,attrs:{perm:Fa(c)}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(u),m}return f}};class iz{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=t;const s=t.length,i=e?"0.0":`getX(${oz(s,"coords")})`,o=t[t.length-1];let a="",l="";e?(a=r?"end != "+(o-1):"end != 0",l=r?"end + 1":"end - 1"):(a=r?`end + pow2 < ${o}`:"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Zt(s)} coords = getOutputCoords();\n        int end = ${az(s,"coords")};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${a}) {\n          int idx = ${l};\n          ${az(s,"coords")} = idx;\n          val += getX(${oz(s,"coords")});\n        }\n        setOutput(val);\n      }\n    `}}function oz(n,t){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}function az(n,t){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}const Vwe={kernelName:ry,backendName:"webgl",kernelFunc:function Lwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r,l=s.shape.length,c=Sn([i],l);let u=s;null!=c&&(u=kr({inputs:{x:s},backend:e,attrs:{perm:c}}));const d=An(1,l)[0];if(d!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${i}`);const h=u.shape[d];let f=hs({inputs:{x:u},backend:e});for(let p=0;p<=Math.ceil(Math.log2(h))-1;p++){const m=new iz(u.shape,!1,a),_=f;f=e.runWebGLProgram(m,[f],f.dtype,[[p]]),e.disposeIntermediateTensorInfo(_)}if(o){const p=new iz(u.shape,o,a),m=f;f=e.runWebGLProgram(p,[f],f.dtype),e.disposeIntermediateTensorInfo(m)}if(null!=c){const m=kr({inputs:{x:f},backend:e,attrs:{perm:Fa(c)}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(u),m}return f}},zwe={kernelName:MP,backendName:"webgl",kernelFunc:function Bwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o,binaryOutput:a}=r;if(1===s.shape.length){const l=e.readSync(s.dataId),c=e.readSync(i.dataId),u=D3(l,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,u)}if(2===s.shape.length){const l=e.bufferSync(s),c=e.bufferSync(i),u=rbe(l,c,o,a);return e.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class Uwe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const jwe={kernelName:SC,backendName:"webgl",kernelFunc:function Hwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:i,dataFormat:o}=r,a=s.shape[0],d=("NHWC"===o?s.shape[1]:s.shape[2])*i,h=("NHWC"===o?s.shape[2]:s.shape[3])*i,f=("NHWC"===o?s.shape[3]:s.shape[1])/(i*i),m=new Uwe("NHWC"===o?[a,d,h,f]:[a,f,d,h],i,o);return e.runWebGLProgram(m,[s],s.dtype)}};class lz{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ds(this.outputShape.length);const o=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels;let c="",u="";r&&(c=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,u="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${o}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${u}\n        setOutput(result);\n      }\n    `}}class cz{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ds(this.outputShape.length);const o=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,u=t.filterHeight,d=t.filterWidth,h=d;let f="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let _=0;_<d;_++)f+=`\n          vec4 xTexelC${2*_};\n          int xTexelC${2*_}Ready;\n          vec4 xTexelC${2*_+1};\n          int xTexelC${2*_+1}Ready;\n          vec4 xC${_};`;f+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let _=0;_<d;_++)f+=`\n          xTexelC${2*_} = vec4(0.0);\n          xTexelC${2*_}Ready = 0;\n          xTexelC${2*_+1} = vec4(0.0);\n          xTexelC${2*_+1}Ready = 0;\n          xC${_} = vec4(0.0);`;f+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let _=0;_<(h+1)/2;_++){const y=2*_;if(f+=`\n          xC = xCCorner + ${y*c};\n          `,1===l){if(y<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                  xTexelC${y} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${y}.zw = vec2(0.0);\n                  }\n                  xTexelC${y}Ready = 1;\n                }\n              `,f+=1===c&&y>0?`\n                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);\n                  } else {\n                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);\n                  }\n                  `):f+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                  xTexelC${y} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${y}.zw = vec2(0.0);\n                  }\n                  xTexelC${y}Ready = 1;\n                }\n\n                xC${y} = xTexelC${y};\n                `,y+1<d)){const v=a%2==0?xP(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(f+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${v};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${y+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${y+1}Ready = 1;\n                  }\n                  `,c>1&&(f+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                      xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${y}Ready = 1;\n                    }\n                    `),f+=`\n                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);\n                  `):f+=1===v?`\n                    xC${y+1} = xTexelC${y};\n                    `:`\n                    xCOffset = xC + ${v};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${y+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${y+1}Ready = 1;\n                    }\n\n                    xC${y+1} = xTexelC${y+1};\n                    `}}else y<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                  xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${y}.zw = vec2(0.0);\n                  }\n                  xTexelC${y}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {\n                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${y+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${y+1}Ready = 1;\n                }\n\n                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n              `,y+1<d&&(f+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);\n                `)):(f+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                  xTexelC${y} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${y}.zw = vec2(0.0);\n                  }\n                  xTexelC${y}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${y+1}.zw = vec2(0.);\n                  }\n                  xTexelC${y+1}Ready = 1;\n                }\n\n                xC${y} = vec4(\n                  xTexelC${y}.xy, xTexelC${y+1}.xy);\n              `,y+1<d&&(f+=`\n                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n                `)));y<d&&(f+=`\n            wTexel = getW(r, ${y}, d1, q);\n            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);\n          `,y+1<d&&(f+=`\n              wTexel = getW(r, ${y+1}, d1, q);\n              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}f+="\n    }\n  ",f+="\n      }\n    ";let p="",m="";r&&(p=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,m="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${f}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${m}\n        setOutput(result);\n      }\n    `}}const Gwe={kernelName:sy,backendName:"webgl",kernelFunc:function Wwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;let u=l;null==u&&(u=[1,1]),S(Er(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const d=gr(s.shape,i.shape,o,u,a,c,!0);let h;return h=ae().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new cz(d):new lz(d),e.runWebGLProgram(h,[s,i],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}};class qwe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Kwe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,l=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Ywe={kernelName:EC,backendName:"webgl",kernelFunc:function Xwe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,d=gr(s.shape,u,o,a,l,c,!0),h=new qwe(d);return e.runWebGLProgram(h,[s,i],"float32")}},Qwe={kernelName:IC,backendName:"webgl",kernelFunc:function Zwe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,d=gr(u,i.shape,o,a,l,c,!0),h=new Kwe(d);return e.runWebGLProgram(h,[s,i],"float32")}};class Jwe{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const tCe={kernelName:"Diag",backendName:"webgl",kernelFunc:function eCe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=[...r.shape,...r.shape],i=ce(r.shape),o=Oe({inputs:{x:r},backend:e,attrs:{shape:[i]}}),a=new Jwe(i),l=e.runWebGLProgram(a,[o],o.dtype),c=Oe({inputs:{x:l},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}};class nCe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=t,{top:d,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const sCe={kernelName:iy,backendName:"webgl",kernelFunc:function rCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=r,c=Lf(s.shape,i.shape,o,a,"NHWC",l);let u;const d=new nCe(c);u=e.runWebGLProgram(d,[s,i],"float32");const h=Oe({inputs:{x:u},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(u),h}},oCe={kernelName:"Einsum",backendName:"webgl",kernelFunc:function iCe(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,i=t,{allDims:o,summedDims:a,idDims:l}=zS(s,i.length);HS(o.length,l,i);const{path:c,steps:u}=jS(a,l),d=u.length;let h=null,f=o.length;const p=[];for(let m=0;m<d;++m){for(const g of u[m]){const{permutationIndices:_,expandDims:y}=US(f,l[g]);let v;WS(_)?v=i[g]:(v=kr({inputs:{x:i[g]},backend:e,attrs:{perm:_}}),p.push(v));const b=v.shape.slice();for(let w=0;w<y.length;++w)b.splice(y[w],0,1);Ut(v.shape,b)||(v=Oe({inputs:{x:v},backend:e,attrs:{shape:b}}),p.push(v)),null===h?h=v:(h=wI({inputs:{a:v,b:h},backend:e}),p.push(h))}m<d-1&&(c[m]>=0&&(h=xv({inputs:{x:h},backend:e,attrs:{axis:c[m]-(o.length-f),keepDims:!1}}),p.push(h)),f--)}for(const m of p)m!==h&&e.disposeIntermediateTensorInfo(m);return h}},aCe=$t({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),lCe={kernelName:Gh,backendName:"webgl",kernelFunc:aCe},dCe={kernelName:NC,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:r,y:s}=t,i=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new mp("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new Yu("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(i,[r,s],r.dtype)}},hCe=Tr({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:obe}),fCe={kernelName:oy,backendName:"webgl",kernelFunc:hCe},mCe=$t({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${MS};\n  float a1 = ${OS};\n  float a2 = ${FS};\n  float a3 = ${PS};\n  float a4 = ${$S};\n  float a5 = ${LS};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),gCe={kernelName:qh,backendName:"webgl",kernelFunc:mCe},uz=$t({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:abe,dtype:"float32"}),_Ce={kernelName:Kh,backendName:"webgl",kernelFunc:uz};function EI(n){const{inputs:t,attrs:e,backend:r}=n,{dim:s}=e,{input:i}=t,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(S(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),Oe({inputs:{x:i},backend:r,attrs:{shape:a}})}const vCe={kernelName:ay,backendName:"webgl",kernelFunc:EI},dz="return exp(x) - 1.0;",bCe=$t({opSnippet:dz,packedOpSnippet:dz,cpuKernelImpl:lbe}),xCe={kernelName:Xh,backendName:"webgl",kernelFunc:bCe};class hz{constructor(t,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const i=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${s}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function fz(n,t,e){const r=e.texData.get(n.dataId),s=ce(n.shape),i=n.shape[n.shape.length-1],a=Oe({inputs:{x:n},backend:e,attrs:{shape:[s/i,i]}}),l=a.shape,c=new hz("real",l,t),u=new hz("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(c,d,"float32"),f=e.runWebGLProgram(u,d,"float32"),p=Ka({inputs:{real:h,imag:f},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f);const m=Oe({inputs:{x:p},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(p),m}const CCe={kernelName:"FFT",backendName:"webgl",kernelFunc:function wCe(n){const{inputs:t,backend:e}=n,{input:r}=t;return fz(r,!1,e)}};class DCe{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function _p(n){const{backend:t,attrs:e}=n,{shape:r,value:s}=e;let{dtype:i}=e;if(i=i||Ah(s),"string"===i){const o=os(i,ce(r));return o.fill(s),t.makeTensorInfo(r,i,o)}{const o=new DCe(r,s);return t.runWebGLProgram(o,[],i,[[s]])}}const SCe={kernelName:RC,backendName:"webgl",kernelFunc:_p};class ECe{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const ICe={kernelName:MC,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,r=t,s=new ECe(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},pz="return floor(x);",TCe=$t({opSnippet:pz,packedOpSnippet:pz,cpuKernelImpl:cbe}),kCe={kernelName:Yh,backendName:"webgl",kernelFunc:TCe},NCe=Tr({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),ACe={kernelName:Zh,backendName:"webgl",kernelFunc:NCe};class RCe{constructor(t){this.variableNames=["A"];const e=Xr(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class MCe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Xr(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const OCe={kernelName:iD,backendName:"webgl",kernelFunc:function FCe(n){const{inputs:t,backend:e,attrs:r}=n;let{pixels:s}=t;const{numChannels:i}=r,o="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,c]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],u=[c,l],d=[c,l,i];(a||o)&&(null==ed&&(ed=document.createElement("canvas").getContext("2d")),ed.canvas.width=l,ed.canvas.height=c,ed.drawImage(s,0,0,l,c),s=ed.canvas);const h=e.makeTensorInfo(u,"int32");e.texData.get(h.dataId).usage=Cs.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),s);const f=ae().getBool("WEBGL_PACK")?new MCe(d):new RCe(d),p=e.runWebGLProgram(f,[h],"int32");return e.disposeData(h.dataId),p}};let ed;const $Ce={kernelName:Gy,backendName:"webgl",kernelFunc:function PCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r,m=qo(u),g=gr(s.shape,i.shape,l,d,c,h,!1,m);let _;const y=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(ae().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])_=tz({x:s,filter:i,convInfo:g,backend:e,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else{const b=null!=o,w=null!=a,C="leakyrelu"===f,E=f?vv(f,!1):null,k=new J3(g,b,E,w,C),M=[s,i];if(o&&M.push(o),a&&M.push(a),C){const O=e.makeTensorInfo([],"float32",Ia(p,"float32"));M.push(O),y.push(O)}_=e.runWebGLProgram(k,M,"float32")}else _=ez({x:s,filter:i,convInfo:g,backend:e,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});const v=Oe({inputs:{x:_},backend:e,attrs:{shape:g.outShape}});return y.push(_),y.forEach(b=>e.disposeIntermediateTensorInfo(b)),v}},VCe={kernelName:qy,backendName:"webgl",kernelFunc:function LCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,p=[];let m=u;null==m&&(m=[1,1]),S(Er(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=gr(s.shape,i.shape,l,m,c,d,!0),_=ae().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,y=h?vv(h,_):null,v=[s,i],b=null!=o,w=null!=a,C="leakyrelu"===h;if(b&&v.push(o),w&&v.push(a),C){const O=e.makeTensorInfo([],"float32",Ia(f,"float32"));v.push(O),p.push(O)}let E;E=_?new cz(g,b,y,w,C):new lz(g,b,y,w,C);const M=e.runWebGLProgram(E,v,"float32",[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]]);return p.forEach(O=>e.disposeIntermediateTensorInfo(O)),M}};class BCe{constructor(t,e,r){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=r;const s=Zt(e.length),i=Zt(r.length);this.userCode=`\n        ${s} strides = ${s}(${this.strides});\n         void main() {\n          ${i} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const UCe={kernelName:PP,backendName:"webgl",kernelFunc:function zCe(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,i=s.shape,o=i[i.length-1],a=ce(r.shape),[l,c,u,d]=RS(r,s),h=Oe({inputs:{x:s},backend:e,attrs:{shape:[c,o]}}),f=Oe({inputs:{x:r},backend:e,attrs:{shape:[ce(r.shape)/u,u]}});if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const _=e.readSync(s.dataId),y=e.bufferSync(r),v=ube(_,y,r.dtype,c,o,u,d,r.shape,a);return e.makeTensorInfo(l,r.dtype,v.values)}const p=new BCe(o,d,[c,u]),m=e.runWebGLProgram(p,[f,h],f.dtype),g=Oe({inputs:{x:m},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}};class HCe{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=Zt(this.rank),s=function jCe(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)r.push(2===s?"index":`${e[s]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function mz(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:i}=t,{axis:o,batchDims:a}=r,l=It(o,s.shape)[0];if(ae().get("DEBUG")){const y=e.readSync(i.dataId),v=s.shape[l];for(let b=0;b<y.length;++b){const w=y[b];S(w<=v-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${v-1}]`)}}const c=KS(s,i,l,a),u=ce(i.shape),d=[],h=Oe({inputs:{x:s},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=Oe({inputs:{x:i},backend:e,attrs:{shape:[c.batchSize,u/c.batchSize]}});d.push(h),d.push(f);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([s,i])||"string"===s.dtype){const y=e.bufferSync(f),v=e.bufferSync(h),b=dbe(v,y,p);return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(c.outputShape,b.dtype,b.values)}const m=new HCe(h.shape,p),g=e.runWebGLProgram(m,[h,f],h.dtype);d.push(g);const _=Oe({inputs:{x:g},backend:e,attrs:{shape:c.outputShape}});return d.forEach(y=>e.disposeIntermediateTensorInfo(y)),_}const WCe={kernelName:cy,backendName:"webgl",kernelFunc:mz},GCe=Tr({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:hbe,dtype:"bool"}),qCe={kernelName:uy,backendName:"webgl",kernelFunc:GCe},KCe=Tr({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:fbe}),XCe={kernelName:Qh,backendName:"webgl",kernelFunc:KCe},ZCe={kernelName:OC,backendName:"webgl",kernelFunc:function YCe(n){const{inputs:t,backend:e}=n,{input:r}=t;return fz(r,!0,e)}},QCe=$t({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),JCe={kernelName:ef,backendName:"webgl",kernelFunc:QCe},eDe=$t({opSnippet:"return float(isinf(x));",dtype:"bool"}),tDe={kernelName:nf,backendName:"webgl",kernelFunc:eDe},nDe=$t({opSnippet:"return float(isnan(x));",dtype:"bool"}),rDe={kernelName:rf,backendName:"webgl",kernelFunc:nDe},sDe=Tr({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:pbe,dtype:"bool"}),iDe={kernelName:hy,backendName:"webgl",kernelFunc:sDe},oDe=Tr({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:mbe,dtype:"bool"}),aDe={kernelName:fy,backendName:"webgl",kernelFunc:oDe},cDe={kernelName:$P,backendName:"webgl",kernelFunc:function lDe(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:i}=e,o=gbe(r,s,i);return t.makeTensorInfo([o.length],"float32",o)}},dDe=$t({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:ybe}),hDe={kernelName:sf,backendName:"webgl",kernelFunc:dDe},pDe=$t({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),mDe={kernelName:af,backendName:"webgl",kernelFunc:pDe},gDe=Tr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),yDe={kernelName:py,backendName:"webgl",kernelFunc:gDe},_De=$t({opSnippet:"return float(!(x >= 1.0));"}),vDe={kernelName:my,backendName:"webgl",kernelFunc:_De},bDe=Tr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),xDe={kernelName:gy,backendName:"webgl",kernelFunc:bDe};class wDe{constructor(t,e,r,s,i){this.variableNames=["x"],this.outputShape=[];const o=e,a=t[3]-1;let l;this.outputShape=t;const c=`float(${r}) + float(${s}) * sum`;l=.5===i?`inversesqrt(${c})`:1===i?`1.0/(${c})`:`exp(log(${c}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class CDe{constructor(t,e,r,s,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,a=t[3]-1;let l;this.outputShape=t;const c=`float(${r}) + float(${s}) * sum`;l=.5===i?`inversesqrt(${c})`:1===i?`1.0/(${c})`:`exp(log(${c}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const DDe={kernelName:yy,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=r,c=ae().getBool("WEBGL_PACK_NORMALIZATION")?new CDe(s.shape,i,o,a,l):new wDe(s.shape,i,o,a,l);return e.runWebGLProgram(c,[s],s.dtype)}};class SDe{constructor(t,e,r,s,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=i,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${i})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${i});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const EDe={kernelName:PC,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:u}=r,d=new SDe(s.shape,a,l,c,u);return e.runWebGLProgram(d,[s,i,o],s.dtype)}};function gz(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:i,keepDims:o}=r,a=s.shape.length,l=It(i,s.shape);let c=l;const u=Sn(c,a),d=null!=u,h=e.shouldExecuteOnCPU([s]);let f=s;if(d){if(h){const v=e.texData.get(f.dataId).values,b=new Array(a);for(let E=0;E<b.length;E++)b[E]=s.shape[u[E]];const w=xI(v,s.shape,s.dtype,u,b);f=e.makeTensorInfo(b,s.dtype),e.texData.get(f.dataId).values=w}else f=bv(s,u,e);c=An(c.length,a)}Ir("max",c,a);const[p,m]=yr(f.shape,c);let _,g=p;if(o&&(g=Bn(p,l)),h){const v=e.texData.get(f.dataId).values,b=_be(v,ce(m),g,s.dtype);_=e.makeTensorInfo(g,s.dtype),e.texData.get(_.dataId).values=b}else _=function IDe(n,t,e,r){const s=ce(t),a=Oe({inputs:{x:n},attrs:{shape:[ce(n.shape)/s,s]},backend:r}),l=ec(a,n.dtype,"max",r),c=Oe({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}(f,m,g,e);return d&&e.disposeIntermediateTensorInfo(f),_}const TDe={kernelName:_y,backendName:"webgl",kernelFunc:gz},ADe=Tr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:vbe}),RDe={kernelName:lf,backendName:"webgl",kernelFunc:ADe},ODe={kernelName:vy,backendName:"webgl",kernelFunc:function MDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;fp(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Er(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=ui(s.shape,i,o,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&Ut(u.inShape,u.outShape))return hs({inputs:{x:s},backend:e});const d=new gp(u,"max",!1);return e.runWebGLProgram(d,[s],s.dtype)}},PDe={kernelName:by,backendName:"webgl",kernelFunc:function FDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=Go(s.shape,i,o,[1,1,1],a,c,l),h=new CI(d,"max",!1);return e.runWebGLProgram(h,[s],s.dtype)}};class $De{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const i=t.effectiveFilterHeight,o=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${i-1-t.padInfo.top}, ${o-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${i*o-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class LDe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,u=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-t.padInfo.front}, ${c-1-t.padInfo.top}, ${u-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*c*u-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const BDe={kernelName:LC,backendName:"webgl",kernelFunc:function VDe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=Go(o.shape,a,l,[1,1,1],c,u),f=new CI(h,"max",!0),p=e.runWebGLProgram(f,[o],o.dtype),m=new LDe(h),g=e.runWebGLProgram(m,[s,p],o.dtype);return e.disposeIntermediateTensorInfo(p),g}},UDe={kernelName:$C,backendName:"webgl",kernelFunc:function zDe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i,output:o}=t,a=i;fp([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,h=ui(a.shape,l,c,1,u,d),p=new gp(h,"max",!0),m=e.runWebGLProgram(p,[a],a.dtype),g=new $De(h),_=e.runWebGLProgram(g,[s,m],a.dtype);return e.disposeIntermediateTensorInfo(m),_}},jDe={kernelName:LP,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;S(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];S(Er(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=ui(r.shape,s,i,c,o),[d,h]=function HDe(n,t,e,r){let s=new gp(e,"max",!1);const i=r.runWebGLProgram(s,[n],"float32");return s=new gp(e,"max",!0,!0,t),[i,r.runWebGLProgram(s,[n],"float32")]}(r,a,u,l);return[d,h]}},GDe={kernelName:xy,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{keepDims:s,axis:i}=t,o=e,a=r.shape.length,l=It(i,r.shape);let c=l;const u=Sn(c,a),d=null!=u,h=o.shouldExecuteOnCPU([r]),f=[];let p=r;if(d){if(h){const b=o.texData.get(p.dataId).values,w=new Array(a);for(let k=0;k<w.length;k++)w[k]=r.shape[u[k]];const C=xI(b,r.shape,r.dtype,u,w);p=o.makeTensorInfo(w,r.dtype),o.texData.get(p.dataId).values=C}else p=bv(r,u,o);f.push(p),c=An(c.length,a)}Ir("sum",c,a);const[m,g]=yr(p.shape,c);let _=m;s&&(_=Bn(m,l));const y=function WDe(n,t,e,r){const s=ce(t),a=Oe({inputs:{x:n},attrs:{shape:[ce(n.shape)/s,s]},backend:r}),l=ec(a,"float32","mean",r),c=Oe({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}(p,g,_,o);for(const v of f)o.disposeIntermediateTensorInfo(v);return y}},KDe={kernelName:wy,backendName:"webgl",kernelFunc:function qDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=It(i,s.shape);let c=l;const u=Sn(c,a);let d=s;null!=u&&(d=kr({inputs:{x:s},backend:e,attrs:{perm:u}}),c=An(c.length,s.shape.length)),Ir("min",c,a);const[h,f]=yr(d.shape,c),m=Oe({inputs:{x:d},backend:e,attrs:{shape:[-1,ce(f)]}}),g=ec(m,m.dtype,"min",e);let _;return _=Oe(o?{inputs:{x:g},backend:e,attrs:{shape:Bn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=u&&e.disposeIntermediateTensorInfo(d),_}},ZDe=Tr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:bbe}),QDe={kernelName:cf,backendName:"webgl",kernelFunc:ZDe};class JDe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((u,d)=>u[0]+t[d]+u[1]);const s=t.length,i=Zt(s),o=e.map(u=>u[0]).join(","),a=e.map((u,d)=>u[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c="reflect"===r?0:1;this.userCode=1!==s?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${i} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class eSe{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((p,m)=>p[0]+t[m]+p[1]);const s=t.length,i=Zt(s),o=e.map(p=>p[0]).join(","),a=e.map((p,m)=>p[0]+t[m]).join(","),l=Yr("rc",s),c=Yr("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${c.slice(-2).join()})`,h="reflect"===r?0:1;let f="";if(1===s){const p=`\n        ${i} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;f=`\n        ${i} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${c.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${u}) {\n          ${p}\n          result[1] = getChannel(getX(${c.join()}), ${d});\n        }\n      `}else{const p=`\n        ${i} source = rc;\n        ${i} lt = ${i}(lessThan(source, start));\n        ${i} gte = ${i}(greaterThanEqual(source, end));\n        ${i} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;f=`\n        ${i} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${c.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${u}) {\n          ${p}\n          result[1] = getChannel(getX(${c.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[s-2]} += 1;\n        if(${l[s-2]} < ${this.outputShape[s-2]}) {\n          ${p}\n          result[2] = getChannel(getX(${c.join()}), ${d});\n          ${l[s-1]} += 1;\n          if(${u}) {\n            ${p}\n            result[3] = getChannel(getX(${c.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const tSe={kernelName:Cy,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r}=n,{paddings:s,mode:i}=e,o=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new eSe(r.shape,s,i):new JDe(r.shape,s,i);return t.runWebGLProgram(o,[r],r.dtype)}},sSe=Tr({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),iSe={kernelName:uf,backendName:"webgl",kernelFunc:sSe};class oSe{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const yz=Tr({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),aSe={kernelName:Wh,backendName:"webgl",kernelFunc:yz},_z="return a - b;",vz=Tr({opSnippet:_z,packedOpSnippet:_z,supportsComplex:!0,cpuKernelImpl:Pbe}),lSe={kernelName:Ef,backendName:"webgl",kernelFunc:vz};function bz(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:i}=r,o=It([i],s.shape),a=gz({inputs:{x:s},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),l=Bn(a.shape,o),c=Oe({inputs:{x:a},backend:e,attrs:{shape:l}}),u=vz({inputs:{a:s,b:c},backend:e}),d=uz({inputs:{x:u},backend:e}),h=xv({inputs:{x:d},backend:e,attrs:{axis:o,keepDims:!1}}),f=Oe({inputs:{x:h},backend:e,attrs:{shape:l}}),p=yz({inputs:{a:d,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}const cSe={kernelName:By,backendName:"webgl",kernelFunc:bz},dSe={kernelName:VP,backendName:"webgl",kernelFunc:function uSe(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:i,seed:o,normalized:a}=r,l=a?s:bz({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),d=new oSe(l.shape[0],l.shape[1],i),f=e.runWebGLProgram(d,[l],"int32",[[o]]);return a||e.disposeIntermediateTensorInfo(l),f}},mSe={kernelName:Dy,backendName:"webgl",kernelFunc:function pSe(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){const i=e.texData.get(r.dataId),[o,a]=wbe(i.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,o)}let s;return s=ae().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Jl(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new ea(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),e.runWebGLProgram(s,[r],r.dtype)}},gSe=hS,_Se={kernelName:VC,backendName:"webgl",kernelFunc:function ySe(n){Vs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=e.readSync(s.dataId),u=e.readSync(i.dataId),{selectedIndices:d}=gSe(c,u,o,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},vSe=fS,xSe={kernelName:BC,backendName:"webgl",kernelFunc:function bSe(n){Vs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,u=e.readSync(s.dataId),d=e.readSync(i.dataId),{selectedIndices:h,validOutputs:f}=vSe(u,d,o,a,l,c);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},wSe=pS,DSe={kernelName:zC,backendName:"webgl",kernelFunc:function CSe(n){Vs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=e.readSync(s.dataId),d=e.readSync(i.dataId),h=o,f=a,p=l,m=c,{selectedIndices:g,selectedScores:_}=wSe(u,d,h,f,p,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([_.length],"float32",new Float32Array(_))]}};class SSe{constructor(t,e,r,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const ESe={kernelName:Iy,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{depth:i,onValue:o,offValue:a}=r,l=ce(s.shape),c=new SSe(l,i,o,a),u=Oe({inputs:{x:s},backend:e,attrs:{shape:[l]}}),d=e.runWebGLProgram(c,[u],s.dtype);e.disposeIntermediateTensorInfo(u);const f=Oe({inputs:{x:d},backend:e,attrs:{shape:[...s.shape,i]}});return e.disposeIntermediateTensorInfo(d),f}};function Ev(n){const{inputs:t,backend:e}=n,{x:r}=t;if("complex64"===r.dtype){const s=yp({inputs:{input:r},backend:e}),i=Ev({inputs:{x:s},backend:e}),o=Sv({inputs:{input:r},backend:e}),a=Ev({inputs:{x:o},backend:e}),l=Ka({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return _p({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const ISe={kernelName:jy,backendName:"webgl",kernelFunc:Ev},TSe={kernelName:Ey,backendName:"webgl",kernelFunc:function xz(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=yp({inputs:{input:r},backend:e}),i=xz({inputs:{x:s},backend:e}),o=Sv({inputs:{input:r},backend:e}),a=Ev({inputs:{x:o},backend:e}),l=Ka({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return _p({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},NSe={kernelName:Ty,backendName:"webgl",kernelFunc:function kSe(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return EI({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const i=t[0].shape,o=t[0].dtype;t.forEach(u=>{ai(i,u.shape,"All tensors passed to stack must have matching shapes"),S(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=Q3({inputs:t.map(u=>{const d=EI({inputs:{input:u},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}};class ASe{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,u)=>c[0]+t[u]+c[1]);const s=t.length,i=Zt(s),o=e.map(c=>c[0]).join(","),a=e.map((c,u)=>c[0]+t[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${i} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class RSe{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((m,g)=>m[0]+t[g]+m[1]);const s=t.length,i=Zt(s),o=e.map(m=>m[0]).join(","),a=e.map((m,g)=>m[0]+t[g]).join(","),l=Yr("rc",s),c=Yr("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${c.slice(-2).join()})`,h=[`${i} rc = outputLoc;`,`${l[s-1]} += 1;\n       if(${u}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${l[s-2]} += 1;\n       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${l[s-1]} += 1;\n         if(${u}) {`],f=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,g=1===s?2:4;m<g;m++)p+=`\n        ${h[m]}\n        if (${f}) {\n          result[${m}] = float(value);\n        } else {\n          ${i} source = rc - start;\n          result[${m}] = getChannel(getX(${c.join()}), ${d});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const wz=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,constantValue:o}=r;if(0===ce(s.shape))return _p({backend:e,attrs:{shape:i.map((u,d)=>u[0]+s.shape[d]+u[1]),value:o,dtype:s.dtype}});const a=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new RSe(s.shape,i,o):new ASe(s.shape,i,o);return e.runWebGLProgram(a,[s],s.dtype,[[o]])},MSe={kernelName:ky,backendName:"webgl",kernelFunc:wz},PSe=Tr({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),$Se={kernelName:hf,backendName:"webgl",kernelFunc:PSe},VSe={kernelName:UC,backendName:"webgl",kernelFunc:function LSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=[],c=It(i,s.shape);let u=c;const d=Sn(u,a);let f,h=s;if(null!=d&&(h=kr({inputs:{x:s},backend:e,attrs:{perm:d}}),u=An(u.length,a),l.push(h)),Ir("prod",u,a),e.shouldExecuteOnCPU([h])){const p=e.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:_}=Dbe(h.shape,h.dtype,p,u);f=e.makeTensorInfo(g,_,m)}else{const[p,m]=yr(h.shape,u),g=ce(m),_=Oe({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}}),v=ec(_,fD(s.dtype),"prod",e);f=Oe({inputs:{x:v},backend:e,attrs:{shape:p}}),l.push(_),l.push(v)}if(o){l.push(f);const p=Bn(f.shape,c);f=Oe({inputs:{x:f},backend:e,attrs:{shape:p}})}return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},Cz=n=>{const{backend:t,attrs:e}=n,{start:r,stop:s,step:i,dtype:o}=e,a=Sbe(r,s,i,o);return t.makeTensorInfo([a.length],o,a)},BSe={kernelName:HC,backendName:"webgl",kernelFunc:Cz},zSe=$t({opSnippet:"return 1.0 / x;"}),USe={kernelName:ff,backendName:"webgl",kernelFunc:zSe},jSe=$t({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),WSe={kernelName:pf,backendName:"webgl",kernelFunc:jSe},qSe=$t({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),KSe={kernelName:mf,backendName:"webgl",kernelFunc:qSe};class XSe{constructor(t,e,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=i?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class YSe{constructor(t,e,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=i?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]},\n          ${u[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const QSe={kernelName:My,backendName:"webgl",kernelFunc:function ZSe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=ae().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new YSe(s.shape,l,c,i,o):new XSe(s.shape,l,c,i,o);return e.runWebGLProgram(u,[s],"float32")}};class JSe{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,i]=e,[,o,a]=t,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],h=1/u,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const tEe={kernelName:GC,backendName:"webgl",kernelFunc:function eEe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r,a=new JSe(i.shape,s.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}};class nEe{constructor(t,e,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=i?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class rEe{constructor(t,e,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=i?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]},\n          ${u[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const iEe={kernelName:Ry,backendName:"webgl",kernelFunc:function sEe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=ae().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new rEe(s.shape,l,c,i,o):new nEe(s.shape,l,c,i,o);return e.runWebGLProgram(u,[s],s.dtype)}};class oEe{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,i]=e,[,o,a]=t,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],h=1/u,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const lEe={kernelName:WC,backendName:"webgl",kernelFunc:function aEe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r,a=new oEe(i.shape,s.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}};class cEe{constructor(t,e){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const i=t.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==t[a]?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),o=Zt(r);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}class uEe{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=Yr("rc",r),i=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Zt(r);function h(p){const m=t.map((y,v)=>function f(p,m){return-1!==e.indexOf(p)&&1!==t[p]?`${t[p]} - ${m[p]} - 1`:`${m[p]}`}(v,p));return`getChannel(getX(${m.join(",")}), vec2(${m.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(p){return h(p)}(s.slice())};\n          if(${i}){\n            result.g = ${function c(p){return p[r-1]="("+p[r-1]+" + 1)",h(p)}(s.slice())};\n          }\n          if(${o}) {\n            result.b = ${function u(p){return p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            if(${i}) {\n              result.a = ${function d(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const hEe={kernelName:Oy,backendName:"webgl",kernelFunc:function dEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:i}=r,o=s.shape.length,a=It(i,s.shape);if(0===o)return hs({inputs:{x:s},backend:e});const l=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new uEe(s.shape,a):new cEe(s.shape,a);return e.runWebGLProgram(l,[s],s.dtype)}};class fEe{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let i="";i="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${i}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const pEe={kernelName:oD,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=t,a=e,l=new fEe(r.shape,i),[c,u]=kS(o,r.shape[1],r.shape[2]),d=[[c,u,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,d)}},mEe=$t({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),gEe={kernelName:gf,backendName:"webgl",kernelFunc:mEe},yEe=$t({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Ebe}),_Ee={kernelName:yf,backendName:"webgl",kernelFunc:yEe};class Dz{constructor(t,e,r,s,i,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=Zt(i.length),c=Zt(o.length);let u="";1===r?u="i":2===r&&(u="i, j");let h="";1===s?h="i":2===s&&(h="i, coords[1]"),this.userCode=`\n        ${l} strides = ${l}(${i});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${u}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${h});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const bEe={kernelName:BP,backendName:"webgl",kernelFunc:function vEe(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:i}=t,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=qf(0,s,o),h=[d/c,c];if(0===d)return e.makeTensorInfo(o,s.dtype);const f=Oe({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),p=Oe({inputs:{x:i},backend:e,attrs:{shape:[l,c]}}),m=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new Dz(l,a,f.shape.length,p.shape.length,u,h),_=e.runWebGLProgram(g,[p,f,m],p.dtype),y=Oe({inputs:{x:_},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(m),y}};class xEe{constructor(t,e,r){let s,i;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)i="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<e.length;u++)c.push(`${a[u]}`),u<t&&l.push(`${a[u]}`);s=l.join(),i=c.join()}const o=Zt(r);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}const CEe={kernelName:Fy,backendName:"webgl",kernelFunc:function wEe(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:i}=t,o=new xEe(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(o,[r,s,i],_s(s.dtype,i.dtype))}},SEe=$t({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${T_};\n  float scale = ${k_};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),EEe={kernelName:_f,backendName:"webgl",kernelFunc:SEe},TEe=$t({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Ibe}),kEe={kernelName:wf,backendName:"webgl",kernelFunc:TEe},NEe=$t({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),AEe={kernelName:xf,backendName:"webgl",kernelFunc:NEe},MEe=$t({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),OEe={kernelName:vf,backendName:"webgl",kernelFunc:MEe},FEe=$t({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),PEe={kernelName:bf,backendName:"webgl",kernelFunc:FEe},$Ee=$t({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),LEe={kernelName:Cf,backendName:"webgl",kernelFunc:$Ee},VEe={kernelName:Ly,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,paddings:o}=r;S(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((_,y)=>_*y),l=[[0,0]];l.push(...o);for(let _=1+i.length;_<s.shape.length;++_)l.push([0,0]);const c=[],u=wz({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),d=jf(u.shape,i,a,!1),h=Wf(d.length,i.length,!1),f=Gf(u.shape,i,a,!1),p=Oe({inputs:{x:u},backend:e,attrs:{shape:d}}),m=kr({inputs:{x:p},backend:e,attrs:{perm:h}}),g=Oe({inputs:{x:m},backend:e,attrs:{shape:f}});return c.push(u),c.push(p),c.push(m),c.forEach(_=>e.disposeIntermediateTensorInfo(_)),g}},zEe={kernelName:qC,backendName:"webgl",kernelFunc:function BEe(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.readSync(r.dataId),l=e.readSync(s.dataId),c=e.readSync(i.dataId),u=e.readSync(o.dataId)[0],[d,h,f,p,m]=kbe(a,r.shape,r.dtype,l,s.dtype,c,u);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,f),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),e.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},HEe={kernelName:KC,backendName:"webgl",kernelFunc:function UEe(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.readSync(s.dataId)),a=e.readSync(r.dataId),l=Array.from(e.readSync(i.dataId)),[c,u,d]=Nbe(a,r.shape,r.dtype,o,l);return[e.makeTensorInfo(u,r.dtype,c),e.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}},WEe={kernelName:XC,backendName:"webgl",kernelFunc:function jEe(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);const o=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(i.dataId),[c,u]=E3(o,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(u,r.dtype,c)}},qEe={kernelName:YC,backendName:"webgl",kernelFunc:function GEe(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);const o=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(i.dataId),[c,u]=E3(o,r.shape,r.dtype,a,l);return e.makeTensorInfo(u,r.dtype,c)}},XEe={kernelName:zP,backendName:"webgl",kernelFunc:function KEe(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:c,strides:u,outputSize:d}=qf(0,s,a),f=new Dz(c,l,s.shape.length,i.shape.length,u,[d,1],!1),p=e.runWebGLProgram(f,[i,s,o],i.dtype),m=Oe({inputs:{x:p},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(p),m}},ZEe={kernelName:Vy,backendName:"webgl",kernelFunc:function YEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:i,axis:o}=r,a=It(o,s.shape)[0],l=GS(s,i,a),u=new Array(s.shape.length).fill(0),d=s.shape.slice();return l.map(h=>{const f=[...d];f[a]=h;const p=Qu({inputs:{x:s},backend:e,attrs:{begin:u,size:f}});return u[a]+=h,p})}},Sz="return sqrt(x);",QEe=$t({opSnippet:Sz,packedOpSnippet:Sz,cpuKernelImpl:Abe}),JEe={kernelName:Df,backendName:"webgl",kernelFunc:QEe},tIe={kernelName:ZC,backendName:"webgl",kernelFunc:$t({opSnippet:"return x * x;"})},Ez="return (a - b) * (a - b);",nIe=Tr({opSnippet:Ez,packedOpSnippet:Ez}),rIe={kernelName:Sf,backendName:"webgl",kernelFunc:nIe},iIe={kernelName:Nf,backendName:"webgl",kernelFunc:function sIe({inputs:n,attrs:t,backend:e}){const{x:r}=n,i=new ea(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(i,[r],r.dtype)}};class oIe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,i=Zt(r.length),o=Zt(r.length);let a="";if(1===s)a="coords * strides + begin";else{let l=0;a=r.map((c,u)=>(l++,1===r.length?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`\n      ${i} begin = ${i}(${t});\n      ${i} strides = ${i}(${e});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const lIe={kernelName:QC,backendName:"webgl",kernelFunc:function aIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:f,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:_,begin:y,end:v,strides:b}=zD(s.shape,i,o,a,l,c,u,d,h);let w;if(m)w=Oe({inputs:{x:s},backend:e,attrs:{shape:p}});else if(g||_){S(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const E=LD(y,v,b),k=Qu({inputs:{x:s},backend:e,attrs:{begin:y,size:E}});w=Oe({inputs:{x:k},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(k)}else if(e.shouldExecuteOnCPU([s])){const k=e.readSync(s.dataId),M=Nt(s.shape,s.dtype,k),O=Rbe(f,M,b,y);w=e.makeTensorInfo(p,s.dtype,O.values)}else{const k=new oIe(y,b,f);w=e.runWebGLProgram(k,[s],s.dtype)}const C=Oe({inputs:{x:w},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(w),C}},uIe={kernelName:JC,backendName:"webgl",kernelFunc:function cIe(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=t,h=e.readSync(u.dataId),f=e.readSync(d.dataId),[p,m]=Mbe(h,f,s,i,o,a,l,c);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(d.shape,"int32",m)]}},hIe={kernelName:eD,backendName:"webgl",kernelFunc:function dIe(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.readSync(i.dataId),l=e.readSync(o.dataId)[0],[c,u,d]=Obe(a,l,s),h=u.length;return[e.makeTensorInfo([h,2],"int32",c),e.makeTensorInfo([h],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(d))]}},pIe={kernelName:tD,backendName:"webgl",kernelFunc:function fIe(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(i.dataId),a=Fbe(o,s);return e.makeTensorInfo(i.shape,"int32",a)}},mIe=$t({opSnippet:"return tan(x);"}),gIe={kernelName:If,backendName:"webgl",kernelFunc:mIe},yIe=$t({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),_Ie={kernelName:Tf,backendName:"webgl",kernelFunc:yIe};class vIe{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let o=0;o<r.length;o++)r[o]=t[o]*e[o];this.outputShape=r,this.rank=r.length;const s=Zt(this.rank),i=function bIe(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${e[s]}, ${n[s]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}function Iz(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:i}=r;if("string"===s.dtype||s.shape.length>5){const l=e.readSync(s.dataId),c="string"===s.dtype?l.map(h=>pu(h)):l,u=Nt(s.shape,s.dtype,c),d=$be(u,i);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new vIe(s.shape,i);return e.runWebGLProgram(o,[s],s.dtype)}const xIe={kernelName:kf,backendName:"webgl",kernelFunc:Iz};class wIe{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class CIe{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function tc(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function Tz(n){let t=1;for(;t<n;)t*=2;return t}const SIe={kernelName:nD,backendName:"webgl",kernelFunc:function DIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:i,sorted:o}=r,a=ae().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ae().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,u=c[c.length-1];if(e.shouldExecuteOnCPU([s])||u<a||i>l){const O=e.readSync(s.dataId),[K,X]=Lbe(O,c,s.dtype,i,o);return[e.makeTensorInfo(K.shape,K.dtype,K.values),e.makeTensorInfo(X.shape,X.dtype,X.values)]}if(0===i)return c[c.length-1]=0,[e.makeTensorInfo(c,s.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(1===u)return[s,_p({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const d=e.texData.get(s.dataId),h=null!==d&&d.isPacked,f=h?e.unpackTensor(s):s,m=ce(c)/u,g=Oe({inputs:{x:f},attrs:{shape:[m,u]},backend:e});h&&tc(e,f);const _=Tz(i),y=Tz(u);let v=null;const b=()=>null===v?[g,g]:[g,v],w=(O,K,X)=>{const Q=b(),re=new wIe(X),G=v;v=e.runWebGLProgram(re,Q,"int32",[[u],[null===v?1:0],[Number.NEGATIVE_INFINITY],[O],[K]]),tc(e,G)};for(let O=1;O<_;O*=2){const K=2*O;for(let X=O;X>=1;X/=2)w(K,X,[m,y])}for(let O=y;O>_;O/=2){const K=b(),X=new CIe([m,O/2]),ne=v;v=e.runWebGLProgram(X,K,"int32",[[u],[null===v?1:0],[_]]),tc(e,ne);const V=_/2,G=2*V;for(let W=V;W>=1;W/=2)w(G,W,v.shape)}let C=v;v=Qu({inputs:{x:v},backend:e,attrs:{begin:0,size:[m,i]}}),tc(e,C);let E=mz({inputs:{x:g,indices:v},backend:e,attrs:{axis:1,batchDims:1}});tc(e,g);const k=c.slice(0,-1);k.push(i),C=v,v=Oe({inputs:{x:v},attrs:{shape:k},backend:e}),tc(e,C);const M=E;return E=Oe({inputs:{x:E},attrs:{shape:k},backend:e}),tc(e,M),[E,v]}};class EIe{constructor(t,e,r,s,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a="nearest"===r?1:2;let l;switch(s){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${i});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${i});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const TIe={kernelName:rD,backendName:"webgl",kernelFunc:function IIe(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,d,h,f]=s.shape,[p,m]=null!=c?c:[d,h],_=new EIe(d,h,o,a,l,[u,p,m,f]);return e.runWebGLProgram(_,[s,i],"float32")}},NIe={kernelName:sD,backendName:"webgl",kernelFunc:function kIe(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:i}=t;fp(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(i.dataId),{outputValues:a,outputShape:l,indices:c}=Vbe(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},RIe={kernelName:Uy,backendName:"webgl",kernelFunc:function AIe(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,l=s.shape[i],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==i&&(c[u++]=o.shape[m]);const d=[],h=new Array(a).fill(0),f=o.shape.slice();f[i]=1;const p=new Array(l);for(let m=0;m<p.length;m++){h[i]=m;const g=Qu({inputs:{x:o},backend:e,attrs:{begin:h,size:f}}),_=Oe({inputs:{x:g},backend:e,attrs:{shape:c}});p[m]=_,d.push(g)}return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}};class MIe{constructor(t,e){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,i=t.inSize,o=t.numSegments,a=o*Math.ceil(i/r);this.outputShape=[s,a];const u=4*Math.floor(r/4),d=r%4,h="\n        sumValue += dot(values, segFilter);\n    ";let f="";i%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let p="";i%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${p}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const PIe=[F0e,$0e,B0e,H0e,W0e,K0e,Y0e,Q0e,nxe,sxe,axe,uxe,fxe,yxe,bxe,wxe,Dxe,Txe,Nxe,Rxe,Fxe,zxe,Hxe,Wxe,Yxe,Qxe,nwe,g0e,iwe,uwe,pwe,bwe,wwe,Dwe,Ewe,Twe,Awe,Mwe,Fwe,$we,Vwe,zwe,jwe,Gwe,Ywe,Qwe,tCe,sCe,oCe,lCe,dCe,fCe,gCe,_Ce,vCe,xCe,CCe,SCe,ICe,kCe,ACe,OCe,$Ce,VCe,UCe,WCe,qCe,XCe,m0e,ZCe,lwe,JCe,tDe,rDe,_0e,iDe,aDe,cDe,hDe,mDe,yDe,vDe,xDe,DDe,EDe,TDe,RDe,ODe,PDe,BDe,UDe,jDe,GDe,KDe,QDe,tSe,iSe,dSe,C0e,mSe,_Se,xSe,DSe,Gxe,ESe,TSe,NSe,MSe,$Se,b0e,VSe,BSe,qxe,aSe,USe,WSe,KSe,S0e,QSe,tEe,iEe,lEe,hEe,pEe,gEe,_Ee,bEe,CEe,EEe,kEe,AEe,OEe,PEe,Bxe,cSe,LEe,VEe,zEe,HEe,WEe,qEe,XEe,ZEe,JEe,tIe,rIe,iIe,lIe,uIe,hIe,pIe,lSe,R0e,gIe,_Ie,xIe,SIe,TIe,M0e,NIe,RIe,{kernelName:Hy,backendName:"webgl",kernelFunc:function OIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:i}=t,{numSegments:o}=r,a=s.shape.length,l=[];let c=0;const u=Sn([c],a);let d=s;null!=u&&(d=kr({inputs:{x:s},backend:e,attrs:{perm:u}}),l.push(d),c=An(1,a)[0]);const h=P$(d.shape,c,o),f=ce([d.shape[c]]),p=Oe({inputs:{x:d},backend:e,attrs:{shape:[-1,f]}});l.push(p);const m=fD(s.dtype),g=(b,w,C,E,k)=>{const M=b.shape[0],O=b.shape[1],K=F$(O,k),Q=new MIe({windowSize:K,inSize:O,batchSize:M,numSegments:k},w),re=e.compileAndRun(Q,[b,C],E);if(l.push(re),re.shape[1]===k)return re;const ne=Cz({backend:e,attrs:{start:0,stop:k,step:1,dtype:"float32"}}),V=Iz({inputs:{x:ne},backend:e,attrs:{reps:[O/K]}});return l.push(ne),l.push(V),g(re,w,V,E,k)},y=Oe({inputs:{x:g(p,"unsortedSegmentSum",i,m,o)},backend:e,attrs:{shape:h}});let v=y;if(null!=u){l.push(y);const b=Fa(u);v=kr({inputs:{x:v},backend:e,attrs:{perm:b}})}return l.forEach(b=>e.disposeIntermediateTensorInfo(b)),v}},ISe];for(const n of PIe)cD(n);const LIe=["mat-button",""],VIe=["*"],zIe=["mat-button","mat-flat-button","mat-icon-button","mat-raised-button","mat-stroked-button","mat-mini-fab","mat-fab"],UIe=yw(UY(HY(class{constructor(n){this._elementRef=n}})));let HIe=(()=>{class n extends UIe{constructor(e,r,s){super(e),this._focusMonitor=r,this._animationMode=s,this.isRoundButton=this._hasHostAttributes("mat-fab","mat-mini-fab"),this.isIconButton=this._hasHostAttributes("mat-icon-button");for(const i of zIe)this._hasHostAttributes(i)&&this._getHostElement().classList.add(i);e.nativeElement.classList.add("mat-button-base"),this.isRoundButton&&(this.color="accent")}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(e,r){e?this._focusMonitor.focusVia(this._getHostElement(),e,r):this._getHostElement().focus(r)}_getHostElement(){return this._elementRef.nativeElement}_isRippleDisabled(){return this.disableRipple||this.disabled}_hasHostAttributes(...e){return e.some(r=>this._getHostElement().hasAttribute(r))}}return n.\u0275fac=function(e){return new(e||n)(oe(Cn),oe(jx),oe(tu,8))},n.\u0275cmp=Wn({type:n,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-icon-button",""],["button","mat-fab",""],["button","mat-mini-fab",""],["button","mat-stroked-button",""],["button","mat-flat-button",""]],viewQuery:function(e,r){if(1&e&&dl(wO,5),2&e){let s;rs(s=ss())&&(r.ripple=s.first)}},hostAttrs:[1,"mat-focus-indicator"],hostVars:5,hostBindings:function(e,r){2&e&&(no("disabled",r.disabled||null),ms("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-button-disabled",r.disabled))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[ki],attrs:LIe,ngContentSelectors:VIe,decls:4,vars:5,consts:[[1,"mat-button-wrapper"],["matRipple","",1,"mat-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-button-focus-overlay"]],template:function(e,r){1&e&&(fa(),Re(0,"span",0),Ni(1),Be(),hn(2,"span",1)(3,"span",2)),2&e&&(Yn(2),ms("mat-button-ripple-round",r.isRoundButton||r.isIconButton),Cr("matRippleDisabled",r._isRippleDisabled())("matRippleCentered",r.isIconButton)("matRippleTrigger",r._getHostElement()))},directives:[wO],styles:[".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n"],encapsulation:2,changeDetection:0}),n})(),jIe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({imports:[[QY,fr],fr]}),n})();const kz=new Set;let td,WIe=(()=>{class n{constructor(e){this._platform=e,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):qIe}matchMedia(e){return(this._platform.WEBKIT||this._platform.BLINK)&&function GIe(n){if(!kz.has(n))try{td||(td=document.createElement("style"),td.setAttribute("type","text/css"),document.head.appendChild(td)),td.sheet&&(td.sheet.insertRule(`@media ${n} {body{ }}`,0),kz.add(n))}catch(t){console.error(t)}}(e),this._matchMedia(e)}}return n.\u0275fac=function(e){return new(e||n)(ee(ys))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function qIe(n){return{matches:"all"===n||""===n,media:n,addListener:()=>{},removeListener:()=>{}}}let Nz=(()=>{class n{constructor(e,r){this._mediaMatcher=e,this._zone=r,this._queries=new Map,this._destroySubject=new Ge}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(e){return Az(rh(e)).some(s=>this._registerQuery(s).mql.matches)}observe(e){let i=LO(Az(rh(e)).map(o=>this._registerQuery(o).observable));return i=Cg(i.pipe(Br(1)),i.pipe(_M(1),eP(0))),i.pipe(Et(o=>{const a={matches:!1,breakpoints:{}};return o.forEach(({matches:l,query:c})=>{a.matches=a.matches||l,a.breakpoints[c]=l}),a}))}_registerQuery(e){if(this._queries.has(e))return this._queries.get(e);const r=this._mediaMatcher.matchMedia(e),i={observable:new ct(o=>{const a=l=>this._zone.run(()=>o.next(l));return r.addListener(a),()=>{r.removeListener(a)}}).pipe(Uo(r),Et(({matches:o})=>({query:e,matches:o})),dr(this._destroySubject)),mql:r};return this._queries.set(e,i),i}}return n.\u0275fac=function(e){return new(e||n)(ee(WIe),ee(Ct))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Az(n){return n.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}function XIe(n,t){if(1&n){const e=Uc();Re(0,"div",2)(1,"button",3),Dr("click",function(){return No(e),ha().action()}),nt(2),Be()()}if(2&n){const e=ha();Yn(2),gm(e.data.action)}}function YIe(n,t){}const Rz=new Fe("MatSnackBarData");class Iv{constructor(){this.politeness="assertive",this.announcementMessage="",this.duration=0,this.data=null,this.horizontalPosition="center",this.verticalPosition="bottom"}}const ZIe=Math.pow(2,31)-1;class II{constructor(t,e){this._overlayRef=e,this._afterDismissed=new Ge,this._afterOpened=new Ge,this._onAction=new Ge,this._dismissedByAction=!1,this.containerInstance=t,this.onAction().subscribe(()=>this.dismiss()),t._onExit.subscribe(()=>this._finishDismiss())}dismiss(){this._afterDismissed.closed||this.containerInstance.exit(),clearTimeout(this._durationTimeoutId)}dismissWithAction(){this._onAction.closed||(this._dismissedByAction=!0,this._onAction.next(),this._onAction.complete()),clearTimeout(this._durationTimeoutId)}closeWithAction(){this.dismissWithAction()}_dismissAfter(t){this._durationTimeoutId=setTimeout(()=>this.dismiss(),Math.min(t,ZIe))}_open(){this._afterOpened.closed||(this._afterOpened.next(),this._afterOpened.complete())}_finishDismiss(){this._overlayRef.dispose(),this._onAction.closed||this._onAction.complete(),this._afterDismissed.next({dismissedByAction:this._dismissedByAction}),this._afterDismissed.complete(),this._dismissedByAction=!1}afterDismissed(){return this._afterDismissed}afterOpened(){return this.containerInstance._onEnter}onAction(){return this._onAction}}let QIe=(()=>{class n{constructor(e,r){this.snackBarRef=e,this.data=r}action(){this.snackBarRef.dismissWithAction()}get hasAction(){return!!this.data.action}}return n.\u0275fac=function(e){return new(e||n)(oe(II),oe(Rz))},n.\u0275cmp=Wn({type:n,selectors:[["simple-snack-bar"]],hostAttrs:[1,"mat-simple-snackbar"],decls:3,vars:2,consts:[[1,"mat-simple-snack-bar-content"],["class","mat-simple-snackbar-action",4,"ngIf"],[1,"mat-simple-snackbar-action"],["mat-button","",3,"click"]],template:function(e,r){1&e&&(Re(0,"span",0),nt(1),Be(),Js(2,XIe,3,1,"div",1)),2&e&&(Yn(1),gm(r.data.message),Yn(1),Cr("ngIf",r.hasAction))},directives:[HIe,jm],styles:[".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}.mat-simple-snack-bar-content{overflow:hidden;text-overflow:ellipsis}\n"],encapsulation:2,changeDetection:0}),n})();const JIe={snackBarState:Jm("state",[yl("void, hidden",Os({transform:"scale(0.8)",opacity:0})),yl("visible",Os({transform:"scale(1)",opacity:1})),_l("* => visible",gl("150ms cubic-bezier(0, 0, 0.2, 1)")),_l("* => void, * => hidden",gl("75ms cubic-bezier(0.4, 0.0, 1, 1)",Os({opacity:0})))])};let eTe=(()=>{class n extends Hg{constructor(e,r,s,i,o){super(),this._ngZone=e,this._elementRef=r,this._changeDetectorRef=s,this._platform=i,this.snackBarConfig=o,this._announceDelay=150,this._destroyed=!1,this._onAnnounce=new Ge,this._onExit=new Ge,this._onEnter=new Ge,this._animationState="void",this.attachDomPortal=a=>(this._assertNotAttached(),this._applySnackBarClasses(),this._portalOutlet.attachDomPortal(a)),this._live="assertive"!==o.politeness||o.announcementMessage?"off"===o.politeness?"off":"polite":"assertive",this._platform.FIREFOX&&("polite"===this._live&&(this._role="status"),"assertive"===this._live&&(this._role="alert"))}attachComponentPortal(e){return this._assertNotAttached(),this._applySnackBarClasses(),this._portalOutlet.attachComponentPortal(e)}attachTemplatePortal(e){return this._assertNotAttached(),this._applySnackBarClasses(),this._portalOutlet.attachTemplatePortal(e)}onAnimationEnd(e){const{fromState:r,toState:s}=e;if(("void"===s&&"void"!==r||"hidden"===s)&&this._completeExit(),"visible"===s){const i=this._onEnter;this._ngZone.run(()=>{i.next(),i.complete()})}}enter(){this._destroyed||(this._animationState="visible",this._changeDetectorRef.detectChanges(),this._screenReaderAnnounce())}exit(){return this._ngZone.run(()=>{this._animationState="hidden",this._elementRef.nativeElement.setAttribute("mat-exit",""),clearTimeout(this._announceTimeoutId)}),this._onExit}ngOnDestroy(){this._destroyed=!0,this._completeExit()}_completeExit(){this._ngZone.onMicrotaskEmpty.pipe(Br(1)).subscribe(()=>{this._ngZone.run(()=>{this._onExit.next(),this._onExit.complete()})})}_applySnackBarClasses(){const e=this._elementRef.nativeElement,r=this.snackBarConfig.panelClass;r&&(Array.isArray(r)?r.forEach(s=>e.classList.add(s)):e.classList.add(r)),"center"===this.snackBarConfig.horizontalPosition&&e.classList.add("mat-snack-bar-center"),"top"===this.snackBarConfig.verticalPosition&&e.classList.add("mat-snack-bar-top")}_assertNotAttached(){this._portalOutlet.hasAttached()}_screenReaderAnnounce(){this._announceTimeoutId||this._ngZone.runOutsideAngular(()=>{this._announceTimeoutId=setTimeout(()=>{const e=this._elementRef.nativeElement.querySelector("[aria-hidden]"),r=this._elementRef.nativeElement.querySelector("[aria-live]");if(e&&r){let s=null;this._platform.isBrowser&&document.activeElement instanceof HTMLElement&&e.contains(document.activeElement)&&(s=document.activeElement),e.removeAttribute("aria-hidden"),r.appendChild(e),null==s||s.focus(),this._onAnnounce.next(),this._onAnnounce.complete()}},this._announceDelay)})}}return n.\u0275fac=function(e){return new(e||n)(oe(Ct),oe(Cn),oe(oo),oe(ys),oe(Iv))},n.\u0275cmp=Wn({type:n,selectors:[["snack-bar-container"]],viewQuery:function(e,r){if(1&e&&dl(jg,7),2&e){let s;rs(s=ss())&&(r._portalOutlet=s.first)}},hostAttrs:[1,"mat-snack-bar-container"],hostVars:1,hostBindings:function(e,r){1&e&&Od("@state.done",function(i){return r.onAnimationEnd(i)}),2&e&&Pd("@state",r._animationState)},features:[ki],decls:3,vars:2,consts:[["aria-hidden","true"],["cdkPortalOutlet",""]],template:function(e,r){1&e&&(Re(0,"div",0),Js(1,YIe,0,0,"ng-template",1),Be(),hn(2,"div")),2&e&&(Yn(2),no("aria-live",r._live)("role",r._role))},directives:[jg],styles:[".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}.cdk-high-contrast-active .mat-snack-bar-container{border:solid 1px}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}\n"],encapsulation:2,data:{animation:[JIe.snackBarState]}}),n})(),Mz=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({imports:[[pP,Qw,Wm,jIe,fr],fr]}),n})();const Oz=new Fe("mat-snack-bar-default-options",{providedIn:"root",factory:function tTe(){return new Iv}});let nTe=(()=>{class n{constructor(e,r,s,i,o,a){this._overlay=e,this._live=r,this._injector=s,this._breakpointObserver=i,this._parentSnackBar=o,this._defaultConfig=a,this._snackBarRefAtThisLevel=null}get _openedSnackBarRef(){const e=this._parentSnackBar;return e?e._openedSnackBarRef:this._snackBarRefAtThisLevel}set _openedSnackBarRef(e){this._parentSnackBar?this._parentSnackBar._openedSnackBarRef=e:this._snackBarRefAtThisLevel=e}openFromComponent(e,r){return this._attach(e,r)}openFromTemplate(e,r){return this._attach(e,r)}open(e,r="",s){const i=Object.assign(Object.assign({},this._defaultConfig),s);return i.data={message:e,action:r},i.announcementMessage===e&&(i.announcementMessage=void 0),this.openFromComponent(this.simpleSnackBarComponent,i)}dismiss(){this._openedSnackBarRef&&this._openedSnackBarRef.dismiss()}ngOnDestroy(){this._snackBarRefAtThisLevel&&this._snackBarRefAtThisLevel.dismiss()}_attachSnackBarContainer(e,r){const i=Tn.create({parent:r&&r.viewContainerRef&&r.viewContainerRef.injector||this._injector,providers:[{provide:Iv,useValue:r}]}),o=new kh(this.snackBarContainerComponent,r.viewContainerRef,i),a=e.attach(o);return a.instance.snackBarConfig=r,a.instance}_attach(e,r){const s=Object.assign(Object.assign(Object.assign({},new Iv),this._defaultConfig),r),i=this._createOverlay(s),o=this._attachSnackBarContainer(i,s),a=new II(o,i);if(e instanceof ei){const l=new Zw(e,null,{$implicit:s.data,snackBarRef:a});a.instance=o.attachTemplatePortal(l)}else{const l=this._createInjector(s,a),c=new kh(e,void 0,l),u=o.attachComponentPortal(c);a.instance=u.instance}return this._breakpointObserver.observe("(max-width: 599.98px) and (orientation: portrait)").pipe(dr(i.detachments())).subscribe(l=>{i.overlayElement.classList.toggle(this.handsetCssClass,l.matches)}),s.announcementMessage&&o._onAnnounce.subscribe(()=>{this._live.announce(s.announcementMessage,s.politeness)}),this._animateSnackBar(a,s),this._openedSnackBarRef=a,this._openedSnackBarRef}_animateSnackBar(e,r){e.afterDismissed().subscribe(()=>{this._openedSnackBarRef==e&&(this._openedSnackBarRef=null),r.announcementMessage&&this._live.clear()}),this._openedSnackBarRef?(this._openedSnackBarRef.afterDismissed().subscribe(()=>{e.containerInstance.enter()}),this._openedSnackBarRef.dismiss()):e.containerInstance.enter(),r.duration&&r.duration>0&&e.afterOpened().subscribe(()=>e._dismissAfter(r.duration))}_createOverlay(e){const r=new eC;r.direction=e.direction;let s=this._overlay.position().global();const i="rtl"===e.direction,o="left"===e.horizontalPosition||"start"===e.horizontalPosition&&!i||"end"===e.horizontalPosition&&i,a=!o&&"center"!==e.horizontalPosition;return o?s.left("0"):a?s.right("0"):s.centerHorizontally(),"top"===e.verticalPosition?s.top("0"):s.bottom("0"),r.positionStrategy=s,this._overlay.create(r)}_createInjector(e,r){return Tn.create({parent:e&&e.viewContainerRef&&e.viewContainerRef.injector||this._injector,providers:[{provide:II,useValue:r},{provide:Rz,useValue:e.data}]})}}return n.\u0275fac=function(e){return new(e||n)(ee(lu),ee(SM),ee(Tn),ee(Nz),ee(n,12),ee(Oz))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac}),n})(),rTe=(()=>{class n extends nTe{constructor(e,r,s,i,o,a){super(e,r,s,i,o,a),this.simpleSnackBarComponent=QIe,this.snackBarContainerComponent=eTe,this.handsetCssClass="mat-snack-bar-handset"}}return n.\u0275fac=function(e){return new(e||n)(ee(lu),ee(SM),ee(Tn),ee(Nz),ee(n,12),ee(Oz))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:Mz}),n})();function TI(n,t,e){for(let r in t)if(t.hasOwnProperty(r)){const s=t[r];s?n.setProperty(r,s,(null==e?void 0:e.has(r))?"important":""):n.removeProperty(r)}return n}function nd(n,t){const e=t?"":"none";TI(n.style,{"touch-action":t?"":"none","-webkit-user-drag":t?"":"none","-webkit-tap-highlight-color":t?"":"transparent","user-select":e,"-ms-user-select":e,"-webkit-user-select":e,"-moz-user-select":e})}function Fz(n,t,e){TI(n.style,{position:t?"":"fixed",top:t?"":"0",opacity:t?"":"0",left:t?"":"-999em"},e)}function Tv(n,t){return t&&"none"!=t?n+" "+t:n}function Pz(n){const t=n.toLowerCase().indexOf("ms")>-1?1:1e3;return parseFloat(n)*t}function kI(n,t){return n.getPropertyValue(t).split(",").map(r=>r.trim())}function NI(n){const t=n.getBoundingClientRect();return{top:t.top,right:t.right,bottom:t.bottom,left:t.left,width:t.width,height:t.height,x:t.x,y:t.y}}function AI(n,t,e){const{top:r,bottom:s,left:i,right:o}=n;return e>=r&&e<=s&&t>=i&&t<=o}function vp(n,t,e){n.top+=t,n.bottom=n.top+n.height,n.left+=e,n.right=n.left+n.width}function $z(n,t,e,r){const{top:s,right:i,bottom:o,left:a,width:l,height:c}=n,u=l*t,d=c*t;return r>s-d&&r<o+d&&e>a-u&&e<i+u}class Lz{constructor(t){this._document=t,this.positions=new Map}clear(){this.positions.clear()}cache(t){this.clear(),this.positions.set(this._document,{scrollPosition:this.getViewportScrollPosition()}),t.forEach(e=>{this.positions.set(e,{scrollPosition:{top:e.scrollTop,left:e.scrollLeft},clientRect:NI(e)})})}handleScroll(t){const e=Pi(t),r=this.positions.get(e);if(!r)return null;const s=r.scrollPosition;let i,o;if(e===this._document){const c=this.getViewportScrollPosition();i=c.top,o=c.left}else i=e.scrollTop,o=e.scrollLeft;const a=s.top-i,l=s.left-o;return this.positions.forEach((c,u)=>{c.clientRect&&e!==u&&e.contains(u)&&vp(c.clientRect,a,l)}),s.top=i,s.left=o,{top:a,left:l}}getViewportScrollPosition(){return{top:window.scrollY,left:window.scrollX}}}function Vz(n){const t=n.cloneNode(!0),e=t.querySelectorAll("[id]"),r=n.nodeName.toLowerCase();t.removeAttribute("id");for(let s=0;s<e.length;s++)e[s].removeAttribute("id");return"canvas"===r?Uz(n,t):("input"===r||"select"===r||"textarea"===r)&&zz(n,t),Bz("canvas",n,t,Uz),Bz("input, textarea, select",n,t,zz),t}function Bz(n,t,e,r){const s=t.querySelectorAll(n);if(s.length){const i=e.querySelectorAll(n);for(let o=0;o<s.length;o++)r(s[o],i[o])}}let oTe=0;function zz(n,t){"file"!==t.type&&(t.value=n.value),"radio"===t.type&&t.name&&(t.name=`mat-clone-${t.name}-${oTe++}`)}function Uz(n,t){const e=t.getContext("2d");if(e)try{e.drawImage(n,0,0)}catch(r){}}const Hz=pl({passive:!0}),kv=pl({passive:!1}),RI=new Set(["position"]);class lTe{constructor(t,e,r,s,i,o){this._config=e,this._document=r,this._ngZone=s,this._viewportRuler=i,this._dragDropRegistry=o,this._passiveTransform={x:0,y:0},this._activeTransform={x:0,y:0},this._hasStartedDragging=!1,this._moveEvents=new Ge,this._pointerMoveSubscription=x.EMPTY,this._pointerUpSubscription=x.EMPTY,this._scrollSubscription=x.EMPTY,this._resizeSubscription=x.EMPTY,this._boundaryElement=null,this._nativeInteractionsEnabled=!0,this._handles=[],this._disabledHandles=new Set,this._direction="ltr",this.dragStartDelay=0,this._disabled=!1,this.beforeStarted=new Ge,this.started=new Ge,this.released=new Ge,this.ended=new Ge,this.entered=new Ge,this.exited=new Ge,this.dropped=new Ge,this.moved=this._moveEvents,this._pointerDown=a=>{if(this.beforeStarted.next(),this._handles.length){const l=this._getTargetHandle(a);l&&!this._disabledHandles.has(l)&&!this.disabled&&this._initializeDragSequence(l,a)}else this.disabled||this._initializeDragSequence(this._rootElement,a)},this._pointerMove=a=>{const l=this._getPointerPositionOnPage(a);if(!this._hasStartedDragging){if(Math.abs(l.x-this._pickupPositionOnPage.x)+Math.abs(l.y-this._pickupPositionOnPage.y)>=this._config.dragStartThreshold){const f=Date.now()>=this._dragStartTime+this._getDragStartDelay(a),p=this._dropContainer;if(!f)return void this._endDragSequence(a);(!p||!p.isDragging()&&!p.isReceiving())&&(a.preventDefault(),this._hasStartedDragging=!0,this._ngZone.run(()=>this._startDragSequence(a)))}return}a.preventDefault();const c=this._getConstrainedPointerPosition(l);if(this._hasMoved=!0,this._lastKnownPointerPosition=l,this._updatePointerDirectionDelta(c),this._dropContainer)this._updateActiveDropContainer(c,l);else{const u=this._activeTransform;u.x=c.x-this._pickupPositionOnPage.x+this._passiveTransform.x,u.y=c.y-this._pickupPositionOnPage.y+this._passiveTransform.y,this._applyRootElementTransform(u.x,u.y)}this._moveEvents.observers.length&&this._ngZone.run(()=>{this._moveEvents.next({source:this,pointerPosition:c,event:a,distance:this._getDragDistance(c),delta:this._pointerDirectionDelta})})},this._pointerUp=a=>{this._endDragSequence(a)},this._nativeDragStart=a=>{if(this._handles.length){const l=this._getTargetHandle(a);l&&!this._disabledHandles.has(l)&&!this.disabled&&a.preventDefault()}else this.disabled||a.preventDefault()},this.withRootElement(t).withParent(e.parentDragRef||null),this._parentPositions=new Lz(r),o.registerDragItem(this)}get disabled(){return this._disabled||!(!this._dropContainer||!this._dropContainer.disabled)}set disabled(t){const e=Rr(t);e!==this._disabled&&(this._disabled=e,this._toggleNativeDragInteractions(),this._handles.forEach(r=>nd(r,e)))}getPlaceholderElement(){return this._placeholder}getRootElement(){return this._rootElement}getVisibleElement(){return this.isDragging()?this.getPlaceholderElement():this.getRootElement()}withHandles(t){this._handles=t.map(r=>hr(r)),this._handles.forEach(r=>nd(r,this.disabled)),this._toggleNativeDragInteractions();const e=new Set;return this._disabledHandles.forEach(r=>{this._handles.indexOf(r)>-1&&e.add(r)}),this._disabledHandles=e,this}withPreviewTemplate(t){return this._previewTemplate=t,this}withPlaceholderTemplate(t){return this._placeholderTemplate=t,this}withRootElement(t){const e=hr(t);return e!==this._rootElement&&(this._rootElement&&this._removeRootElementListeners(this._rootElement),this._ngZone.runOutsideAngular(()=>{e.addEventListener("mousedown",this._pointerDown,kv),e.addEventListener("touchstart",this._pointerDown,Hz),e.addEventListener("dragstart",this._nativeDragStart,kv)}),this._initialTransform=void 0,this._rootElement=e),"undefined"!=typeof SVGElement&&this._rootElement instanceof SVGElement&&(this._ownerSVGElement=this._rootElement.ownerSVGElement),this}withBoundaryElement(t){return this._boundaryElement=t?hr(t):null,this._resizeSubscription.unsubscribe(),t&&(this._resizeSubscription=this._viewportRuler.change(10).subscribe(()=>this._containInsideBoundaryOnResize())),this}withParent(t){return this._parentDragRef=t,this}dispose(){var t,e;this._removeRootElementListeners(this._rootElement),this.isDragging()&&(null===(t=this._rootElement)||void 0===t||t.remove()),null===(e=this._anchor)||void 0===e||e.remove(),this._destroyPreview(),this._destroyPlaceholder(),this._dragDropRegistry.removeDragItem(this),this._removeSubscriptions(),this.beforeStarted.complete(),this.started.complete(),this.released.complete(),this.ended.complete(),this.entered.complete(),this.exited.complete(),this.dropped.complete(),this._moveEvents.complete(),this._handles=[],this._disabledHandles.clear(),this._dropContainer=void 0,this._resizeSubscription.unsubscribe(),this._parentPositions.clear(),this._boundaryElement=this._rootElement=this._ownerSVGElement=this._placeholderTemplate=this._previewTemplate=this._anchor=this._parentDragRef=null}isDragging(){return this._hasStartedDragging&&this._dragDropRegistry.isDragging(this)}reset(){this._rootElement.style.transform=this._initialTransform||"",this._activeTransform={x:0,y:0},this._passiveTransform={x:0,y:0}}disableHandle(t){!this._disabledHandles.has(t)&&this._handles.indexOf(t)>-1&&(this._disabledHandles.add(t),nd(t,!0))}enableHandle(t){this._disabledHandles.has(t)&&(this._disabledHandles.delete(t),nd(t,this.disabled))}withDirection(t){return this._direction=t,this}_withDropContainer(t){this._dropContainer=t}getFreeDragPosition(){const t=this.isDragging()?this._activeTransform:this._passiveTransform;return{x:t.x,y:t.y}}setFreeDragPosition(t){return this._activeTransform={x:0,y:0},this._passiveTransform.x=t.x,this._passiveTransform.y=t.y,this._dropContainer||this._applyRootElementTransform(t.x,t.y),this}withPreviewContainer(t){return this._previewContainer=t,this}_sortFromLastPointerPosition(){const t=this._lastKnownPointerPosition;t&&this._dropContainer&&this._updateActiveDropContainer(this._getConstrainedPointerPosition(t),t)}_removeSubscriptions(){this._pointerMoveSubscription.unsubscribe(),this._pointerUpSubscription.unsubscribe(),this._scrollSubscription.unsubscribe()}_destroyPreview(){var t,e;null===(t=this._preview)||void 0===t||t.remove(),null===(e=this._previewRef)||void 0===e||e.destroy(),this._preview=this._previewRef=null}_destroyPlaceholder(){var t,e;null===(t=this._placeholder)||void 0===t||t.remove(),null===(e=this._placeholderRef)||void 0===e||e.destroy(),this._placeholder=this._placeholderRef=null}_endDragSequence(t){if(this._dragDropRegistry.isDragging(this)&&(this._removeSubscriptions(),this._dragDropRegistry.stopDragging(this),this._toggleNativeDragInteractions(),this._handles&&(this._rootElement.style.webkitTapHighlightColor=this._rootElementTapHighlight),this._hasStartedDragging))if(this.released.next({source:this}),this._dropContainer)this._dropContainer._stopScrolling(),this._animatePreviewToPlaceholder().then(()=>{this._cleanupDragArtifacts(t),this._cleanupCachedDimensions(),this._dragDropRegistry.stopDragging(this)});else{this._passiveTransform.x=this._activeTransform.x;const e=this._getPointerPositionOnPage(t);this._passiveTransform.y=this._activeTransform.y,this._ngZone.run(()=>{this.ended.next({source:this,distance:this._getDragDistance(e),dropPoint:e})}),this._cleanupCachedDimensions(),this._dragDropRegistry.stopDragging(this)}}_startDragSequence(t){bp(t)&&(this._lastTouchEventTime=Date.now()),this._toggleNativeDragInteractions();const e=this._dropContainer;if(e){const r=this._rootElement,s=r.parentNode,i=this._placeholder=this._createPlaceholderElement(),o=this._anchor=this._anchor||this._document.createComment(""),a=this._getShadowRoot();s.insertBefore(o,r),this._initialTransform=r.style.transform||"",this._preview=this._createPreviewElement(),Fz(r,!1,RI),this._document.body.appendChild(s.replaceChild(i,r)),this._getPreviewInsertionPoint(s,a).appendChild(this._preview),this.started.next({source:this}),e.start(),this._initialContainer=e,this._initialIndex=e.getItemIndex(this)}else this.started.next({source:this}),this._initialContainer=this._initialIndex=void 0;this._parentPositions.cache(e?e.getScrollableParents():[])}_initializeDragSequence(t,e){this._parentDragRef&&e.stopPropagation();const r=this.isDragging(),s=bp(e),i=!s&&0!==e.button,o=this._rootElement,a=Pi(e),l=!s&&this._lastTouchEventTime&&this._lastTouchEventTime+800>Date.now(),c=s?Hx(e):Ux(e);if(a&&a.draggable&&"mousedown"===e.type&&e.preventDefault(),r||i||l||c)return;if(this._handles.length){const h=o.style;this._rootElementTapHighlight=h.webkitTapHighlightColor||"",h.webkitTapHighlightColor="transparent"}this._hasStartedDragging=this._hasMoved=!1,this._removeSubscriptions(),this._pointerMoveSubscription=this._dragDropRegistry.pointerMove.subscribe(this._pointerMove),this._pointerUpSubscription=this._dragDropRegistry.pointerUp.subscribe(this._pointerUp),this._scrollSubscription=this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(h=>this._updateOnScroll(h)),this._boundaryElement&&(this._boundaryRect=NI(this._boundaryElement));const u=this._previewTemplate;this._pickupPositionInElement=u&&u.template&&!u.matchSize?{x:0,y:0}:this._getPointerPositionInElement(t,e);const d=this._pickupPositionOnPage=this._lastKnownPointerPosition=this._getPointerPositionOnPage(e);this._pointerDirectionDelta={x:0,y:0},this._pointerPositionAtLastDirectionChange={x:d.x,y:d.y},this._dragStartTime=Date.now(),this._dragDropRegistry.startDragging(this,e)}_cleanupDragArtifacts(t){Fz(this._rootElement,!0,RI),this._anchor.parentNode.replaceChild(this._rootElement,this._anchor),this._destroyPreview(),this._destroyPlaceholder(),this._boundaryRect=this._previewRect=this._initialTransform=void 0,this._ngZone.run(()=>{const e=this._dropContainer,r=e.getItemIndex(this),s=this._getPointerPositionOnPage(t),i=this._getDragDistance(s),o=e._isOverContainer(s.x,s.y);this.ended.next({source:this,distance:i,dropPoint:s}),this.dropped.next({item:this,currentIndex:r,previousIndex:this._initialIndex,container:e,previousContainer:this._initialContainer,isPointerOverContainer:o,distance:i,dropPoint:s}),e.drop(this,r,this._initialIndex,this._initialContainer,o,i,s),this._dropContainer=this._initialContainer})}_updateActiveDropContainer({x:t,y:e},{x:r,y:s}){let i=this._initialContainer._getSiblingContainerFromPosition(this,t,e);!i&&this._dropContainer!==this._initialContainer&&this._initialContainer._isOverContainer(t,e)&&(i=this._initialContainer),i&&i!==this._dropContainer&&this._ngZone.run(()=>{this.exited.next({item:this,container:this._dropContainer}),this._dropContainer.exit(this),this._dropContainer=i,this._dropContainer.enter(this,t,e,i===this._initialContainer&&i.sortingDisabled?this._initialIndex:void 0),this.entered.next({item:this,container:i,currentIndex:i.getItemIndex(this)})}),this.isDragging()&&(this._dropContainer._startScrollingIfNecessary(r,s),this._dropContainer._sortItem(this,t,e,this._pointerDirectionDelta),this._applyPreviewTransform(t-this._pickupPositionInElement.x,e-this._pickupPositionInElement.y))}_createPreviewElement(){const t=this._previewTemplate,e=this.previewClass,r=t?t.template:null;let s;if(r&&t){const i=t.matchSize?this._rootElement.getBoundingClientRect():null,o=t.viewContainer.createEmbeddedView(r,t.context);o.detectChanges(),s=Wz(o,this._document),this._previewRef=o,t.matchSize?Gz(s,i):s.style.transform=Nv(this._pickupPositionOnPage.x,this._pickupPositionOnPage.y)}else{const i=this._rootElement;s=Vz(i),Gz(s,i.getBoundingClientRect()),this._initialTransform&&(s.style.transform=this._initialTransform)}return TI(s.style,{"pointer-events":"none",margin:"0",position:"fixed",top:"0",left:"0","z-index":`${this._config.zIndex||1e3}`},RI),nd(s,!1),s.classList.add("cdk-drag-preview"),s.setAttribute("dir",this._direction),e&&(Array.isArray(e)?e.forEach(i=>s.classList.add(i)):s.classList.add(e)),s}_animatePreviewToPlaceholder(){if(!this._hasMoved)return Promise.resolve();const t=this._placeholder.getBoundingClientRect();this._preview.classList.add("cdk-drag-animating"),this._applyPreviewTransform(t.left,t.top);const e=function iTe(n){const t=getComputedStyle(n),e=kI(t,"transition-property"),r=e.find(a=>"transform"===a||"all"===a);if(!r)return 0;const s=e.indexOf(r),i=kI(t,"transition-duration"),o=kI(t,"transition-delay");return Pz(i[s])+Pz(o[s])}(this._preview);return 0===e?Promise.resolve():this._ngZone.runOutsideAngular(()=>new Promise(r=>{const s=o=>{var a;(!o||Pi(o)===this._preview&&"transform"===o.propertyName)&&(null===(a=this._preview)||void 0===a||a.removeEventListener("transitionend",s),r(),clearTimeout(i))},i=setTimeout(s,1.5*e);this._preview.addEventListener("transitionend",s)}))}_createPlaceholderElement(){const t=this._placeholderTemplate,e=t?t.template:null;let r;return e?(this._placeholderRef=t.viewContainer.createEmbeddedView(e,t.context),this._placeholderRef.detectChanges(),r=Wz(this._placeholderRef,this._document)):r=Vz(this._rootElement),r.style.pointerEvents="none",r.classList.add("cdk-drag-placeholder"),r}_getPointerPositionInElement(t,e){const r=this._rootElement.getBoundingClientRect(),s=t===this._rootElement?null:t,i=s?s.getBoundingClientRect():r,o=bp(e)?e.targetTouches[0]:e,a=this._getViewportScrollPosition();return{x:i.left-r.left+(o.pageX-i.left-a.left),y:i.top-r.top+(o.pageY-i.top-a.top)}}_getPointerPositionOnPage(t){const e=this._getViewportScrollPosition(),r=bp(t)?t.touches[0]||t.changedTouches[0]||{pageX:0,pageY:0}:t,s=r.pageX-e.left,i=r.pageY-e.top;if(this._ownerSVGElement){const o=this._ownerSVGElement.getScreenCTM();if(o){const a=this._ownerSVGElement.createSVGPoint();return a.x=s,a.y=i,a.matrixTransform(o.inverse())}}return{x:s,y:i}}_getConstrainedPointerPosition(t){const e=this._dropContainer?this._dropContainer.lockAxis:null;let{x:r,y:s}=this.constrainPosition?this.constrainPosition(t,this):t;if("x"===this.lockAxis||"x"===e?s=this._pickupPositionOnPage.y:("y"===this.lockAxis||"y"===e)&&(r=this._pickupPositionOnPage.x),this._boundaryRect){const{x:i,y:o}=this._pickupPositionInElement,a=this._boundaryRect,{width:l,height:c}=this._getPreviewRect(),u=a.top+o,d=a.bottom-(c-o);r=jz(r,a.left+i,a.right-(l-i)),s=jz(s,u,d)}return{x:r,y:s}}_updatePointerDirectionDelta(t){const{x:e,y:r}=t,s=this._pointerDirectionDelta,i=this._pointerPositionAtLastDirectionChange,o=Math.abs(e-i.x),a=Math.abs(r-i.y);return o>this._config.pointerDirectionChangeThreshold&&(s.x=e>i.x?1:-1,i.x=e),a>this._config.pointerDirectionChangeThreshold&&(s.y=r>i.y?1:-1,i.y=r),s}_toggleNativeDragInteractions(){if(!this._rootElement||!this._handles)return;const t=this._handles.length>0||!this.isDragging();t!==this._nativeInteractionsEnabled&&(this._nativeInteractionsEnabled=t,nd(this._rootElement,t))}_removeRootElementListeners(t){t.removeEventListener("mousedown",this._pointerDown,kv),t.removeEventListener("touchstart",this._pointerDown,Hz),t.removeEventListener("dragstart",this._nativeDragStart,kv)}_applyRootElementTransform(t,e){const r=Nv(t,e),s=this._rootElement.style;null==this._initialTransform&&(this._initialTransform=s.transform&&"none"!=s.transform?s.transform:""),s.transform=Tv(r,this._initialTransform)}_applyPreviewTransform(t,e){var r;const s=(null===(r=this._previewTemplate)||void 0===r?void 0:r.template)?void 0:this._initialTransform,i=Nv(t,e);this._preview.style.transform=Tv(i,s)}_getDragDistance(t){const e=this._pickupPositionOnPage;return e?{x:t.x-e.x,y:t.y-e.y}:{x:0,y:0}}_cleanupCachedDimensions(){this._boundaryRect=this._previewRect=void 0,this._parentPositions.clear()}_containInsideBoundaryOnResize(){let{x:t,y:e}=this._passiveTransform;if(0===t&&0===e||this.isDragging()||!this._boundaryElement)return;const r=this._boundaryElement.getBoundingClientRect(),s=this._rootElement.getBoundingClientRect();if(0===r.width&&0===r.height||0===s.width&&0===s.height)return;const i=r.left-s.left,o=s.right-r.right,a=r.top-s.top,l=s.bottom-r.bottom;r.width>s.width?(i>0&&(t+=i),o>0&&(t-=o)):t=0,r.height>s.height?(a>0&&(e+=a),l>0&&(e-=l)):e=0,(t!==this._passiveTransform.x||e!==this._passiveTransform.y)&&this.setFreeDragPosition({y:e,x:t})}_getDragStartDelay(t){const e=this.dragStartDelay;return"number"==typeof e?e:bp(t)?e.touch:e?e.mouse:0}_updateOnScroll(t){const e=this._parentPositions.handleScroll(t);if(e){const r=Pi(t);this._boundaryRect&&r!==this._boundaryElement&&r.contains(this._boundaryElement)&&vp(this._boundaryRect,e.top,e.left),this._pickupPositionOnPage.x+=e.left,this._pickupPositionOnPage.y+=e.top,this._dropContainer||(this._activeTransform.x-=e.left,this._activeTransform.y-=e.top,this._applyRootElementTransform(this._activeTransform.x,this._activeTransform.y))}}_getViewportScrollPosition(){var t;return(null===(t=this._parentPositions.positions.get(this._document))||void 0===t?void 0:t.scrollPosition)||this._parentPositions.getViewportScrollPosition()}_getShadowRoot(){return void 0===this._cachedShadowRoot&&(this._cachedShadowRoot=$x(this._rootElement)),this._cachedShadowRoot}_getPreviewInsertionPoint(t,e){const r=this._previewContainer||"global";if("parent"===r)return t;if("global"===r){const s=this._document;return e||s.fullscreenElement||s.webkitFullscreenElement||s.mozFullScreenElement||s.msFullscreenElement||s.body}return hr(r)}_getPreviewRect(){return(!this._previewRect||!this._previewRect.width&&!this._previewRect.height)&&(this._previewRect=(this._preview||this._rootElement).getBoundingClientRect()),this._previewRect}_getTargetHandle(t){return this._handles.find(e=>t.target&&(t.target===e||e.contains(t.target)))}}function Nv(n,t){return`translate3d(${Math.round(n)}px, ${Math.round(t)}px, 0)`}function jz(n,t,e){return Math.max(t,Math.min(e,n))}function bp(n){return"t"===n.type[0]}function Wz(n,t){const e=n.rootNodes;if(1===e.length&&e[0].nodeType===t.ELEMENT_NODE)return e[0];const r=t.createElement("div");return e.forEach(s=>r.appendChild(s)),r}function Gz(n,t){n.style.width=`${t.width}px`,n.style.height=`${t.height}px`,n.style.transform=Nv(t.left,t.top)}function xp(n,t){return Math.max(0,Math.min(t,n))}class uTe{constructor(t,e,r,s,i){this._dragDropRegistry=e,this._ngZone=s,this._viewportRuler=i,this.disabled=!1,this.sortingDisabled=!1,this.autoScrollDisabled=!1,this.autoScrollStep=2,this.enterPredicate=()=>!0,this.sortPredicate=()=>!0,this.beforeStarted=new Ge,this.entered=new Ge,this.exited=new Ge,this.dropped=new Ge,this.sorted=new Ge,this._isDragging=!1,this._itemPositions=[],this._previousSwap={drag:null,delta:0,overlaps:!1},this._draggables=[],this._siblings=[],this._orientation="vertical",this._activeSiblings=new Set,this._direction="ltr",this._viewportScrollSubscription=x.EMPTY,this._verticalScrollDirection=0,this._horizontalScrollDirection=0,this._stopScrollTimers=new Ge,this._cachedShadowRoot=null,this._startScrollInterval=()=>{this._stopScrolling(),function sTe(n=0,t=zg){return n<0&&(n=0),ZF(n,n,t)}(0,XF).pipe(dr(this._stopScrollTimers)).subscribe(()=>{const o=this._scrollNode,a=this.autoScrollStep;1===this._verticalScrollDirection?o.scrollBy(0,-a):2===this._verticalScrollDirection&&o.scrollBy(0,a),1===this._horizontalScrollDirection?o.scrollBy(-a,0):2===this._horizontalScrollDirection&&o.scrollBy(a,0)})},this.element=hr(t),this._document=r,this.withScrollableParents([this.element]),e.registerDropContainer(this),this._parentPositions=new Lz(r)}dispose(){this._stopScrolling(),this._stopScrollTimers.complete(),this._viewportScrollSubscription.unsubscribe(),this.beforeStarted.complete(),this.entered.complete(),this.exited.complete(),this.dropped.complete(),this.sorted.complete(),this._activeSiblings.clear(),this._scrollNode=null,this._parentPositions.clear(),this._dragDropRegistry.removeDropContainer(this)}isDragging(){return this._isDragging}start(){this._draggingStarted(),this._notifyReceivingSiblings()}enter(t,e,r,s){let i;this._draggingStarted(),null==s?(i=this.sortingDisabled?this._draggables.indexOf(t):-1,-1===i&&(i=this._getItemIndexFromPointerPosition(t,e,r))):i=s;const o=this._activeDraggables,a=o.indexOf(t),l=t.getPlaceholderElement();let c=o[i];if(c===t&&(c=o[i+1]),!c&&(null==i||-1===i||i<o.length-1)&&this._shouldEnterAsFirstChild(e,r)&&(c=o[0]),a>-1&&o.splice(a,1),c&&!this._dragDropRegistry.isDragging(c)){const u=c.getRootElement();u.parentElement.insertBefore(l,u),o.splice(i,0,t)}else hr(this.element).appendChild(l),o.push(t);l.style.transform="",this._cacheItemPositions(),this._cacheParentPositions(),this._notifyReceivingSiblings(),this.entered.next({item:t,container:this,currentIndex:this.getItemIndex(t)})}exit(t){this._reset(),this.exited.next({item:t,container:this})}drop(t,e,r,s,i,o,a){this._reset(),this.dropped.next({item:t,currentIndex:e,previousIndex:r,container:this,previousContainer:s,isPointerOverContainer:i,distance:o,dropPoint:a})}withItems(t){const e=this._draggables;return this._draggables=t,t.forEach(r=>r._withDropContainer(this)),this.isDragging()&&(e.filter(s=>s.isDragging()).every(s=>-1===t.indexOf(s))?this._reset():this._cacheItems()),this}withDirection(t){return this._direction=t,this}connectedTo(t){return this._siblings=t.slice(),this}withOrientation(t){return this._orientation=t,this}withScrollableParents(t){const e=hr(this.element);return this._scrollableElements=-1===t.indexOf(e)?[e,...t]:t.slice(),this}getScrollableParents(){return this._scrollableElements}getItemIndex(t){return this._isDragging?("horizontal"===this._orientation&&"rtl"===this._direction?this._itemPositions.slice().reverse():this._itemPositions).findIndex(r=>r.drag===t):this._draggables.indexOf(t)}isReceiving(){return this._activeSiblings.size>0}_sortItem(t,e,r,s){if(this.sortingDisabled||!this._clientRect||!$z(this._clientRect,.05,e,r))return;const i=this._itemPositions,o=this._getItemIndexFromPointerPosition(t,e,r,s);if(-1===o&&i.length>0)return;const a="horizontal"===this._orientation,l=i.findIndex(g=>g.drag===t),c=i[o],d=c.clientRect,h=l>o?1:-1,f=this._getItemOffsetPx(i[l].clientRect,d,h),p=this._getSiblingOffsetPx(l,i,h),m=i.slice();(function cTe(n,t,e){const r=xp(t,n.length-1),s=xp(e,n.length-1);if(r===s)return;const i=n[r],o=s<r?-1:1;for(let a=r;a!==s;a+=o)n[a]=n[a+o];n[s]=i})(i,l,o),this.sorted.next({previousIndex:l,currentIndex:o,container:this,item:t}),i.forEach((g,_)=>{if(m[_]===g)return;const y=g.drag===t,v=y?f:p,b=y?t.getPlaceholderElement():g.drag.getRootElement();g.offset+=v,a?(b.style.transform=Tv(`translate3d(${Math.round(g.offset)}px, 0, 0)`,g.initialTransform),vp(g.clientRect,0,v)):(b.style.transform=Tv(`translate3d(0, ${Math.round(g.offset)}px, 0)`,g.initialTransform),vp(g.clientRect,v,0))}),this._previousSwap.overlaps=AI(d,e,r),this._previousSwap.drag=c.drag,this._previousSwap.delta=a?s.x:s.y}_startScrollingIfNecessary(t,e){if(this.autoScrollDisabled)return;let r,s=0,i=0;if(this._parentPositions.positions.forEach((o,a)=>{a===this._document||!o.clientRect||r||$z(o.clientRect,.05,t,e)&&([s,i]=function dTe(n,t,e,r){const s=Xz(t,r),i=Yz(t,e);let o=0,a=0;if(s){const l=n.scrollTop;1===s?l>0&&(o=1):n.scrollHeight-l>n.clientHeight&&(o=2)}if(i){const l=n.scrollLeft;1===i?l>0&&(a=1):n.scrollWidth-l>n.clientWidth&&(a=2)}return[o,a]}(a,o.clientRect,t,e),(s||i)&&(r=a))}),!s&&!i){const{width:o,height:a}=this._viewportRuler.getViewportSize(),l={width:o,height:a,top:0,right:o,bottom:a,left:0};s=Xz(l,e),i=Yz(l,t),r=window}r&&(s!==this._verticalScrollDirection||i!==this._horizontalScrollDirection||r!==this._scrollNode)&&(this._verticalScrollDirection=s,this._horizontalScrollDirection=i,this._scrollNode=r,(s||i)&&r?this._ngZone.runOutsideAngular(this._startScrollInterval):this._stopScrolling())}_stopScrolling(){this._stopScrollTimers.next()}_draggingStarted(){const t=hr(this.element).style;this.beforeStarted.next(),this._isDragging=!0,this._initialScrollSnap=t.msScrollSnapType||t.scrollSnapType||"",t.scrollSnapType=t.msScrollSnapType="none",this._cacheItems(),this._viewportScrollSubscription.unsubscribe(),this._listenToScrollEvents()}_cacheParentPositions(){const t=hr(this.element);this._parentPositions.cache(this._scrollableElements),this._clientRect=this._parentPositions.positions.get(t).clientRect}_cacheItemPositions(){const t="horizontal"===this._orientation;this._itemPositions=this._activeDraggables.map(e=>{const r=e.getVisibleElement();return{drag:e,offset:0,initialTransform:r.style.transform||"",clientRect:NI(r)}}).sort((e,r)=>t?e.clientRect.left-r.clientRect.left:e.clientRect.top-r.clientRect.top)}_reset(){this._isDragging=!1;const t=hr(this.element).style;t.scrollSnapType=t.msScrollSnapType=this._initialScrollSnap,this._activeDraggables.forEach(e=>{var r;const s=e.getRootElement();if(s){const i=null===(r=this._itemPositions.find(o=>o.drag===e))||void 0===r?void 0:r.initialTransform;s.style.transform=i||""}}),this._siblings.forEach(e=>e._stopReceiving(this)),this._activeDraggables=[],this._itemPositions=[],this._previousSwap.drag=null,this._previousSwap.delta=0,this._previousSwap.overlaps=!1,this._stopScrolling(),this._viewportScrollSubscription.unsubscribe(),this._parentPositions.clear()}_getSiblingOffsetPx(t,e,r){const s="horizontal"===this._orientation,i=e[t].clientRect,o=e[t+-1*r];let a=i[s?"width":"height"]*r;if(o){const l=s?"left":"top",c=s?"right":"bottom";-1===r?a-=o.clientRect[l]-i[c]:a+=i[l]-o.clientRect[c]}return a}_getItemOffsetPx(t,e,r){const s="horizontal"===this._orientation;let i=s?e.left-t.left:e.top-t.top;return-1===r&&(i+=s?e.width-t.width:e.height-t.height),i}_shouldEnterAsFirstChild(t,e){if(!this._activeDraggables.length)return!1;const r=this._itemPositions,s="horizontal"===this._orientation;if(r[0].drag!==this._activeDraggables[0]){const o=r[r.length-1].clientRect;return s?t>=o.right:e>=o.bottom}{const o=r[0].clientRect;return s?t<=o.left:e<=o.top}}_getItemIndexFromPointerPosition(t,e,r,s){const i="horizontal"===this._orientation,o=this._itemPositions.findIndex(({drag:a,clientRect:l})=>{if(a===t)return!1;if(s){const c=i?s.x:s.y;if(a===this._previousSwap.drag&&this._previousSwap.overlaps&&c===this._previousSwap.delta)return!1}return i?e>=Math.floor(l.left)&&e<Math.floor(l.right):r>=Math.floor(l.top)&&r<Math.floor(l.bottom)});return-1!==o&&this.sortPredicate(o,t,this)?o:-1}_cacheItems(){this._activeDraggables=this._draggables.slice(),this._cacheItemPositions(),this._cacheParentPositions()}_isOverContainer(t,e){return null!=this._clientRect&&AI(this._clientRect,t,e)}_getSiblingContainerFromPosition(t,e,r){return this._siblings.find(s=>s._canReceive(t,e,r))}_canReceive(t,e,r){if(!this._clientRect||!AI(this._clientRect,e,r)||!this.enterPredicate(t,this))return!1;const s=this._getShadowRoot().elementFromPoint(e,r);if(!s)return!1;const i=hr(this.element);return s===i||i.contains(s)}_startReceiving(t,e){const r=this._activeSiblings;!r.has(t)&&e.every(s=>this.enterPredicate(s,this)||this._draggables.indexOf(s)>-1)&&(r.add(t),this._cacheParentPositions(),this._listenToScrollEvents())}_stopReceiving(t){this._activeSiblings.delete(t),this._viewportScrollSubscription.unsubscribe()}_listenToScrollEvents(){this._viewportScrollSubscription=this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(t=>{if(this.isDragging()){const e=this._parentPositions.handleScroll(t);e&&(this._itemPositions.forEach(({clientRect:r})=>{vp(r,e.top,e.left)}),this._itemPositions.forEach(({drag:r})=>{this._dragDropRegistry.isDragging(r)&&r._sortFromLastPointerPosition()}))}else this.isReceiving()&&this._cacheParentPositions()})}_getShadowRoot(){if(!this._cachedShadowRoot){const t=$x(hr(this.element));this._cachedShadowRoot=t||this._document}return this._cachedShadowRoot}_notifyReceivingSiblings(){const t=this._activeDraggables.filter(e=>e.isDragging());this._siblings.forEach(e=>e._startReceiving(this,t))}}function Xz(n,t){const{top:e,bottom:r,height:s}=n,i=.05*s;return t>=e-i&&t<=e+i?1:t>=r-i&&t<=r+i?2:0}function Yz(n,t){const{left:e,right:r,width:s}=n,i=.05*s;return t>=e-i&&t<=e+i?1:t>=r-i&&t<=r+i?2:0}const Av=pl({passive:!1,capture:!0});let hTe=(()=>{class n{constructor(e,r){this._ngZone=e,this._dropInstances=new Set,this._dragInstances=new Set,this._activeDragInstances=[],this._globalListeners=new Map,this._draggingPredicate=s=>s.isDragging(),this.pointerMove=new Ge,this.pointerUp=new Ge,this.scroll=new Ge,this._preventDefaultWhileDragging=s=>{this._activeDragInstances.length>0&&s.preventDefault()},this._persistentTouchmoveListener=s=>{this._activeDragInstances.length>0&&(this._activeDragInstances.some(this._draggingPredicate)&&s.preventDefault(),this.pointerMove.next(s))},this._document=r}registerDropContainer(e){this._dropInstances.has(e)||this._dropInstances.add(e)}registerDragItem(e){this._dragInstances.add(e),1===this._dragInstances.size&&this._ngZone.runOutsideAngular(()=>{this._document.addEventListener("touchmove",this._persistentTouchmoveListener,Av)})}removeDropContainer(e){this._dropInstances.delete(e)}removeDragItem(e){this._dragInstances.delete(e),this.stopDragging(e),0===this._dragInstances.size&&this._document.removeEventListener("touchmove",this._persistentTouchmoveListener,Av)}startDragging(e,r){if(!(this._activeDragInstances.indexOf(e)>-1)&&(this._activeDragInstances.push(e),1===this._activeDragInstances.length)){const s=r.type.startsWith("touch");this._globalListeners.set(s?"touchend":"mouseup",{handler:i=>this.pointerUp.next(i),options:!0}).set("scroll",{handler:i=>this.scroll.next(i),options:!0}).set("selectstart",{handler:this._preventDefaultWhileDragging,options:Av}),s||this._globalListeners.set("mousemove",{handler:i=>this.pointerMove.next(i),options:Av}),this._ngZone.runOutsideAngular(()=>{this._globalListeners.forEach((i,o)=>{this._document.addEventListener(o,i.handler,i.options)})})}}stopDragging(e){const r=this._activeDragInstances.indexOf(e);r>-1&&(this._activeDragInstances.splice(r,1),0===this._activeDragInstances.length&&this._clearGlobalListeners())}isDragging(e){return this._activeDragInstances.indexOf(e)>-1}scrolled(e){const r=[this.scroll];return e&&e!==this._document&&r.push(new ct(s=>this._ngZone.runOutsideAngular(()=>{const o=a=>{this._activeDragInstances.length&&s.next(a)};return e.addEventListener("scroll",o,!0),()=>{e.removeEventListener("scroll",o,!0)}}))),id(...r)}ngOnDestroy(){this._dragInstances.forEach(e=>this.removeDragItem(e)),this._dropInstances.forEach(e=>this.removeDropContainer(e)),this._clearGlobalListeners(),this.pointerMove.complete(),this.pointerUp.complete()}_clearGlobalListeners(){this._globalListeners.forEach((e,r)=>{this._document.removeEventListener(r,e.handler,e.options)}),this._globalListeners.clear()}}return n.\u0275fac=function(e){return new(e||n)(ee(Ct),ee(_t))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const fTe={dragStartThreshold:5,pointerDirectionChangeThreshold:5};let MI=(()=>{class n{constructor(e,r,s,i){this._document=e,this._ngZone=r,this._viewportRuler=s,this._dragDropRegistry=i}createDrag(e,r=fTe){return new lTe(e,r,this._document,this._ngZone,this._viewportRuler,this._dragDropRegistry)}createDropList(e){return new uTe(e,this._dragDropRegistry,this._document,this._ngZone,this._viewportRuler)}}return n.\u0275fac=function(e){return new(e||n)(ee(_t),ee(Ct),ee(Ih),ee(hTe))},n.\u0275prov=Ve({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Zz=new Fe("CDK_DRAG_PARENT"),Qz=new Fe("CdkDropListGroup"),Jz=new Fe("CDK_DRAG_CONFIG");let pTe=0;const eU=new Fe("CdkDropList");let mTe=(()=>{class n{constructor(e,r,s,i,o,a,l){this.element=e,this._changeDetectorRef=s,this._scrollDispatcher=i,this._dir=o,this._group=a,this._destroyed=new Ge,this.connectedTo=[],this.id="cdk-drop-list-"+pTe++,this.enterPredicate=()=>!0,this.sortPredicate=()=>!0,this.dropped=new Bt,this.entered=new Bt,this.exited=new Bt,this.sorted=new Bt,this._unsortedItems=new Set,this._dropListRef=r.createDropList(e),this._dropListRef.data=this,l&&this._assignDefaults(l),this._dropListRef.enterPredicate=(c,u)=>this.enterPredicate(c.data,u.data),this._dropListRef.sortPredicate=(c,u,d)=>this.sortPredicate(c,u.data,d.data),this._setupInputSyncSubscription(this._dropListRef),this._handleEvents(this._dropListRef),n._dropLists.push(this),a&&a._items.add(this)}get disabled(){return this._disabled||!!this._group&&this._group.disabled}set disabled(e){this._dropListRef.disabled=this._disabled=Rr(e)}addItem(e){this._unsortedItems.add(e),this._dropListRef.isDragging()&&this._syncItemsWithRef()}removeItem(e){this._unsortedItems.delete(e),this._dropListRef.isDragging()&&this._syncItemsWithRef()}getSortedItems(){return Array.from(this._unsortedItems).sort((e,r)=>e._dragRef.getVisibleElement().compareDocumentPosition(r._dragRef.getVisibleElement())&Node.DOCUMENT_POSITION_FOLLOWING?-1:1)}ngOnDestroy(){const e=n._dropLists.indexOf(this);e>-1&&n._dropLists.splice(e,1),this._group&&this._group._items.delete(this),this._unsortedItems.clear(),this._dropListRef.dispose(),this._destroyed.next(),this._destroyed.complete()}_setupInputSyncSubscription(e){this._dir&&this._dir.change.pipe(Uo(this._dir.value),dr(this._destroyed)).subscribe(r=>e.withDirection(r)),e.beforeStarted.subscribe(()=>{const r=rh(this.connectedTo).map(s=>"string"==typeof s?n._dropLists.find(o=>o.id===s):s);if(this._group&&this._group._items.forEach(s=>{-1===r.indexOf(s)&&r.push(s)}),!this._scrollableParentsResolved){const s=this._scrollDispatcher.getAncestorScrollContainers(this.element).map(i=>i.getElementRef().nativeElement);this._dropListRef.withScrollableParents(s),this._scrollableParentsResolved=!0}e.disabled=this.disabled,e.lockAxis=this.lockAxis,e.sortingDisabled=Rr(this.sortingDisabled),e.autoScrollDisabled=Rr(this.autoScrollDisabled),e.autoScrollStep=nh(this.autoScrollStep,2),e.connectedTo(r.filter(s=>s&&s!==this).map(s=>s._dropListRef)).withOrientation(this.orientation)})}_handleEvents(e){e.beforeStarted.subscribe(()=>{this._syncItemsWithRef(),this._changeDetectorRef.markForCheck()}),e.entered.subscribe(r=>{this.entered.emit({container:this,item:r.item.data,currentIndex:r.currentIndex})}),e.exited.subscribe(r=>{this.exited.emit({container:this,item:r.item.data}),this._changeDetectorRef.markForCheck()}),e.sorted.subscribe(r=>{this.sorted.emit({previousIndex:r.previousIndex,currentIndex:r.currentIndex,container:this,item:r.item.data})}),e.dropped.subscribe(r=>{this.dropped.emit({previousIndex:r.previousIndex,currentIndex:r.currentIndex,previousContainer:r.previousContainer.data,container:r.container.data,item:r.item.data,isPointerOverContainer:r.isPointerOverContainer,distance:r.distance,dropPoint:r.dropPoint}),this._changeDetectorRef.markForCheck()})}_assignDefaults(e){const{lockAxis:r,draggingDisabled:s,sortingDisabled:i,listAutoScrollDisabled:o,listOrientation:a}=e;this.disabled=null!=s&&s,this.sortingDisabled=null!=i&&i,this.autoScrollDisabled=null!=o&&o,this.orientation=a||"vertical",r&&(this.lockAxis=r)}_syncItemsWithRef(){this._dropListRef.withItems(this.getSortedItems().map(e=>e._dragRef))}}return n._dropLists=[],n.\u0275fac=function(e){return new(e||n)(oe(Cn),oe(MI),oe(oo),oe(Sh),oe(ya,8),oe(Qz,12),oe(Jz,8))},n.\u0275dir=un({type:n,selectors:[["","cdkDropList",""],["cdk-drop-list"]],hostAttrs:[1,"cdk-drop-list"],hostVars:7,hostBindings:function(e,r){2&e&&(no("id",r.id),ms("cdk-drop-list-disabled",r.disabled)("cdk-drop-list-dragging",r._dropListRef.isDragging())("cdk-drop-list-receiving",r._dropListRef.isReceiving()))},inputs:{connectedTo:["cdkDropListConnectedTo","connectedTo"],data:["cdkDropListData","data"],orientation:["cdkDropListOrientation","orientation"],id:"id",lockAxis:["cdkDropListLockAxis","lockAxis"],disabled:["cdkDropListDisabled","disabled"],sortingDisabled:["cdkDropListSortingDisabled","sortingDisabled"],enterPredicate:["cdkDropListEnterPredicate","enterPredicate"],sortPredicate:["cdkDropListSortPredicate","sortPredicate"],autoScrollDisabled:["cdkDropListAutoScrollDisabled","autoScrollDisabled"],autoScrollStep:["cdkDropListAutoScrollStep","autoScrollStep"]},outputs:{dropped:"cdkDropListDropped",entered:"cdkDropListEntered",exited:"cdkDropListExited",sorted:"cdkDropListSorted"},exportAs:["cdkDropList"],features:[pa([{provide:Qz,useValue:void 0},{provide:eU,useExisting:n}])]}),n})();const tU=new Fe("CdkDragHandle"),gTe=new Fe("CdkDragPlaceholder"),nU=new Fe("CdkDragPreview");let yTe=(()=>{class n{constructor(e){this.templateRef=e,this._matchSize=!1}get matchSize(){return this._matchSize}set matchSize(e){this._matchSize=Rr(e)}}return n.\u0275fac=function(e){return new(e||n)(oe(ei))},n.\u0275dir=un({type:n,selectors:[["ng-template","cdkDragPreview",""]],inputs:{data:"data",matchSize:"matchSize"},features:[pa([{provide:nU,useExisting:n}])]}),n})(),vTe=(()=>{class n{constructor(e,r,s,i,o,a,l,c,u,d,h){this.element=e,this.dropContainer=r,this._ngZone=i,this._viewContainerRef=o,this._dir=l,this._changeDetectorRef=u,this._selfHandle=d,this._parentDrag=h,this._destroyed=new Ge,this.started=new Bt,this.released=new Bt,this.ended=new Bt,this.entered=new Bt,this.exited=new Bt,this.dropped=new Bt,this.moved=new ct(f=>{const p=this._dragRef.moved.pipe(Et(m=>({source:this,pointerPosition:m.pointerPosition,event:m.event,delta:m.delta,distance:m.distance}))).subscribe(f);return()=>{p.unsubscribe()}}),this._dragRef=c.createDrag(e,{dragStartThreshold:a&&null!=a.dragStartThreshold?a.dragStartThreshold:5,pointerDirectionChangeThreshold:a&&null!=a.pointerDirectionChangeThreshold?a.pointerDirectionChangeThreshold:5,zIndex:null==a?void 0:a.zIndex}),this._dragRef.data=this,n._dragInstances.push(this),a&&this._assignDefaults(a),r&&(this._dragRef._withDropContainer(r._dropListRef),r.addItem(this)),this._syncInputs(this._dragRef),this._handleEvents(this._dragRef)}get disabled(){return this._disabled||this.dropContainer&&this.dropContainer.disabled}set disabled(e){this._disabled=Rr(e),this._dragRef.disabled=this._disabled}getPlaceholderElement(){return this._dragRef.getPlaceholderElement()}getRootElement(){return this._dragRef.getRootElement()}reset(){this._dragRef.reset()}getFreeDragPosition(){return this._dragRef.getFreeDragPosition()}ngAfterViewInit(){this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.pipe(Br(1),dr(this._destroyed)).subscribe(()=>{this._updateRootElement(),this._setupHandlesListener(),this.freeDragPosition&&this._dragRef.setFreeDragPosition(this.freeDragPosition)})})}ngOnChanges(e){const r=e.rootElementSelector,s=e.freeDragPosition;r&&!r.firstChange&&this._updateRootElement(),s&&!s.firstChange&&this.freeDragPosition&&this._dragRef.setFreeDragPosition(this.freeDragPosition)}ngOnDestroy(){this.dropContainer&&this.dropContainer.removeItem(this);const e=n._dragInstances.indexOf(this);e>-1&&n._dragInstances.splice(e,1),this._ngZone.runOutsideAngular(()=>{this._destroyed.next(),this._destroyed.complete(),this._dragRef.dispose()})}_updateRootElement(){var e;const r=this.element.nativeElement;let s=r;this.rootElementSelector&&(s=void 0!==r.closest?r.closest(this.rootElementSelector):null===(e=r.parentElement)||void 0===e?void 0:e.closest(this.rootElementSelector)),this._dragRef.withRootElement(s||r)}_getBoundaryElement(){const e=this.boundaryElement;return e?"string"==typeof e?this.element.nativeElement.closest(e):hr(e):null}_syncInputs(e){e.beforeStarted.subscribe(()=>{if(!e.isDragging()){const r=this._dir,s=this.dragStartDelay,i=this._placeholderTemplate?{template:this._placeholderTemplate.templateRef,context:this._placeholderTemplate.data,viewContainer:this._viewContainerRef}:null,o=this._previewTemplate?{template:this._previewTemplate.templateRef,context:this._previewTemplate.data,matchSize:this._previewTemplate.matchSize,viewContainer:this._viewContainerRef}:null;e.disabled=this.disabled,e.lockAxis=this.lockAxis,e.dragStartDelay="object"==typeof s&&s?s:nh(s),e.constrainPosition=this.constrainPosition,e.previewClass=this.previewClass,e.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(i).withPreviewTemplate(o).withPreviewContainer(this.previewContainer||"global"),r&&e.withDirection(r.value)}}),e.beforeStarted.pipe(Br(1)).subscribe(()=>{var r;if(this._parentDrag)return void e.withParent(this._parentDrag._dragRef);let s=this.element.nativeElement.parentElement;for(;s;){if(s.classList.contains("cdk-drag")){e.withParent((null===(r=n._dragInstances.find(i=>i.element.nativeElement===s))||void 0===r?void 0:r._dragRef)||null);break}s=s.parentElement}})}_handleEvents(e){e.started.subscribe(()=>{this.started.emit({source:this}),this._changeDetectorRef.markForCheck()}),e.released.subscribe(()=>{this.released.emit({source:this})}),e.ended.subscribe(r=>{this.ended.emit({source:this,distance:r.distance,dropPoint:r.dropPoint}),this._changeDetectorRef.markForCheck()}),e.entered.subscribe(r=>{this.entered.emit({container:r.container.data,item:this,currentIndex:r.currentIndex})}),e.exited.subscribe(r=>{this.exited.emit({container:r.container.data,item:this})}),e.dropped.subscribe(r=>{this.dropped.emit({previousIndex:r.previousIndex,currentIndex:r.currentIndex,previousContainer:r.previousContainer.data,container:r.container.data,isPointerOverContainer:r.isPointerOverContainer,item:this,distance:r.distance,dropPoint:r.dropPoint})})}_assignDefaults(e){const{lockAxis:r,dragStartDelay:s,constrainPosition:i,previewClass:o,boundaryElement:a,draggingDisabled:l,rootElementSelector:c,previewContainer:u}=e;this.disabled=null!=l&&l,this.dragStartDelay=s||0,r&&(this.lockAxis=r),i&&(this.constrainPosition=i),o&&(this.previewClass=o),a&&(this.boundaryElement=a),c&&(this.rootElementSelector=c),u&&(this.previewContainer=u)}_setupHandlesListener(){this._handles.changes.pipe(Uo(this._handles),Mr(e=>{const r=e.filter(s=>s._parentDrag===this).map(s=>s.element);this._selfHandle&&this.rootElementSelector&&r.push(this.element),this._dragRef.withHandles(r)}),wa(e=>id(...e.map(r=>r._stateChanges.pipe(Uo(r))))),dr(this._destroyed)).subscribe(e=>{const r=this._dragRef,s=e.element.nativeElement;e.disabled?r.disableHandle(s):r.enableHandle(s)})}}return n._dragInstances=[],n.\u0275fac=function(e){return new(e||n)(oe(Cn),oe(eU,12),oe(_t),oe(Ct),oe(Ms),oe(Jz,8),oe(ya,8),oe(MI),oe(oo),oe(tU,10),oe(Zz,12))},n.\u0275dir=un({type:n,selectors:[["","cdkDrag",""]],contentQueries:function(e,r,s){if(1&e&&(Po(s,nU,5),Po(s,gTe,5),Po(s,tU,5)),2&e){let i;rs(i=ss())&&(r._previewTemplate=i.first),rs(i=ss())&&(r._placeholderTemplate=i.first),rs(i=ss())&&(r._handles=i)}},hostAttrs:[1,"cdk-drag"],hostVars:4,hostBindings:function(e,r){2&e&&ms("cdk-drag-disabled",r.disabled)("cdk-drag-dragging",r._dragRef.isDragging())},inputs:{data:["cdkDragData","data"],lockAxis:["cdkDragLockAxis","lockAxis"],rootElementSelector:["cdkDragRootElement","rootElementSelector"],boundaryElement:["cdkDragBoundary","boundaryElement"],dragStartDelay:["cdkDragStartDelay","dragStartDelay"],freeDragPosition:["cdkDragFreeDragPosition","freeDragPosition"],disabled:["cdkDragDisabled","disabled"],constrainPosition:["cdkDragConstrainPosition","constrainPosition"],previewClass:["cdkDragPreviewClass","previewClass"],previewContainer:["cdkDragPreviewContainer","previewContainer"]},outputs:{started:"cdkDragStarted",released:"cdkDragReleased",ended:"cdkDragEnded",entered:"cdkDragEntered",exited:"cdkDragExited",dropped:"cdkDragDropped",moved:"cdkDragMoved"},exportAs:["cdkDrag"],features:[pa([{provide:Zz,useExisting:n}]),ko]}),n})(),bTe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n}),n.\u0275inj=Jt({providers:[MI],imports:[Th]}),n})();function xTe(n,t){1&n&&hn(0,"img",18),2&n&&Cr("src",ha().$implicit,Cc)}function wTe(n,t){if(1&n&&(Re(0,"div",17),hn(1,"img",18),Js(2,xTe,1,1,"img",19),Be()),2&n){const e=t.$implicit;Yn(1),Cr("src",e,Cc)}}function CTe(n,t){if(1&n&&(Re(0,"div"),hn(1,"img",20),Be()),2&n){const e=t.$implicit,r=t.index;Yn(1),Cr("id",r)("src",e,Cc)}}const rU=function(n){return[n]},DTe=function(){return{color:"white"}};let STe=(()=>{class n{constructor(e,r){this.dialog=e,this._snackBar=r,this.todo=[],this.HomeEvent=new Bt,this.photos=["../../assets/project1/cat.1.jpg","../../assets/project1/dog.1.jpg","../../assets/project1/cat.2.jpg","../../assets/project1/dog.2.jpg","../../assets/project1/cat.3.jpg","../../assets/project1/dog.3.jpg","../../assets/project1/cat.4.jpg","../../assets/project1/dog.4.jpg","../../assets/project1/cat.5.jpg","../../assets/project1/dog.5.jpg"]}ngOnInit(){this.loadModel()}loadModel(){var e=this;return he(function*(){e._snackBar.open("loading Model","WAIT"),e.model=yield function dde(n,t){return null==t&&(t={}),function lde(n,t){return kE.apply(this,arguments)}(n,t)}("../../assets/project1/model.json"),e._snackBar.open("Model load","OK",{duration:2e3})})()}openHome(){this.HomeEvent.emit(!0)}getfile(){document.getElementById("fileid").click()}openDialog(e){this.dialog.open(vee,{data:{probability:e}})}predict(e){var r=this;return he(function*(){te(()=>{let s=document.getElementById(e.toString()),i=Yte(s);i=Hf.resizeBilinear(i,[64,64]).div(lt(255)),i=i.reshape([1,64,64,3]),i=Ne(i,"float32");const o=r.model.predict(i);r.predictions=Array.from(o.dataSync()),r.openDialog(r.predictions[0])})})()}drop(e){e.previousContainer!==e.container&&(this.model?this.predict(e.previousIndex):this._snackBar.open("Model not load yet","OK",{duration:2e3}))}}return n.\u0275fac=function(e){return new(e||n)(oe(_P),oe(rTe))},n.\u0275cmp=Wn({type:n,selectors:[["app-project1"]],outputs:{HomeEvent:"HomeEvent"},decls:48,vars:12,consts:[[1,"container"],["itemSize","50",1,"example-viewport"],["cdkDropList","",1,"example-list",3,"cdkDropListData","cdkDropListConnectedTo","cdkDropListDropped"],["photoList","cdkDropList"],[1,"color"],["class","example-box","cdkDrag","",4,"ngFor","ngForOf"],[1,"container-upload"],["cdkDropList","",1,"upload",3,"cdkDropListData","cdkDropListConnectedTo","cdkDropListDropped"],["todoList","cdkDropList"],[1,"container-icon"],[1,"button",3,"click"],[1,"icon-display",3,"ngStyle"],["id","fileid","type","file","hidden",""],[1,"presentation"],[1,"element"],[1,"button","back",3,"click"],[4,"ngFor","ngForOf"],["cdkDrag","",1,"example-box"],[1,"example-img",3,"src"],["class","example-img",3,"src",4,"cdkDragPreview"],["width","64px","height","64px","hidden","",3,"id","src"]],template:function(e,r){if(1&e&&(Re(0,"div",0)(1,"cdk-virtual-scroll-viewport",1)(2,"div",2,3),Dr("cdkDropListDropped",function(i){return r.drop(i)}),Re(4,"h3",4),nt(5,"Some examples: "),Be(),Js(6,wTe,3,1,"div",5),Be()(),Re(7,"div",6)(8,"div",7,8),Dr("cdkDropListDropped",function(i){return r.drop(i)}),Re(10,"h3",4),nt(11,"Make a Prediction "),Be(),Re(12,"div",9)(13,"button",10),Dr("click",function(){return r.getfile()}),Re(14,"mat-icon",11),nt(15,"get_app"),Be()(),Re(16,"p"),nt(17," Drag and Drop a given example "),Be()(),hn(18,"input",12),Be(),Re(19,"div",13)(20,"h3",4),nt(21,"Presentation of the Project"),Be(),Re(22,"div",14)(23,"p")(24,"mat-icon",4),nt(25,"arrow_forward"),Be(),nt(26," Goal : recognize dogs and cats in images "),Be(),Re(27,"p")(28,"mat-icon",4),nt(29,"arrow_forward"),Be(),nt(30," Training : 2000 image 64*64 for training the model "),Be(),Re(31,"p")(32,"mat-icon",4),nt(33,"arrow_forward"),Be(),nt(34," Transfer learning : VGG-16 trained on imageNet "),Be(),Re(35,"p")(36,"mat-icon",4),nt(37,"arrow_forward"),Be(),nt(38," Fine-tuning : VGG-16 trained with Adam and a small learning rate "),Be(),Re(39,"p")(40,"mat-icon",4),nt(41,"arrow_forward"),Be(),nt(42," Validation : 90% accuracy on the validation set "),Be()()(),Re(43,"button",15),Dr("click",function(){return r.openHome()}),Re(44,"mat-icon"),nt(45,"arrow_backward"),Be()()()(),Re(46,"div"),Js(47,CTe,2,2,"div",16),Be()),2&e){const s=ll(3),i=ll(9);Yn(2),Cr("cdkDropListData",r.photos)("cdkDropListConnectedTo",B0(7,rU,i)),Yn(4),Cr("ngForOf",r.photos),Yn(2),Cr("cdkDropListData",r.todo)("cdkDropListConnectedTo",B0(9,rU,s)),Yn(6),Cr("ngStyle",function MA(n,t,e){const r=Jr()+n,s=ye();return s[r]===mt?to(s,r,e?t.call(e):t()):function Md(n,t){return n[t]}(s,r)}(11,DTe)),Yn(33),Cr("ngForOf",r.photos)}},directives:[kJ,DJ,mTe,WR,vTe,yTe,M9,XR],styles:[".example-viewport[_ngcontent-%COMP%]{height:100%;width:280px}.container[_ngcontent-%COMP%]{height:100%;width:100%;display:flex;flex-direction:row-reverse;justify-content:end}.example-img[_ngcontent-%COMP%]{border-radius:10%;padding:10px;width:180px;height:180px}.upload[_ngcontent-%COMP%]{width:100%;height:100%}.icon-display[_ngcontent-%COMP%]{transform:scale(2.5);border-radius:5px;padding:30px 60px;border:1px solid white}.container-upload[_ngcontent-%COMP%]{display:flex;flex-direction:row-reverse;justify-content:space-between;width:100%;height:80%}.container-icon[_ngcontent-%COMP%]{display:flex;align-items:center;height:100%;width:100%;justify-content:center;flex-direction:column}.presentation[_ngcontent-%COMP%]{display:flex;flex-direction:column;width:100%;height:100%;white-space:normal}h3[_ngcontent-%COMP%]{margin-top:20px;font-size:1.3em;display:flex;align-items:center;justify-content:center;font-weight:700}p[_ngcontent-%COMP%]{display:flex;align-items:center;flex-direction:row;font-size:1.1em}.element[_ngcontent-%COMP%]{margin-left:10px;display:flex;justify-content:space-evenly;flex-direction:column;width:100%;height:100%;margin-bottom:10%}.button[_ngcontent-%COMP%]{border:none;background-color:transparent}.back[_ngcontent-%COMP%]{display:flex;align-items:top;justify-content:top;color:#fff}"],changeDetection:0}),n})();function ETe(n,t){if(1&n){const e=Uc();Re(0,"div",6)(1,"app-home",7),Dr("ClassifEvent",function(){return No(e),ha().affichage(2)}),Be()()}}function ITe(n,t){1&n&&(Re(0,"div",6),hn(1,"app-cv"),Be())}function TTe(n,t){if(1&n){const e=Uc();Re(0,"div",6)(1,"app-project1",8),Dr("HomeEvent",function(){return No(e),ha().affichage(0)}),Be()()}}let kTe=(()=>{class n{constructor(){this.hasBackdrop=!0,this.section=0}ngOnInit(){}affichage(e){this.section=e}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Wn({type:n,selectors:[["app-main"]],decls:20,vars:4,consts:[[3,"OpenEvent"],[1,"container",3,"hasBackdrop"],["drawer",""],[1,"conc-button"],["mat-button","",1,"button",3,"click"],["class","section",4,"ngIf"],[1,"section"],[3,"ClassifEvent"],[3,"HomeEvent"]],template:function(e,r){if(1&e){const s=Uc();Re(0,"app-header",0),Dr("OpenEvent",function(){return No(s),ll(3).toggle()}),Be(),Re(1,"mat-drawer-container",1)(2,"mat-drawer",null,2)(4,"div",3)(5,"button",4),Dr("click",function(){No(s);const o=ll(3);return r.affichage(0),o.close()}),nt(6,"Home"),Be()(),hn(7,"mat-divider"),Re(8,"div",3)(9,"button",4),Dr("click",function(){No(s);const o=ll(3);return r.affichage(1),o.close()}),nt(10,"CV"),Be()(),hn(11,"mat-divider"),Re(12,"div",3)(13,"button",4),Dr("click",function(){No(s);const o=ll(3);return r.affichage(2),o.close()}),nt(14,"Binary Classification"),Be()(),hn(15,"mat-divider"),Be(),Re(16,"mat-drawer-content"),Js(17,ETe,2,0,"div",5),Js(18,ITe,2,0,"div",5),Js(19,TTe,2,0,"div",5),Be()()}2&e&&(Yn(1),Cr("hasBackdrop",r.hasBackdrop),Yn(16),Cr("ngIf",0===r.section),Yn(1),Cr("ngIf",1===r.section),Yn(1),Cr("ngIf",2===r.section))},directives:[eJ,sP,rP,VJ,Ug,jm,zJ,UJ,STe],styles:[".container[_ngcontent-%COMP%]{width:auto;height:100%}mat-drawer-content[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:flex-start}.example-label[_ngcontent-%COMP%]{display:table-cell;font-size:14px;margin-left:8px;min-width:120px}.example-button-row[_ngcontent-%COMP%]{display:table-cell;width:490px}.button[_ngcontent-%COMP%]{background-color:transparent;color:#fff;border:0;transition-duration:.4s;width:100%;font-size:1.2em;padding:15px 7px}.button[_ngcontent-%COMP%]:hover{background-color:#323232;color:#fff}.section[_ngcontent-%COMP%]{height:100%;width:100%}"]}),n})(),NTe=(()=>{class n{constructor(){this.title="portfolio"}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Wn({type:n,selectors:[["app-root"]],decls:1,vars:0,template:function(e,r){1&e&&hn(0,"app-main")},directives:[kTe],styles:[""]}),n})(),ATe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=sn({type:n,bootstrap:[NTe]}),n.\u0275inj=Jt({providers:[],imports:[[cM,GQ,s9,O9,LJ,jw,JQ,BJ,bTe,Xw,VY,_ee,Mz]]}),n})();(function O8(){xR=!1})(),YK().bootstrapModule(ATe).catch(n=>console.error(n))},537:(Ce,Te,U)=>{var fe=U(123),ht=U(786),se=U(516),tt=U(868),de=U(902),xe=U(576),pe=U(390);pe.alea=fe,pe.xor128=ht,pe.xorwow=se,pe.xorshift7=tt,pe.xor4096=de,pe.tychei=xe,Ce.exports=pe},123:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(x){var N=this,F=function B(){var x=4022871197;return function(F){F=F.toString();for(var D=0;D<F.length;D++){var I=.02519603282416938*(x+=F.charCodeAt(D));I-=x=I>>>0,x=(I*=x)>>>0,x+=4294967296*(I-=x)}return 2.3283064365386963e-10*(x>>>0)}}();N.next=function(){var D=2091639*N.s0+2.3283064365386963e-10*N.c;return N.s0=N.s1,N.s1=N.s2,N.s2=D-(N.c=0|D)},N.c=1,N.s0=F(" "),N.s1=F(" "),N.s2=F(" "),N.s0-=F(x),N.s0<0&&(N.s0+=1),N.s1-=F(x),N.s1<0&&(N.s1+=1),N.s2-=F(x),N.s2<0&&(N.s2+=1),F=null}function xe(x,N){return N.c=x.c,N.s0=x.s0,N.s1=x.s1,N.s2=x.s2,N}function pe(x,N){var F=new de(x),D=N&&N.state,I=F.next;return I.int32=function(){return 4294967296*F.next()|0},I.double=function(){return I()+11102230246251565e-32*(2097152*I()|0)},I.quick=I,D&&("object"==typeof D&&xe(D,F),I.state=function(){return xe(F,{})}),I}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.alea=pe}(0,Ce=U.nmd(Ce))},576:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this,N="";x.next=function(){var D=x.b,I=x.c,H=x.d,q=x.a;return D=D<<25^D>>>7^I,I=I-H|0,H=H<<24^H>>>8^q,q=q-D|0,x.b=D=D<<20^D>>>12^I,x.c=I=I-H|0,x.d=H<<16^I>>>16^q,x.a=q-D|0},x.a=0,x.b=0,x.c=-1640531527,x.d=1367130551,B===Math.floor(B)?(x.a=B/4294967296|0,x.b=0|B):N+=B;for(var F=0;F<N.length+20;F++)x.b^=0|N.charCodeAt(F),x.next()}function xe(B,x){return x.a=B.a,x.b=B.b,x.c=B.c,x.d=B.d,x}function pe(B,x){var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&("object"==typeof F&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.tychei=pe}(0,Ce=U.nmd(Ce))},786:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this,N="";x.x=0,x.y=0,x.z=0,x.w=0,x.next=function(){var D=x.x^x.x<<11;return x.x=x.y,x.y=x.z,x.z=x.w,x.w^=x.w>>>19^D^D>>>8},B===(0|B)?x.x=B:N+=B;for(var F=0;F<N.length+64;F++)x.x^=0|N.charCodeAt(F),x.next()}function xe(B,x){return x.x=B.x,x.y=B.y,x.z=B.z,x.w=B.w,x}function pe(B,x){var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&("object"==typeof F&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.xor128=pe}(0,Ce=U.nmd(Ce))},902:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this;x.next=function(){var H,q,F=x.w,D=x.X,I=x.i;return x.w=F=F+1640531527|0,q=D[I+34&127],H=D[I=I+1&127],q^=q<<13,H^=H<<17,q=D[I]=(q^=q>>>15)^(H^=H>>>12),x.i=I,q+(F^F>>>16)|0},function N(F,D){var I,H,q,Ye,Rt,bt=[],On=128;for(D===(0|D)?(H=D,D=null):(D+="\0",H=0,On=Math.max(On,D.length)),q=0,Ye=-32;Ye<On;++Ye)D&&(H^=D.charCodeAt((Ye+32)%D.length)),0===Ye&&(Rt=H),H^=H<<10,H^=H>>>15,H^=H<<4,H^=H>>>13,Ye>=0&&(q=0==(I=bt[127&Ye]^=H+(Rt=Rt+1640531527|0))?q+1:0);for(q>=128&&(bt[127&(D&&D.length||0)]=-1),q=127,Ye=512;Ye>0;--Ye)H=bt[q+34&127],I=bt[q=q+1&127],H^=H<<13,I^=I<<17,bt[q]=(H^=H>>>15)^(I^=I>>>12);F.w=Rt,F.X=bt,F.i=q}(x,B)}function xe(B,x){return x.i=B.i,x.w=B.w,x.X=B.X.slice(),x}function pe(B,x){null==B&&(B=+new Date);var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&(F.X&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.xor4096=pe}(0,Ce=U.nmd(Ce))},868:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this;x.next=function(){var I,H,F=x.x,D=x.i;return I=F[D],H=(I^=I>>>7)^I<<24,H^=(I=F[D+1&7])^I>>>10,H^=(I=F[D+3&7])^I>>>3,H^=(I=F[D+4&7])^I<<7,I=F[D+7&7],F[D]=H^=(I^=I<<13)^I<<9,x.i=D+1&7,H},function N(F,D){var I,q=[];if(D===(0|D))q[0]=D;else for(D=""+D,I=0;I<D.length;++I)q[7&I]=q[7&I]<<15^D.charCodeAt(I)+q[I+1&7]<<13;for(;q.length<8;)q.push(0);for(I=0;I<8&&0===q[I];++I);for(8==I&&(q[7]=-1),F.x=q,F.i=0,I=256;I>0;--I)F.next()}(x,B)}function xe(B,x){return x.x=B.x.slice(),x.i=B.i,x}function pe(B,x){null==B&&(B=+new Date);var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&(F.x&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.xorshift7=pe}(0,Ce=U.nmd(Ce))},516:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this,N="";x.next=function(){var D=x.x^x.x>>>2;return x.x=x.y,x.y=x.z,x.z=x.w,x.w=x.v,(x.d=x.d+362437|0)+(x.v=x.v^x.v<<4^D^D<<1)|0},x.x=0,x.y=0,x.z=0,x.w=0,x.v=0,B===(0|B)?x.x=B:N+=B;for(var F=0;F<N.length+64;F++)x.x^=0|N.charCodeAt(F),F==N.length&&(x.d=x.x<<10^x.x>>>4),x.next()}function xe(B,x){return x.x=B.x,x.y=B.y,x.z=B.z,x.w=B.w,x.v=B.v,x.d=B.d,x}function pe(B,x){var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&("object"==typeof F&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.xorwow=pe}(0,Ce=U.nmd(Ce))},390:(Ce,Te,U)=>{var fe;!function(ht,se){var I,tt=this,de=256,B="random",x=se.pow(de,6),N=se.pow(2,52),F=2*N,D=255;function H(_e,Ee,We){var ie=[],Y=bt(Rt((Ee=1==Ee?{entropy:!0}:Ee||{}).entropy?[_e,mn(ht)]:null==_e?function On(){try{var _e;return I&&(_e=I.randomBytes)?_e=_e(de):(_e=new Uint8Array(de),(tt.crypto||tt.msCrypto).getRandomValues(_e)),mn(_e)}catch(ie){var Ee=tt.navigator,We=Ee&&Ee.plugins;return[+new Date,tt,We,tt.screen,mn(ht)]}}():_e,3),ie),R=new q(ie),ve=function(){for(var ke=R.g(6),Qe=x,Xe=0;ke<N;)ke=(ke+Xe)*de,Qe*=de,Xe=R.g(1);for(;ke>=F;)ke/=2,Qe/=2,Xe>>>=1;return(ke+Xe)/Qe};return ve.int32=function(){return 0|R.g(4)},ve.quick=function(){return R.g(4)/4294967296},ve.double=ve,bt(mn(R.S),ht),(Ee.pass||We||function(ke,Qe,Xe,st){return st&&(st.S&&Ye(st,R),ke.state=function(){return Ye(R,{})}),Xe?(se[B]=ke,Qe):ke})(ve,Y,"global"in Ee?Ee.global:this==se,Ee.state)}function q(_e){var Ee,We=_e.length,ie=this,Y=0,R=ie.i=ie.j=0,ve=ie.S=[];for(We||(_e=[We++]);Y<de;)ve[Y]=Y++;for(Y=0;Y<de;Y++)ve[Y]=ve[R=D&R+_e[Y%We]+(Ee=ve[Y])],ve[R]=Ee;(ie.g=function(ke){for(var Qe,Xe=0,st=ie.i,jt=ie.j,Lt=ie.S;ke--;)Qe=Lt[st=D&st+1],Xe=Xe*de+Lt[D&(Lt[st]=Lt[jt=D&jt+Qe])+(Lt[jt]=Qe)];return ie.i=st,ie.j=jt,Xe})(de)}function Ye(_e,Ee){return Ee.i=_e.i,Ee.j=_e.j,Ee.S=_e.S.slice(),Ee}function Rt(_e,Ee){var Y,We=[],ie=typeof _e;if(Ee&&"object"==ie)for(Y in _e)try{We.push(Rt(_e[Y],Ee-1))}catch(R){}return We.length?We:"string"==ie?_e:_e+"\0"}function bt(_e,Ee){for(var ie,We=_e+"",Y=0;Y<We.length;)Ee[D&Y]=D&(ie^=19*Ee[D&Y])+We.charCodeAt(Y++);return mn(Ee)}function mn(_e){return String.fromCharCode.apply(0,_e)}if(se["seed"+B]=H,bt(se.random(),ht),Ce.exports){Ce.exports=H;try{I=U(914)}catch(_e){}}else void 0!==(fe=function(){return H}.call(Te,U,Te,Ce))&&(Ce.exports=fe)}([],Math)},349:(Ce,Te,U)=>{var fe=U(300),ht=U(650),se=U(100),tt=U(69),de=U(120),xe=U(703),pe=U(97);pe.alea=fe,pe.xor128=ht,pe.xorwow=se,pe.xorshift7=tt,pe.xor4096=de,pe.tychei=xe,Ce.exports=pe},300:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(x){var N=this,F=function B(){var x=4022871197;return function(F){F=F.toString();for(var D=0;D<F.length;D++){var I=.02519603282416938*(x+=F.charCodeAt(D));I-=x=I>>>0,x=(I*=x)>>>0,x+=4294967296*(I-=x)}return 2.3283064365386963e-10*(x>>>0)}}();N.next=function(){var D=2091639*N.s0+2.3283064365386963e-10*N.c;return N.s0=N.s1,N.s1=N.s2,N.s2=D-(N.c=0|D)},N.c=1,N.s0=F(" "),N.s1=F(" "),N.s2=F(" "),N.s0-=F(x),N.s0<0&&(N.s0+=1),N.s1-=F(x),N.s1<0&&(N.s1+=1),N.s2-=F(x),N.s2<0&&(N.s2+=1),F=null}function xe(x,N){return N.c=x.c,N.s0=x.s0,N.s1=x.s1,N.s2=x.s2,N}function pe(x,N){var F=new de(x),D=N&&N.state,I=F.next;return I.int32=function(){return 4294967296*F.next()|0},I.double=function(){return I()+11102230246251565e-32*(2097152*I()|0)},I.quick=I,D&&("object"==typeof D&&xe(D,F),I.state=function(){return xe(F,{})}),I}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.alea=pe}(0,Ce=U.nmd(Ce))},703:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this,N="";x.next=function(){var D=x.b,I=x.c,H=x.d,q=x.a;return D=D<<25^D>>>7^I,I=I-H|0,H=H<<24^H>>>8^q,q=q-D|0,x.b=D=D<<20^D>>>12^I,x.c=I=I-H|0,x.d=H<<16^I>>>16^q,x.a=q-D|0},x.a=0,x.b=0,x.c=-1640531527,x.d=1367130551,B===Math.floor(B)?(x.a=B/4294967296|0,x.b=0|B):N+=B;for(var F=0;F<N.length+20;F++)x.b^=0|N.charCodeAt(F),x.next()}function xe(B,x){return x.a=B.a,x.b=B.b,x.c=B.c,x.d=B.d,x}function pe(B,x){var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&("object"==typeof F&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.tychei=pe}(0,Ce=U.nmd(Ce))},650:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this,N="";x.x=0,x.y=0,x.z=0,x.w=0,x.next=function(){var D=x.x^x.x<<11;return x.x=x.y,x.y=x.z,x.z=x.w,x.w^=x.w>>>19^D^D>>>8},B===(0|B)?x.x=B:N+=B;for(var F=0;F<N.length+64;F++)x.x^=0|N.charCodeAt(F),x.next()}function xe(B,x){return x.x=B.x,x.y=B.y,x.z=B.z,x.w=B.w,x}function pe(B,x){var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&("object"==typeof F&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.xor128=pe}(0,Ce=U.nmd(Ce))},120:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this;x.next=function(){var H,q,F=x.w,D=x.X,I=x.i;return x.w=F=F+1640531527|0,q=D[I+34&127],H=D[I=I+1&127],q^=q<<13,H^=H<<17,q=D[I]=(q^=q>>>15)^(H^=H>>>12),x.i=I,q+(F^F>>>16)|0},function N(F,D){var I,H,q,Ye,Rt,bt=[],On=128;for(D===(0|D)?(H=D,D=null):(D+="\0",H=0,On=Math.max(On,D.length)),q=0,Ye=-32;Ye<On;++Ye)D&&(H^=D.charCodeAt((Ye+32)%D.length)),0===Ye&&(Rt=H),H^=H<<10,H^=H>>>15,H^=H<<4,H^=H>>>13,Ye>=0&&(q=0==(I=bt[127&Ye]^=H+(Rt=Rt+1640531527|0))?q+1:0);for(q>=128&&(bt[127&(D&&D.length||0)]=-1),q=127,Ye=512;Ye>0;--Ye)H=bt[q+34&127],I=bt[q=q+1&127],H^=H<<13,I^=I<<17,bt[q]=(H^=H>>>15)^(I^=I>>>12);F.w=Rt,F.X=bt,F.i=q}(x,B)}function xe(B,x){return x.i=B.i,x.w=B.w,x.X=B.X.slice(),x}function pe(B,x){null==B&&(B=+new Date);var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&(F.X&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.xor4096=pe}(0,Ce=U.nmd(Ce))},69:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this;x.next=function(){var I,H,F=x.x,D=x.i;return I=F[D],H=(I^=I>>>7)^I<<24,H^=(I=F[D+1&7])^I>>>10,H^=(I=F[D+3&7])^I>>>3,H^=(I=F[D+4&7])^I<<7,I=F[D+7&7],F[D]=H^=(I^=I<<13)^I<<9,x.i=D+1&7,H},function N(F,D){var I,q=[];if(D===(0|D))q[0]=D;else for(D=""+D,I=0;I<D.length;++I)q[7&I]=q[7&I]<<15^D.charCodeAt(I)+q[I+1&7]<<13;for(;q.length<8;)q.push(0);for(I=0;I<8&&0===q[I];++I);for(8==I&&(q[7]=-1),F.x=q,F.i=0,I=256;I>0;--I)F.next()}(x,B)}function xe(B,x){return x.x=B.x.slice(),x.i=B.i,x}function pe(B,x){null==B&&(B=+new Date);var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&(F.x&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.xorshift7=pe}(0,Ce=U.nmd(Ce))},100:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this,N="";x.next=function(){var D=x.x^x.x>>>2;return x.x=x.y,x.y=x.z,x.z=x.w,x.w=x.v,(x.d=x.d+362437|0)+(x.v=x.v^x.v<<4^D^D<<1)|0},x.x=0,x.y=0,x.z=0,x.w=0,x.v=0,B===(0|B)?x.x=B:N+=B;for(var F=0;F<N.length+64;F++)x.x^=0|N.charCodeAt(F),F==N.length&&(x.d=x.x<<10^x.x>>>4),x.next()}function xe(B,x){return x.x=B.x,x.y=B.y,x.z=B.z,x.w=B.w,x.v=B.v,x.d=B.d,x}function pe(B,x){var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&("object"==typeof F&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.xorwow=pe}(0,Ce=U.nmd(Ce))},97:(Ce,Te,U)=>{var fe;!function(ht,se){var I,tt=this,de=256,B="random",x=se.pow(de,6),N=se.pow(2,52),F=2*N,D=255;function H(_e,Ee,We){var ie=[],Y=bt(Rt((Ee=1==Ee?{entropy:!0}:Ee||{}).entropy?[_e,mn(ht)]:null==_e?function On(){try{var _e;return I&&(_e=I.randomBytes)?_e=_e(de):(_e=new Uint8Array(de),(tt.crypto||tt.msCrypto).getRandomValues(_e)),mn(_e)}catch(ie){var Ee=tt.navigator,We=Ee&&Ee.plugins;return[+new Date,tt,We,tt.screen,mn(ht)]}}():_e,3),ie),R=new q(ie),ve=function(){for(var ke=R.g(6),Qe=x,Xe=0;ke<N;)ke=(ke+Xe)*de,Qe*=de,Xe=R.g(1);for(;ke>=F;)ke/=2,Qe/=2,Xe>>>=1;return(ke+Xe)/Qe};return ve.int32=function(){return 0|R.g(4)},ve.quick=function(){return R.g(4)/4294967296},ve.double=ve,bt(mn(R.S),ht),(Ee.pass||We||function(ke,Qe,Xe,st){return st&&(st.S&&Ye(st,R),ke.state=function(){return Ye(R,{})}),Xe?(se[B]=ke,Qe):ke})(ve,Y,"global"in Ee?Ee.global:this==se,Ee.state)}function q(_e){var Ee,We=_e.length,ie=this,Y=0,R=ie.i=ie.j=0,ve=ie.S=[];for(We||(_e=[We++]);Y<de;)ve[Y]=Y++;for(Y=0;Y<de;Y++)ve[Y]=ve[R=D&R+_e[Y%We]+(Ee=ve[Y])],ve[R]=Ee;(ie.g=function(ke){for(var Qe,Xe=0,st=ie.i,jt=ie.j,Lt=ie.S;ke--;)Qe=Lt[st=D&st+1],Xe=Xe*de+Lt[D&(Lt[st]=Lt[jt=D&jt+Qe])+(Lt[jt]=Qe)];return ie.i=st,ie.j=jt,Xe})(de)}function Ye(_e,Ee){return Ee.i=_e.i,Ee.j=_e.j,Ee.S=_e.S.slice(),Ee}function Rt(_e,Ee){var Y,We=[],ie=typeof _e;if(Ee&&"object"==ie)for(Y in _e)try{We.push(Rt(_e[Y],Ee-1))}catch(R){}return We.length?We:"string"==ie?_e:_e+"\0"}function bt(_e,Ee){for(var ie,We=_e+"",Y=0;Y<We.length;)Ee[D&Y]=D&(ie^=19*Ee[D&Y])+We.charCodeAt(Y++);return mn(Ee)}function mn(_e){return String.fromCharCode.apply(0,_e)}if(se["seed"+B]=H,bt(se.random(),ht),Ce.exports){Ce.exports=H;try{I=U(778)}catch(_e){}}else void 0!==(fe=function(){return H}.call(Te,U,Te,Ce))&&(Ce.exports=fe)}([],Math)},658:Ce=>{Ce.exports=U;var Te=null;try{Te=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(Y){}function U(Y,R,ve){this.low=0|Y,this.high=0|R,this.unsigned=!!ve}function fe(Y){return!0===(Y&&Y.__isLong__)}Object.defineProperty(U.prototype,"__isLong__",{value:!0}),U.isLong=fe;var ht={},se={};function tt(Y,R){var ve,ke,Qe;return R?(Qe=0<=(Y>>>=0)&&Y<256)&&(ke=se[Y])?ke:(ve=xe(Y,(0|Y)<0?-1:0,!0),Qe&&(se[Y]=ve),ve):(Qe=-128<=(Y|=0)&&Y<128)&&(ke=ht[Y])?ke:(ve=xe(Y,Y<0?-1:0,!1),Qe&&(ht[Y]=ve),ve)}function de(Y,R){if(isNaN(Y))return R?Rt:Ye;if(R){if(Y<0)return Rt;if(Y>=I)return Ee}else{if(Y<=-H)return We;if(Y+1>=H)return _e}return Y<0?de(-Y,R).neg():xe(Y%D|0,Y/D|0,R)}function xe(Y,R,ve){return new U(Y,R,ve)}U.fromInt=tt,U.fromNumber=de,U.fromBits=xe;var pe=Math.pow;function B(Y,R,ve){if(0===Y.length)throw Error("empty string");if("NaN"===Y||"Infinity"===Y||"+Infinity"===Y||"-Infinity"===Y)return Ye;if("number"==typeof R?(ve=R,R=!1):R=!!R,(ve=ve||10)<2||36<ve)throw RangeError("radix");var ke;if((ke=Y.indexOf("-"))>0)throw Error("interior hyphen");if(0===ke)return B(Y.substring(1),R,ve).neg();for(var Qe=de(pe(ve,8)),Xe=Ye,st=0;st<Y.length;st+=8){var jt=Math.min(8,Y.length-st),Lt=parseInt(Y.substring(st,st+jt),ve);if(jt<8){var gn=de(pe(ve,jt));Xe=Xe.mul(gn).add(de(Lt))}else Xe=(Xe=Xe.mul(Qe)).add(de(Lt))}return Xe.unsigned=R,Xe}function x(Y,R){return"number"==typeof Y?de(Y,R):"string"==typeof Y?B(Y,R):xe(Y.low,Y.high,"boolean"==typeof R?R:Y.unsigned)}U.fromString=B,U.fromValue=x;var D=4294967296,I=D*D,H=I/2,q=tt(1<<24),Ye=tt(0);U.ZERO=Ye;var Rt=tt(0,!0);U.UZERO=Rt;var bt=tt(1);U.ONE=bt;var On=tt(1,!0);U.UONE=On;var mn=tt(-1);U.NEG_ONE=mn;var _e=xe(-1,2147483647,!1);U.MAX_VALUE=_e;var Ee=xe(-1,-1,!0);U.MAX_UNSIGNED_VALUE=Ee;var We=xe(0,-2147483648,!1);U.MIN_VALUE=We;var ie=U.prototype;ie.toInt=function(){return this.unsigned?this.low>>>0:this.low},ie.toNumber=function(){return this.unsigned?(this.high>>>0)*D+(this.low>>>0):this.high*D+(this.low>>>0)},ie.toString=function(R){if((R=R||10)<2||36<R)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(We)){var ve=de(R),ke=this.div(ve),Qe=ke.mul(ve).sub(this);return ke.toString(R)+Qe.toInt().toString(R)}return"-"+this.neg().toString(R)}for(var Xe=de(pe(R,6),this.unsigned),st=this,jt="";;){var Lt=st.div(Xe),Hn=(st.sub(Lt.mul(Xe)).toInt()>>>0).toString(R);if((st=Lt).isZero())return Hn+jt;for(;Hn.length<6;)Hn="0"+Hn;jt=""+Hn+jt}},ie.getHighBits=function(){return this.high},ie.getHighBitsUnsigned=function(){return this.high>>>0},ie.getLowBits=function(){return this.low},ie.getLowBitsUnsigned=function(){return this.low>>>0},ie.getNumBitsAbs=function(){if(this.isNegative())return this.eq(We)?64:this.neg().getNumBitsAbs();for(var R=0!=this.high?this.high:this.low,ve=31;ve>0&&0==(R&1<<ve);ve--);return 0!=this.high?ve+33:ve+1},ie.isZero=function(){return 0===this.high&&0===this.low},ie.eqz=ie.isZero,ie.isNegative=function(){return!this.unsigned&&this.high<0},ie.isPositive=function(){return this.unsigned||this.high>=0},ie.isOdd=function(){return 1==(1&this.low)},ie.isEven=function(){return 0==(1&this.low)},ie.equals=function(R){return fe(R)||(R=x(R)),(this.unsigned===R.unsigned||this.high>>>31!=1||R.high>>>31!=1)&&this.high===R.high&&this.low===R.low},ie.eq=ie.equals,ie.notEquals=function(R){return!this.eq(R)},ie.neq=ie.notEquals,ie.ne=ie.notEquals,ie.lessThan=function(R){return this.comp(R)<0},ie.lt=ie.lessThan,ie.lessThanOrEqual=function(R){return this.comp(R)<=0},ie.lte=ie.lessThanOrEqual,ie.le=ie.lessThanOrEqual,ie.greaterThan=function(R){return this.comp(R)>0},ie.gt=ie.greaterThan,ie.greaterThanOrEqual=function(R){return this.comp(R)>=0},ie.gte=ie.greaterThanOrEqual,ie.ge=ie.greaterThanOrEqual,ie.compare=function(R){if(fe(R)||(R=x(R)),this.eq(R))return 0;var ve=this.isNegative(),ke=R.isNegative();return ve&&!ke?-1:!ve&&ke?1:this.unsigned?R.high>>>0>this.high>>>0||R.high===this.high&&R.low>>>0>this.low>>>0?-1:1:this.sub(R).isNegative()?-1:1},ie.comp=ie.compare,ie.negate=function(){return!this.unsigned&&this.eq(We)?We:this.not().add(bt)},ie.neg=ie.negate,ie.add=function(R){fe(R)||(R=x(R));var Hn=0,Zr=0,ct=0,Vr=0;return ct+=(Vr+=(65535&this.low)+(65535&R.low))>>>16,Zr+=(ct+=(this.low>>>16)+(R.low>>>16))>>>16,Hn+=(Zr+=(65535&this.high)+(65535&R.high))>>>16,Hn+=(this.high>>>16)+(R.high>>>16),xe((ct&=65535)<<16|(Vr&=65535),(Hn&=65535)<<16|(Zr&=65535),this.unsigned)},ie.subtract=function(R){return fe(R)||(R=x(R)),this.add(R.neg())},ie.sub=ie.subtract,ie.multiply=function(R){if(this.isZero())return Ye;if(fe(R)||(R=x(R)),Te)return xe(Te.mul(this.low,this.high,R.low,R.high),Te.get_high(),this.unsigned);if(R.isZero())return Ye;if(this.eq(We))return R.isOdd()?We:Ye;if(R.eq(We))return this.isOdd()?We:Ye;if(this.isNegative())return R.isNegative()?this.neg().mul(R.neg()):this.neg().mul(R).neg();if(R.isNegative())return this.mul(R.neg()).neg();if(this.lt(q)&&R.lt(q))return de(this.toNumber()*R.toNumber(),this.unsigned);var Qe=65535&this.high,Xe=this.low>>>16,st=65535&this.low,Lt=65535&R.high,gn=R.low>>>16,Hn=65535&R.low,Zr=0,ct=0,Vr=0,rc=0;return Vr+=(rc+=st*Hn)>>>16,ct+=(Vr+=Xe*Hn)>>>16,Vr&=65535,ct+=(Vr+=st*gn)>>>16,Zr+=(ct+=Qe*Hn)>>>16,ct&=65535,Zr+=(ct+=Xe*gn)>>>16,ct&=65535,Zr+=(ct+=st*Lt)>>>16,Zr+=(this.high>>>16)*Hn+Qe*gn+Xe*Lt+st*(R.high>>>16),xe((Vr&=65535)<<16|(rc&=65535),(Zr&=65535)<<16|(ct&=65535),this.unsigned)},ie.mul=ie.multiply,ie.divide=function(R){if(fe(R)||(R=x(R)),R.isZero())throw Error("division by zero");var ke,Qe,Xe;if(Te)return this.unsigned||-2147483648!==this.high||-1!==R.low||-1!==R.high?xe((this.unsigned?Te.div_u:Te.div_s)(this.low,this.high,R.low,R.high),Te.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?Rt:Ye;if(this.unsigned){if(R.unsigned||(R=R.toUnsigned()),R.gt(this))return Rt;if(R.gt(this.shru(1)))return On;Xe=Rt}else{if(this.eq(We))return R.eq(bt)||R.eq(mn)?We:R.eq(We)?bt:(ke=this.shr(1).div(R).shl(1)).eq(Ye)?R.isNegative()?bt:mn:(Qe=this.sub(R.mul(ke)),Xe=ke.add(Qe.div(R)));if(R.eq(We))return this.unsigned?Rt:Ye;if(this.isNegative())return R.isNegative()?this.neg().div(R.neg()):this.neg().div(R).neg();if(R.isNegative())return this.div(R.neg()).neg();Xe=Ye}for(Qe=this;Qe.gte(R);){ke=Math.max(1,Math.floor(Qe.toNumber()/R.toNumber()));for(var jt=Math.ceil(Math.log(ke)/Math.LN2),Lt=jt<=48?1:pe(2,jt-48),gn=de(ke),Hn=gn.mul(R);Hn.isNegative()||Hn.gt(Qe);)Hn=(gn=de(ke-=Lt,this.unsigned)).mul(R);gn.isZero()&&(gn=bt),Xe=Xe.add(gn),Qe=Qe.sub(Hn)}return Xe},ie.div=ie.divide,ie.modulo=function(R){return fe(R)||(R=x(R)),Te?xe((this.unsigned?Te.rem_u:Te.rem_s)(this.low,this.high,R.low,R.high),Te.get_high(),this.unsigned):this.sub(this.div(R).mul(R))},ie.mod=ie.modulo,ie.rem=ie.modulo,ie.not=function(){return xe(~this.low,~this.high,this.unsigned)},ie.and=function(R){return fe(R)||(R=x(R)),xe(this.low&R.low,this.high&R.high,this.unsigned)},ie.or=function(R){return fe(R)||(R=x(R)),xe(this.low|R.low,this.high|R.high,this.unsigned)},ie.xor=function(R){return fe(R)||(R=x(R)),xe(this.low^R.low,this.high^R.high,this.unsigned)},ie.shiftLeft=function(R){return fe(R)&&(R=R.toInt()),0==(R&=63)?this:R<32?xe(this.low<<R,this.high<<R|this.low>>>32-R,this.unsigned):xe(0,this.low<<R-32,this.unsigned)},ie.shl=ie.shiftLeft,ie.shiftRight=function(R){return fe(R)&&(R=R.toInt()),0==(R&=63)?this:R<32?xe(this.low>>>R|this.high<<32-R,this.high>>R,this.unsigned):xe(this.high>>R-32,this.high>=0?0:-1,this.unsigned)},ie.shr=ie.shiftRight,ie.shiftRightUnsigned=function(R){if(fe(R)&&(R=R.toInt()),0==(R&=63))return this;var ve=this.high;return R<32?xe(this.low>>>R|ve<<32-R,ve>>>R,this.unsigned):xe(32===R?ve:ve>>>R-32,0,this.unsigned)},ie.shru=ie.shiftRightUnsigned,ie.shr_u=ie.shiftRightUnsigned,ie.toSigned=function(){return this.unsigned?xe(this.low,this.high,!1):this},ie.toUnsigned=function(){return this.unsigned?this:xe(this.low,this.high,!0)},ie.toBytes=function(R){return R?this.toBytesLE():this.toBytesBE()},ie.toBytesLE=function(){var R=this.high,ve=this.low;return[255&ve,ve>>>8&255,ve>>>16&255,ve>>>24,255&R,R>>>8&255,R>>>16&255,R>>>24]},ie.toBytesBE=function(){var R=this.high,ve=this.low;return[R>>>24,R>>>16&255,R>>>8&255,255&R,ve>>>24,ve>>>16&255,ve>>>8&255,255&ve]},U.fromBytes=function(R,ve,ke){return ke?U.fromBytesLE(R,ve):U.fromBytesBE(R,ve)},U.fromBytesLE=function(R,ve){return new U(R[0]|R[1]<<8|R[2]<<16|R[3]<<24,R[4]|R[5]<<8|R[6]<<16|R[7]<<24,ve)},U.fromBytesBE=function(R,ve){return new U(R[4]<<24|R[5]<<16|R[6]<<8|R[7],R[0]<<24|R[1]<<16|R[2]<<8|R[3],ve)}},340:(Ce,Te,U)=>{var fe=U(471),ht=U(992),se=U(657),tt=U(583),de=U(929),xe=U(83),pe=U(818);pe.alea=fe,pe.xor128=ht,pe.xorwow=se,pe.xorshift7=tt,pe.xor4096=de,pe.tychei=xe,Ce.exports=pe},471:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(x){var N=this,F=function B(){var x=4022871197;return function(F){F=F.toString();for(var D=0;D<F.length;D++){var I=.02519603282416938*(x+=F.charCodeAt(D));I-=x=I>>>0,x=(I*=x)>>>0,x+=4294967296*(I-=x)}return 2.3283064365386963e-10*(x>>>0)}}();N.next=function(){var D=2091639*N.s0+2.3283064365386963e-10*N.c;return N.s0=N.s1,N.s1=N.s2,N.s2=D-(N.c=0|D)},N.c=1,N.s0=F(" "),N.s1=F(" "),N.s2=F(" "),N.s0-=F(x),N.s0<0&&(N.s0+=1),N.s1-=F(x),N.s1<0&&(N.s1+=1),N.s2-=F(x),N.s2<0&&(N.s2+=1),F=null}function xe(x,N){return N.c=x.c,N.s0=x.s0,N.s1=x.s1,N.s2=x.s2,N}function pe(x,N){var F=new de(x),D=N&&N.state,I=F.next;return I.int32=function(){return 4294967296*F.next()|0},I.double=function(){return I()+11102230246251565e-32*(2097152*I()|0)},I.quick=I,D&&("object"==typeof D&&xe(D,F),I.state=function(){return xe(F,{})}),I}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.alea=pe}(0,Ce=U.nmd(Ce))},83:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this,N="";x.next=function(){var D=x.b,I=x.c,H=x.d,q=x.a;return D=D<<25^D>>>7^I,I=I-H|0,H=H<<24^H>>>8^q,q=q-D|0,x.b=D=D<<20^D>>>12^I,x.c=I=I-H|0,x.d=H<<16^I>>>16^q,x.a=q-D|0},x.a=0,x.b=0,x.c=-1640531527,x.d=1367130551,B===Math.floor(B)?(x.a=B/4294967296|0,x.b=0|B):N+=B;for(var F=0;F<N.length+20;F++)x.b^=0|N.charCodeAt(F),x.next()}function xe(B,x){return x.a=B.a,x.b=B.b,x.c=B.c,x.d=B.d,x}function pe(B,x){var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&("object"==typeof F&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.tychei=pe}(0,Ce=U.nmd(Ce))},992:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this,N="";x.x=0,x.y=0,x.z=0,x.w=0,x.next=function(){var D=x.x^x.x<<11;return x.x=x.y,x.y=x.z,x.z=x.w,x.w^=x.w>>>19^D^D>>>8},B===(0|B)?x.x=B:N+=B;for(var F=0;F<N.length+64;F++)x.x^=0|N.charCodeAt(F),x.next()}function xe(B,x){return x.x=B.x,x.y=B.y,x.z=B.z,x.w=B.w,x}function pe(B,x){var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&("object"==typeof F&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.xor128=pe}(0,Ce=U.nmd(Ce))},929:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this;x.next=function(){var H,q,F=x.w,D=x.X,I=x.i;return x.w=F=F+1640531527|0,q=D[I+34&127],H=D[I=I+1&127],q^=q<<13,H^=H<<17,q=D[I]=(q^=q>>>15)^(H^=H>>>12),x.i=I,q+(F^F>>>16)|0},function N(F,D){var I,H,q,Ye,Rt,bt=[],On=128;for(D===(0|D)?(H=D,D=null):(D+="\0",H=0,On=Math.max(On,D.length)),q=0,Ye=-32;Ye<On;++Ye)D&&(H^=D.charCodeAt((Ye+32)%D.length)),0===Ye&&(Rt=H),H^=H<<10,H^=H>>>15,H^=H<<4,H^=H>>>13,Ye>=0&&(q=0==(I=bt[127&Ye]^=H+(Rt=Rt+1640531527|0))?q+1:0);for(q>=128&&(bt[127&(D&&D.length||0)]=-1),q=127,Ye=512;Ye>0;--Ye)H=bt[q+34&127],I=bt[q=q+1&127],H^=H<<13,I^=I<<17,bt[q]=(H^=H>>>15)^(I^=I>>>12);F.w=Rt,F.X=bt,F.i=q}(x,B)}function xe(B,x){return x.i=B.i,x.w=B.w,x.X=B.X.slice(),x}function pe(B,x){null==B&&(B=+new Date);var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&(F.X&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.xor4096=pe}(0,Ce=U.nmd(Ce))},583:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this;x.next=function(){var I,H,F=x.x,D=x.i;return I=F[D],H=(I^=I>>>7)^I<<24,H^=(I=F[D+1&7])^I>>>10,H^=(I=F[D+3&7])^I>>>3,H^=(I=F[D+4&7])^I<<7,I=F[D+7&7],F[D]=H^=(I^=I<<13)^I<<9,x.i=D+1&7,H},function N(F,D){var I,q=[];if(D===(0|D))q[0]=D;else for(D=""+D,I=0;I<D.length;++I)q[7&I]=q[7&I]<<15^D.charCodeAt(I)+q[I+1&7]<<13;for(;q.length<8;)q.push(0);for(I=0;I<8&&0===q[I];++I);for(8==I&&(q[7]=-1),F.x=q,F.i=0,I=256;I>0;--I)F.next()}(x,B)}function xe(B,x){return x.x=B.x.slice(),x.i=B.i,x}function pe(B,x){null==B&&(B=+new Date);var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&(F.x&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.xorshift7=pe}(0,Ce=U.nmd(Ce))},657:function(Ce,Te,U){var fe;!function(ht,se,tt){function de(B){var x=this,N="";x.next=function(){var D=x.x^x.x>>>2;return x.x=x.y,x.y=x.z,x.z=x.w,x.w=x.v,(x.d=x.d+362437|0)+(x.v=x.v^x.v<<4^D^D<<1)|0},x.x=0,x.y=0,x.z=0,x.w=0,x.v=0,B===(0|B)?x.x=B:N+=B;for(var F=0;F<N.length+64;F++)x.x^=0|N.charCodeAt(F),F==N.length&&(x.d=x.x<<10^x.x>>>4),x.next()}function xe(B,x){return x.x=B.x,x.y=B.y,x.z=B.z,x.w=B.w,x.v=B.v,x.d=B.d,x}function pe(B,x){var N=new de(B),F=x&&x.state,D=function(){return(N.next()>>>0)/4294967296};return D.double=function(){do{var q=((N.next()>>>11)+(N.next()>>>0)/4294967296)/(1<<21)}while(0===q);return q},D.int32=N.next,D.quick=D,F&&("object"==typeof F&&xe(F,N),D.state=function(){return xe(N,{})}),D}se&&se.exports?se.exports=pe:U.amdD&&U.amdO?void 0!==(fe=function(){return pe}.call(Te,U,Te,se))&&(se.exports=fe):this.xorwow=pe}(0,Ce=U.nmd(Ce))},818:(Ce,Te,U)=>{var fe;!function(ht,se){var I,tt=(0,eval)("this"),de=256,B="random",x=se.pow(de,6),N=se.pow(2,52),F=2*N,D=255;function H(_e,Ee,We){var ie=[],Y=bt(Rt((Ee=1==Ee?{entropy:!0}:Ee||{}).entropy?[_e,mn(ht)]:null==_e?function On(){try{var _e;return I&&(_e=I.randomBytes)?_e=_e(de):(_e=new Uint8Array(de),(tt.crypto||tt.msCrypto).getRandomValues(_e)),mn(_e)}catch(ie){var Ee=tt.navigator,We=Ee&&Ee.plugins;return[+new Date,tt,We,tt.screen,mn(ht)]}}():_e,3),ie),R=new q(ie),ve=function(){for(var ke=R.g(6),Qe=x,Xe=0;ke<N;)ke=(ke+Xe)*de,Qe*=de,Xe=R.g(1);for(;ke>=F;)ke/=2,Qe/=2,Xe>>>=1;return(ke+Xe)/Qe};return ve.int32=function(){return 0|R.g(4)},ve.quick=function(){return R.g(4)/4294967296},ve.double=ve,bt(mn(R.S),ht),(Ee.pass||We||function(ke,Qe,Xe,st){return st&&(st.S&&Ye(st,R),ke.state=function(){return Ye(R,{})}),Xe?(se[B]=ke,Qe):ke})(ve,Y,"global"in Ee?Ee.global:this==se,Ee.state)}function q(_e){var Ee,We=_e.length,ie=this,Y=0,R=ie.i=ie.j=0,ve=ie.S=[];for(We||(_e=[We++]);Y<de;)ve[Y]=Y++;for(Y=0;Y<de;Y++)ve[Y]=ve[R=D&R+_e[Y%We]+(Ee=ve[Y])],ve[R]=Ee;(ie.g=function(ke){for(var Qe,Xe=0,st=ie.i,jt=ie.j,Lt=ie.S;ke--;)Qe=Lt[st=D&st+1],Xe=Xe*de+Lt[D&(Lt[st]=Lt[jt=D&jt+Qe])+(Lt[jt]=Qe)];return ie.i=st,ie.j=jt,Xe})(de)}function Ye(_e,Ee){return Ee.i=_e.i,Ee.j=_e.j,Ee.S=_e.S.slice(),Ee}function Rt(_e,Ee){var Y,We=[],ie=typeof _e;if(Ee&&"object"==ie)for(Y in _e)try{We.push(Rt(_e[Y],Ee-1))}catch(R){}return We.length?We:"string"==ie?_e:_e+"\0"}function bt(_e,Ee){for(var ie,We=_e+"",Y=0;Y<We.length;)Ee[D&Y]=D&(ie^=19*Ee[D&Y])+We.charCodeAt(Y++);return mn(Ee)}function mn(_e){return String.fromCharCode.apply(0,_e)}if(se["seed"+B]=H,bt(se.random(),ht),Ce.exports){Ce.exports=H;try{I=U(42)}catch(_e){}}else void 0!==(fe=function(){return H}.call(Te,U,Te,Ce))&&(Ce.exports=fe)}([],Math)},914:()=>{},410:()=>{},628:()=>{},778:()=>{},601:()=>{},792:()=>{},977:()=>{},42:()=>{}},Ce=>{Ce(Ce.s=878)}]);